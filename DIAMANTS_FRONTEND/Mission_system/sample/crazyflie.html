<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIAMANTS V3 - Crazyflie Gazebo Simulation (Vrais Mesh)</title>
    <link rel="icon" href="data:,">

    <!-- CSS Anti-Split Forc√© -->
    <style>
        /* FORCER PLEIN ECRAN - ANTI SPLIT RADICAL */
        html {
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }

        body::before {
            content: '';
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
            z-index: -1000 !important;
        }

        /* Masquer toute interface syst√®me */
        ::-webkit-scrollbar {
            display: none !important;
        }

        * {
            user-select: none;
            -webkit-user-drag: none;
        }
    </style>

    <style>
        /* Forcer l'occupation compl√®te de l'√©cran */
        html,
        body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            overflow: hidden !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
            color: #00FFFF;
        }

        /* Emp√™cher tout type de split ou redimensionnement */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            overflow: hidden;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
            color: #00FFFF;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Interface ROS2/Gazebo-like */
        #ros_interface {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 350px !important;
            height: 100vh !important;
            background: linear-gradient(180deg, rgba(40, 44, 52, 0.95), rgba(25, 30, 40, 0.95));
            backdrop-filter: blur(10px);
            border-right: 2px solid #00CCFF;
            z-index: 100 !important;
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        .ros_panel {
            background: rgba(60, 70, 80, 0.8);
            border: 1px solid #00AAFF;
            border-radius: 8px;
            margin: 10px 0;
            padding: 12px;
        }

        .ros_panel h3 {
            margin: 0 0 10px 0;
            color: #00FFFF;
            font-size: 14px;
            text-transform: uppercase;
            border-bottom: 1px solid #00AAFF;
            padding-bottom: 5px;
        }

        .mission_control {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .btn_ros {
            padding: 8px 12px;
            background: linear-gradient(45deg, #1e3a8a, #3b82f6);
            color: white;
            border: 1px solid #60a5fa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
        }

        .btn_ros:hover {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.6);
            transform: translateY(-1px);
        }

        .btn_ros.active {
            background: linear-gradient(45deg, #059669, #10b981);
            border-color: #34d399;
        }

        .drone_status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 3px 0;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            border-left: 3px solid #00FF88;
            font-size: 11px;
        }

        .drone_status.inactive {
            border-left-color: #FF4444;
            opacity: 0.6;
        }

        .metric_display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 10px;
        }

        .metric_item {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }

        .metric_value {
            color: #00FF88;
            font-weight: bold;
            font-size: 12px;
        }

        .ros_button {
            background: linear-gradient(45deg, #00AAFF, #0088CC);
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 4px 2px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .ros_button:hover {
            background: linear-gradient(45deg, #00CCFF, #00AAFF);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 170, 255, 0.4);
        }

        .ros_button.emergency {
            background: linear-gradient(45deg, #FF4444, #CC2222);
        }

        .ros_button.emergency:hover {
            background: linear-gradient(45deg, #FF6666, #FF4444);
        }

        .topic_monitor {
            font-family: 'Roboto Mono', monospace;
            font-size: 9px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 6px;
            margin: 5px 0;
            border-left: 3px solid #FFD700;
            max-height: 120px;
            overflow-y: auto;
        }

        .collision_warning {
            background: linear-gradient(45deg, rgba(255, 0, 0, 0.2), rgba(255, 100, 0, 0.2));
            border: 1px solid #FF4444;
            color: #FF8888;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.8;
            }

            50% {
                opacity: 1.0;
            }
        }

        .emergence_indicator {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }

        .emergence_bar {
            height: 100%;
            background: linear-gradient(90deg, #00FF88, #00FFFF, #FFD700);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .metric_bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .metric_fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF88, #00CCFF);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .metric_value {
            font-size: 11px;
            color: #AAFFCC;
            margin: 2px 0;
        }

        #canvas_container {
            position: fixed !important;
            top: 0 !important;
            left: 350px !important;
            width: calc(100vw - 350px) !important;
            height: 100vh !important;
            z-index: 10 !important;
            overflow: hidden !important;
        }

        #status_display {
            position: fixed;
            bottom: 270px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            color: #00FFFF;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #00AAFF;
            font-size: 12px;
            z-index: 200;
        }

        /* Minimap - Toujours visible et bien positionn√©e */
        #minimap {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 220px;
            height: 220px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00AAFF;
            border-radius: 8px;
            z-index: 150;
            display: block;
        }

        #minimap canvas {
            width: calc(100% - 10px);
            height: calc(100% - 35px);
            margin: 5px;
            border-radius: 6px;
            background: #87CEEB;
        }

        #minimap h4 {
            margin: 0;
            padding: 5px;
            background: rgba(0, 170, 255, 0.8);
            color: white;
            font-size: 12px;
            text-align: center;
            border-radius: 6px 6px 0 0;
        }

        .loading_status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00FFFF;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00AAFF;
            text-align: center;
            z-index: 300;
        }
    </style>
</head>

<body>
    <!-- Loading screen -->
    <div id="loading_screen" class="loading_status">
        <h3>üöÅ Chargement DIAMANTS V3 Gazebo</h3>
        <p>Chargement des mesh Crazyflie...</p>
        <div id="loading_progress">0%</div>
    </div>

    <!-- Interface ROS2/Gazebo -->
    <div id="ros_interface">
        <!-- Mission Control Panel -->
        <div class="ros_panel">
            <h3>üöÅ Mission Control</h3>
            <div class="mission_control">
                <button class="btn_ros" onclick="launchMission()">Launch Mission</button>
                <button class="btn_ros" onclick="emergencyLand()">Emergency Land</button>
                <button class="btn_ros" onclick="resetSwarm()">Reset Swarm</button>
                <button class="btn_ros" onclick="changePattern()">üåü Pattern</button>
            </div>
            <div>
                <label>Mission Type:</label>
                <select id="mission_type"
                    style="width: 100%; padding: 4px; margin: 5px 0; background: #2a2a2a; color: #fff; border: 1px solid #666;">
                    <option value="exploration">Exploration</option>
                    <option value="mapping">SLAM Mapping</option>
                    <option value="surveillance">Surveillance</option>
                    <option value="formation_flight">Formation Flight</option>
                </select>
            </div>
            <div>
                <label>Pattern: <span class="value" id="currentPattern">grid</span></label>
            </div>
        </div>

        <!-- Drone Status Panel -->
        <div class="ros_panel">
            <h3>ü§ñ Drone Status (/odom topics)</h3>
            <div id="drone_status_list">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- DIAMANTS Metrics Panel -->
        <div class="ros_panel">
            <h3>üß† DIAMANTS Intelligence Metrics</h3>
            <div class="metric_display">
                <div class="metric_item">
                    <div>Total I(t)</div>
                    <div class="metric_value" id="total_intelligence">0.0</div>
                </div>
                <div class="metric_item">
                    <div>Emergence</div>
                    <div class="metric_value" id="emergence_level">0.0</div>
                </div>
                <div class="metric_item">
                    <div>Cohesion</div>
                    <div class="metric_value" id="cohesion_index">0.0</div>
                </div>
                <div class="metric_item">
                    <div>Coordination</div>
                    <div class="metric_value" id="coordination_score">0.0</div>
                </div>
            </div>
            <div class="emergence_indicator">
                <div class="emergence_bar" id="emergence_bar" style="width: 0%"></div>
            </div>
        </div>

        <!-- Mission Metrics Panel -->
        <div class="ros_panel">
            <h3>üéØ Mission Progress</h3>
            <div class="metrics_grid">
                <div class="metric_item">
                    <div>Coverage</div>
                    <div class="metric_value" id="mission_coverage">0.0%</div>
                </div>
                <div class="metric_item">
                    <div>Targets</div>
                    <div class="metric_value" id="targets_discovered">0/0</div>
                </div>
                <div class="metric_item">
                    <div>Efficiency</div>
                    <div class="metric_value" id="mission_efficiency">0.0%</div>
                </div>
                <div class="metric_item">
                    <div>Speed</div>
                    <div class="metric_value" id="exploration_speed">0.00 zones/min</div>
                </div>
            </div>
        </div>

        <!-- Camera Controls Panel -->
        <div class="ros_panel">
            <h3>üìπ Camera Controls</h3>
            <div class="mission_control">
                <button class="btn_ros" onclick="resetCamera()">Reset View</button>
                <button class="btn_ros" onclick="topView()">Top View</button>
                <button class="btn_ros" onclick="toggleFollowMode()">Follow Mode</button>
                <button class="btn_ros" onclick="zoomToSwarm()">View All</button>
            </div>
            <div>
                <label>Select Drone to Follow:</label>
                <select id="drone_selector" onchange="selectDroneToFollow()"
                    style="width: 100%; padding: 4px; margin: 5px 0; background: #2a2a2a; color: #fff; border: 1px solid #666;">
                    <option value="">No Selection</option>
                </select>
            </div>
        </div>

        <!-- Anti-Collision System -->
        <div class="ros_panel">
            <h3>‚ö†Ô∏è Anti-Collision DIAMANTS</h3>
            <div id="collision_warnings">
                <div style="font-size: 10px; color: #888;">No collision warnings</div>
            </div>
            <div style="margin: 10px 0;">
                <label>Safety Distance (m):</label>
                <input type="range" id="safety_distance" min="1" max="10" value="3" style="width: 100%;"
                    onchange="updateSafetyDistance(this.value)">
                <span id="safety_distance_value">3.0m</span>
            </div>
        </div>

        <!-- Topic Monitor -->
        <div class="ros_panel">
            <h3>üì° ROS2 Topics Monitor</h3>
            <div class="topic_monitor" id="topic_monitor">
                <div>[INFO] Multi-agent framework initialized</div>
                <div>[INFO] Waiting for drone connections...</div>
            </div>
        </div>

        <!-- Swarm Formation Panel -->
        <div class="ros_panel">
            <h3>üî¢ Formation Control</h3>
            <div class="mission_control">
                <button class="btn_ros" onclick="setFormation('line')">Line</button>
                <button class="btn_ros" onclick="setFormation('circle')">Circle</button>
                <button class="btn_ros" onclick="setFormation('triangle')">Triangle</button>
                <button class="btn_ros" onclick="setFormation('grid')">Grid</button>
            </div>
        </div>

        <!-- Drone Modes (from victoire) -->
        <div class="ros_panel">
            <h3>üåü Drone Modes</h3>
            <div>
                <label>Mode:</label>
                <select id="mode_select"
                    style="width: 100%; padding: 4px; margin: 5px 0; background: #2a2a2a; color: #fff; border: 1px solid #666;">
                    <option value="grid">Grid</option>
                    <option value="boustrophedon">Boustrophedon</option>
                    <option value="spiral">Spiral</option>
                    <option value="coverage">Coverage</option>
                    <option value="follow_leader">Follow Leader</option>
                    <option value="random">Random</option>
                </select>
                <button class="btn_ros" onclick="applyMode()">Apply Mode</button>
            </div>
        </div>

        <!-- Intelligence Collective Panel -->
        <div class="ros_panel">
            <h3>ÔøΩ Intelligence Collective</h3>
            <div class="metric_display">
                <div class="metric_item">
                    <div>Stigmergie</div>
                    <div class="metric_value" id="stigmergy_value">0</div>
                </div>
                <div class="metric_item">
                    <div>Consensus</div>
                    <div class="metric_value" id="consensus_value">0</div>
                </div>
                <div class="metric_item">
                    <div>Communication</div>
                    <div class="metric_value" id="communication_value">0.0</div>
                </div>
                <div class="metric_item">
                    <div>Adaptation</div>
                    <div class="metric_value" id="adaptation_value">0%</div>
                </div>
            </div>
        </div>
    </div>
    <div class="metric_bar">
        <div id="phi_bar" class="metric_fill" style="width: 0%"></div>
    </div>

    <div class="metric_value">Sigma (œÉ): <span id="sigma_value">0.00</span></div>
    <div class="metric_bar">
        <div id="sigma_bar" class="metric_fill" style="width: 0%"></div>
    </div>

    <div class="metric_value">Emergence: <span id="emergence_value">0.00</span></div>
    <div class="metric_bar">
        <div id="emergence_bar" class="metric_fill" style="width: 0%"></div>
    </div>
    </div>

    <div class="ros_panel">
        <h3>‚öôÔ∏è System</h3>
        <div class="metric_value">Status: <span style="color: #00FF88;">GAZEBO</span></div>
        <div class="metric_value">FPS: <span id="fps_display">60</span></div>
        <div class="metric_value">Mesh: <span style="color: #FFAA00;">COLLADA</span></div>
        <button class="ros_button" onclick="toggleMinimap()">üìã Minimap</button>
        <button class="ros_button" onclick="toggleSAROverlay()">üß≠ SAR Lanes</button>
    </div>
    </div>

    <!-- Zone de rendu 3D -->
    <div id="canvas_container"></div>

    <!-- Minimap -->
    <div id="minimap">
        <h4>üéØ Tactical Overview - Mission Intel</h4>
        <canvas id="minimap_canvas" width="180" height="170"></canvas>
    </div>

    <!-- Status Display -->
    <div id="status_display">
        üöÅ DIAMANTS V3 - Gazebo Style avec Mesh R√©els<br>
        <span id="system_status">Initializing...</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/ColladaLoader.js"></script>
    <script>
        // ===== DIAMANTS V3 - GAZEBO MESH AVEC ROS2 & INTELLIGENCE COLLECTIVE =====

        // V√©rification Three.js
        if (typeof THREE === 'undefined') {
            console.error('‚ùå THREE.js non charg√©! V√©rifiez votre connexion internet.');
            document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 50px;">‚ùå Erreur: THREE.js non charg√©!</h1>';
        } else {
            console.log('‚úÖ THREE.js charg√©, version:', THREE.REVISION);
        }

        // ===== PATTERNS DE RECHERCHE ET VARIABLES GLOBALES =====
        const SEARCH_PATTERNS = ['grid', 'boustrophedon', 'spiral', 'coverage', 'follow_leader', 'random'];
        let currentSearchPattern = 0;
        let isRunning = false;

        let startTime = Date.now();
        let showMinimap = true;

        // Variables de sc√®ne globales
        let scene, camera, renderer;
        let drones = [];
        // Expose l'essaim globalement pour SwarmMemory (utilise window.drones)
        window.drones = drones;
        let SWARM_MEMORY = null;
        let colladaLoader = null;
        let minimapCanvas, minimapCtx;
        let minimapVisible = true;

        // ===== MAPPING ET EXPLORATION AVANC√âE =====
        let explorationMap = [];
        let scoutingTargets = [];
        let trees = [];
        let forestObstacles = [];

        // Initialiser la grille d'exploration
        function initializeExplorationMap() {
            explorationMap = Array(CONFIG.explorationGrid).fill().map(() => Array(CONFIG.explorationGrid).fill(0));
            console.log(`üó∫Ô∏è Grille d'exploration initialis√©e: ${CONFIG.explorationGrid}x${CONFIG.explorationGrid}`);
        }

        // Cr√©er des cibles de scouting
        function createScoutingTargets() {
            scoutingTargets = [];
            const numTargets = 12;

            for (let i = 0; i < numTargets; i++) {
                const target = {
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.zoneSize * 0.8,
                        0.1,
                        (Math.random() - 0.5) * CONFIG.zoneSize * 0.8
                    ),
                    value: Math.random() * 50 + 25,
                    discovered: false,
                    discoveredBy: null,
                    discoveryTime: null
                };
                scoutingTargets.push(target);
            }

            console.log(`üéØ ${numTargets} cibles de scouting cr√©√©es`);
        }

        // Variables Gazebo syst√®me
        let positionCoordinator;
        let swarmMemory;
        let diamantMetrics;

        // ===== ROS2-LIKE COMMUNICATION SYSTEM =====
        class ROSNode {
            constructor(name) {
                this.name = name;
                this.subscribers = new Map();
                this.publishers = new Map();
                this.topics = new Map();
                this.active = true;
            }

            subscribe(topic, callback) {
                if (!this.subscribers.has(topic)) {
                    this.subscribers.set(topic, []);
                }
                this.subscribers.get(topic).push(callback);
                // Register on global ROS bus so other nodes can publish to this subscriber
                if (!rosSystem.subscribers.has(topic)) {
                    rosSystem.subscribers.set(topic, []);
                }
                rosSystem.subscribers.get(topic).push(callback);
                this.logTopic(`Subscribed to ${topic}`);
            }

            publish(topic, message) {
                if (!this.topics.has(topic)) {
                    this.topics.set(topic, []);
                }
                this.topics.get(topic).push({
                    timestamp: Date.now(),
                    data: message,
                    node: this.name
                });

                // Distribute to subscribers
                if (rosSystem.subscribers.has(topic)) {
                    rosSystem.subscribers.get(topic).forEach(callback => {
                        try {
                            callback(message);
                        } catch (error) {
                            console.error(`Error in subscriber for ${topic}:`, error);
                        }
                    });
                }
            }

            logTopic(message) {
                const monitor = document.getElementById('topic_monitor');
                if (monitor) {
                    const now = new Date().toLocaleTimeString();
                    monitor.innerHTML += `<div>[${now}] ${this.name}: ${message}</div>`;
                    monitor.scrollTop = monitor.scrollHeight;

                    // Limit log size
                    const lines = monitor.children;
                    if (lines.length > 50) {
                        monitor.removeChild(lines[0]);
                    }
                }
            }
        }

        // Global ROS2 System
        const rosSystem = {
            nodes: new Map(),
            subscribers: new Map(),
            globalSubscribe: function (topic, callback) {
                if (!this.subscribers.has(topic)) {
                    this.subscribers.set(topic, []);
                }
                this.subscribers.get(topic).push(callback);
            }
        };

        // ===== MULTI-AGENT FRAMEWORK (like drone_position_coordinator.py) =====
        class DronePositionCoordinator extends ROSNode {
            constructor() {
                super('drone_position_coordinator');
                this.dronePositions = new Map();
                this.lastUpdate = new Map();
                this.minDistance = 3.0;
                this.collisionWarnings = new Set();

                // Subscribe to all drone odometry topics
                for (let i = 0; i < 8; i++) {
                    const droneName = `crazyflie${i === 0 ? '' : i}`;
                    this.subscribe(`/${droneName}/odom`, (msg) => {
                        this.updateDronePosition(droneName, msg);
                    });
                }

                setInterval(() => this.checkCoordination(), 2000);
                this.logTopic('Multi-agent coordinator initialized');
            }

            updateDronePosition(droneName, odometryMsg) {
                // Handle ROS2 odom message structure (pose.pose.position) or simpler structures
                const position = odometryMsg.pose?.pose?.position || odometryMsg.position;
                if (!position) {
                    console.warn(`Received odom for ${droneName} with no position data.`);
                    return;
                }
                this.dronePositions.set(droneName, {
                    x: position.x,
                    y: position.y,
                    z: position.z,
                    timestamp: Date.now()
                });
                this.lastUpdate.set(droneName, Date.now());
            }

            checkCoordination() {
                const currentTime = Date.now();
                const activeDrones = [];

                for (const [droneName, lastTime] of this.lastUpdate.entries()) {
                    if (currentTime - lastTime < 5000) {
                        activeDrones.push(droneName);
                    }
                }

                this.logTopic(`Active drones: ${activeDrones.length}`);
                this.updateDroneStatusDisplay(activeDrones);

                this.collisionWarnings.clear();
                for (let i = 0; i < activeDrones.length; i++) {
                    for (let j = i + 1; j < activeDrones.length; j++) {
                        const drone1 = activeDrones[i];
                        const drone2 = activeDrones[j];

                        if (this.dronePositions.has(drone1) && this.dronePositions.has(drone2)) {
                            const distance = this.calculateDistance(
                                this.dronePositions.get(drone1),
                                this.dronePositions.get(drone2)
                            );

                            if (distance < this.minDistance) {
                                const warning = `${drone1} ‚Üî ${drone2} (${distance.toFixed(2)}m)`;
                                this.collisionWarnings.add(warning);
                                this.logTopic(`‚ö†Ô∏è COLLISION WARNING: ${warning}`);
                            }
                        }
                    }
                }

                this.updateCollisionDisplay();
            }

            calculateDistance(pos1, pos2) {
                return Math.sqrt(
                    Math.pow(pos1.x - pos2.x, 2) +
                    Math.pow(pos1.y - pos2.y, 2) +
                    Math.pow(pos1.z - pos2.z, 2)
                );
            }

            updateDroneStatusDisplay(activeDrones) {
                const statusList = document.getElementById('drone_status_list');
                if (!statusList) return;

                statusList.innerHTML = '';
                for (let i = 0; i < 8; i++) {
                    const droneName = `crazyflie${i === 0 ? '' : i}`;
                    const isActive = activeDrones.includes(droneName);
                    const pos = this.dronePositions.get(droneName);

                    const statusDiv = document.createElement('div');
                    statusDiv.className = `drone_status ${isActive ? '' : 'inactive'}`;
                    statusDiv.innerHTML = `
                        <span>${droneName}</span>
                        <span>${isActive && pos ?
                            `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})` :
                            'OFFLINE'}</span>
                    `;
                    statusList.appendChild(statusDiv);
                }
            }

            updateCollisionDisplay() {
                const warningsDiv = document.getElementById('collision_warnings');
                if (!warningsDiv) return;

                if (this.collisionWarnings.size === 0) {
                    warningsDiv.innerHTML = '<div style="font-size: 10px; color: #00FF88;">‚úÖ All safety distances respected</div>';
                } else {
                    warningsDiv.innerHTML = '';
                    for (const warning of this.collisionWarnings) {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'collision_warning';
                        warningDiv.style.cssText = 'font-size: 10px; padding: 4px; margin: 2px 0; border-radius: 4px;';
                        warningDiv.textContent = `‚ö†Ô∏è ${warning}`;
                        warningsDiv.appendChild(warningDiv);
                    }
                }
            }

            setSafetyDistance(distance) {
                this.minDistance = distance;
                this.logTopic(`Safety distance updated to ${distance}m`);
            }
        }

        // ===== DIAMANTS INTELLIGENCE METRICS =====
        class DiamantMetrics {
            constructor() {
                this.totalIntelligence = 0;
                this.emergenceLevel = 0;
                this.cohesionIndex = 0;
                this.coordinationScore = 0;
                this.updateInterval = 100;

                setTimeout(() => {
                    setInterval(() => this.updateMetrics(), this.updateInterval);
                }, 1000);
            }

            updateMetrics() {
                if (!window.drones || window.drones.length === 0) return;

                this.totalIntelligence = window.drones.reduce((sum, drone) => {
                    return sum + (drone.intelligence || 0);
                }, 0);

                const averageIntelligence = this.totalIntelligence / window.drones.length;
                this.emergenceLevel = Math.min(100, averageIntelligence * 2.5);

                let totalDistance = 0;
                let pairCount = 0;
                for (let i = 0; i < window.drones.length; i++) {
                    for (let j = i + 1; j < window.drones.length; j++) {
                        const dist = window.drones[i].position.distanceTo(window.drones[j].position);
                        totalDistance += dist;
                        pairCount++;
                    }
                }
                const averageDistance = pairCount > 0 ? totalDistance / pairCount : 0;
                this.cohesionIndex = Math.max(0, 100 - averageDistance * 2);

                let alignment = 0;
                for (let i = 0; i < window.drones.length; i++) {
                    for (let j = i + 1; j < window.drones.length; j++) {
                        const vel1 = window.drones[i].velocity.clone();
                        const vel2 = window.drones[j].velocity.clone();

                        if (vel1.length() > 0.01 && vel2.length() > 0.01) {
                            const dot = vel1.normalize().dot(vel2.normalize());
                            alignment += (dot + 1) * 50;
                        }
                    }
                }
                this.coordinationScore = pairCount > 0 ? alignment / pairCount : 0;

                this.updateUI();
            }

            updateUI() {
                const elements = {
                    'total_intelligence': this.totalIntelligence.toFixed(1),
                    'emergence_level': this.emergenceLevel.toFixed(1),
                    'cohesion_index': this.cohesionIndex.toFixed(1),
                    'coordination_score': this.coordinationScore.toFixed(1)
                };

                for (const [id, value] of Object.entries(elements)) {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                }

                const emergeBar = document.getElementById('emergence_bar');
                if (emergeBar) {
                    emergeBar.style.width = `${this.emergenceLevel}%`;
                }
            }
        }

        // ===== SYST√àME DE R√âSEAUX DE NEURONES AVANC√â =====
        class NeuralNetwork {
            constructor(inputSize, hiddenSizes, outputSize) {
                this.layers = [];
                this.activations = [];

                // Construction des couches
                let layerSizes = [inputSize, ...hiddenSizes, outputSize];
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    this.layers.push(this.createLayer(layerSizes[i], layerSizes[i + 1]));
                }

                this.learningRate = CONFIG.AI.learningRate;
                console.log(`üß† R√©seau de neurones cr√©√©: ${layerSizes.join(' ‚Üí ')}`);
            }

            createLayer(inputSize, outputSize) {
                const layer = {
                    weights: [],
                    biases: new Array(outputSize).fill(0).map(() => Math.random() * 0.2 - 0.1)
                };

                for (let i = 0; i < outputSize; i++) {
                    layer.weights[i] = new Array(inputSize).fill(0).map(() => Math.random() * 0.2 - 0.1);
                }

                return layer;
            }

            activate(x) {
                return Math.tanh(x); // Fonction d'activation
            }

            activateDerivative(x) {
                const tanh = Math.tanh(x);
                return 1 - tanh * tanh;
            }

            forward(inputs) {
                let currentInputs = [...inputs];
                this.activations = [currentInputs];

                for (let layer of this.layers) {
                    const outputs = [];
                    for (let i = 0; i < layer.biases.length; i++) {
                        let sum = layer.biases[i];
                        for (let j = 0; j < currentInputs.length; j++) {
                            sum += currentInputs[j] * layer.weights[i][j];
                        }
                        outputs.push(this.activate(sum));
                    }
                    currentInputs = outputs;
                    this.activations.push([...outputs]);
                }

                return currentInputs;
            }

            train(inputs, expectedOutputs) {
                // Forward pass
                const outputs = this.forward(inputs);

                // Backpropagation
                let errors = expectedOutputs.map((expected, i) => expected - outputs[i]);

                for (let layerIndex = this.layers.length - 1; layerIndex >= 0; layerIndex--) {
                    const layer = this.layers[layerIndex];
                    const layerInputs = this.activations[layerIndex];
                    const layerOutputs = this.activations[layerIndex + 1];

                    const newErrors = new Array(layerInputs.length).fill(0);

                    for (let i = 0; i < layer.biases.length; i++) {
                        const outputError = errors[i];
                        const derivative = this.activateDerivative(layerOutputs[i]);
                        const delta = outputError * derivative;

                        // Mise √† jour des poids et biais
                        layer.biases[i] += this.learningRate * delta;

                        for (let j = 0; j < layerInputs.length; j++) {
                            layer.weights[i][j] += this.learningRate * delta * layerInputs[j];
                            newErrors[j] += delta * layer.weights[i][j];
                        }
                    }

                    errors = newErrors;
                }

                return outputs;
            }
        }

        // ===== SYST√àME D'EXPERTISE √âMERGENTE =====
        class ExpertiseSystem {
            constructor(droneId) {
                this.droneId = droneId;
                this.specializations = new Map();
                this.knowledgeBase = new Map();
                this.experienceCounter = 0;
                this.teachingHistory = [];

                // Domaines d'expertise possibles
                this.expertiseDomains = [
                    'navigation', 'obstacle_avoidance', 'target_detection',
                    'communication', 'energy_optimization', 'formation_flight',
                    'risk_assessment', 'path_planning', 'sensor_fusion'
                ];

                // Initialiser les niveaux d'expertise
                this.expertiseDomains.forEach(domain => {
                    this.specializations.set(domain, Math.random() * 0.3); // D√©marrage al√©atoire faible
                });
            }

            updateExpertise(domain, success, difficultyLevel = 1.0) {
                if (!this.specializations.has(domain)) return;

                const currentLevel = this.specializations.get(domain);
                const learningRate = CONFIG.AI.learningRate * difficultyLevel;
                const improvement = success ? learningRate : -learningRate * 0.5;

                const newLevel = Math.max(0, Math.min(1, currentLevel + improvement));
                this.specializations.set(domain, newLevel);

                this.experienceCounter++;

                // Stockage de l'exp√©rience
                if (!this.knowledgeBase.has(domain)) {
                    this.knowledgeBase.set(domain, []);
                }
                this.knowledgeBase.get(domain).push({
                    success,
                    difficulty: difficultyLevel,
                    timestamp: Date.now(),
                    context: this.getCurrentContext()
                });

                // Nettoyage de l'historique (garder seulement les 100 derni√®res)
                if (this.knowledgeBase.get(domain).length > 100) {
                    this.knowledgeBase.get(domain).shift();
                }
            }

            getExpertiseLevel(domain) {
                return this.specializations.get(domain) || 0;
            }

            getBestSpecialization() {
                let maxLevel = 0;
                let bestDomain = null;

                for (let [domain, level] of this.specializations) {
                    if (level > maxLevel) {
                        maxLevel = level;
                        bestDomain = domain;
                    }
                }

                return bestDomain;
            }

            canTeach(domain) {
                return this.getExpertiseLevel(domain) > CONFIG.AI.expertiseThreshold;
            }

            teachOtherDrone(otherExpertiseSystem, domain) {
                if (!this.canTeach(domain)) return false;

                const myLevel = this.getExpertiseLevel(domain);
                const otherLevel = otherExpertiseSystem.getExpertiseLevel(domain);

                if (myLevel > otherLevel + 0.1) { // Enseigner seulement si √©cart significatif
                    const knowledge = this.knowledgeBase.get(domain) || [];
                    const recentSuccesses = knowledge.filter(exp =>
                        exp.success && (Date.now() - exp.timestamp) < 60000
                    ).slice(-5); // Les 5 derniers succ√®s

                    if (recentSuccesses.length > 0) {
                        // Transfert de connaissance
                        const teachingEffectiveness = myLevel * 0.1;
                        otherExpertiseSystem.receiveTeaching(domain, teachingEffectiveness, recentSuccesses);

                        this.teachingHistory.push({
                            domain,
                            student: otherExpertiseSystem.droneId,
                            effectiveness: teachingEffectiveness,
                            timestamp: Date.now()
                        });

                        return true;
                    }
                }

                return false;
            }

            receiveTeaching(domain, effectiveness, examples) {
                const currentLevel = this.getExpertiseLevel(domain);
                const improvement = effectiveness * (1 - currentLevel); // Am√©lioration diminue avec le niveau

                this.specializations.set(domain, Math.min(1, currentLevel + improvement));

                // Int√©grer les exemples dans la base de connaissances
                if (!this.knowledgeBase.has(domain)) {
                    this.knowledgeBase.set(domain, []);
                }

                examples.forEach(example => {
                    this.knowledgeBase.get(domain).push({
                        ...example,
                        learned: true,
                        teacher: true
                    });
                });
            }

            getCurrentContext() {
                // Contexte simplifi√© pour l'apprentissage
                return {
                    position: window.drones[this.droneId]?.position.toArray() || [0, 0, 0],
                    velocity: window.drones[this.droneId]?.velocity.length() || 0,
                    nearbyDrones: window.drones.length,
                    timeOfDay: Date.now() % 86400000 // Heure du jour en ms
                };
            }

            // Ajout: API simple d'exp√©rience pour compatibilit√© avec le code d'IA
            gainExperience(domain, amount = 0.001) {
                const success = amount >= 0; // simplification
                const difficulty = 1.0;
                this.updateExpertise(domain, success, difficulty);
            }

            getRecentLearningRate() {
                // Estime un taux d'apprentissage bas√© sur les derniers enregistrements
                let recent = 0;
                this.knowledgeBase.forEach((arr) => {
                    recent += arr.slice(-5).filter(e => e.success).length;
                });
                return Math.min(1, recent / 20);
            }
        }

        // ===== SYST√àME DE CONSENSUS DISTRIBU√â AVANC√â =====
        class DistributedConsensus {
            constructor() {
                this.proposals = new Map();
                this.votes = new Map();
                this.decisions = new Map();
                this.consensusHistory = [];
                this.votingPower = new Map(); // Pouvoir de vote bas√© sur l'expertise
            }

            createProposal(proposerId, proposalType, data, urgency = 1.0) {
                const proposalId = `${proposalType}_${Date.now()}_${proposerId}`;

                const proposal = {
                    id: proposalId,
                    type: proposalType,
                    proposer: proposerId,
                    data: data,
                    urgency: urgency,
                    timestamp: Date.now(),
                    deadline: Date.now() + (urgency > 1.5 ? 5000 : 15000), // Deadline bas√©e sur urgence
                    votes: new Map(),
                    status: 'ACTIVE'
                };

                this.proposals.set(proposalId, proposal);
                this.broadcastProposal(proposal);

                console.log(`üìä Nouvelle proposition: ${proposalType} par drone ${proposerId}`);
                return proposalId;
            }

            castVote(voterId, proposalId, vote, confidence = 1.0) {
                const proposal = this.proposals.get(proposalId);
                if (!proposal || proposal.status !== 'ACTIVE') return false;

                if (Date.now() > proposal.deadline) {
                    proposal.status = 'EXPIRED';
                    return false;
                }

                // Calcul du poids du vote bas√© sur l'expertise
                const voterExpertise = this.getVoterExpertise(voterId, proposal.type);
                const voteWeight = confidence * voterExpertise;

                proposal.votes.set(voterId, {
                    vote: vote, // 'FOR', 'AGAINST', 'ABSTAIN'
                    weight: voteWeight,
                    confidence: confidence,
                    timestamp: Date.now()
                });

                // V√©rifier si consensus atteint
                this.checkConsensus(proposalId);
                return true;
            }

            checkConsensus(proposalId) {
                const proposal = this.proposals.get(proposalId);
                if (!proposal) return;

                const totalDrones = window.drones.length;
                const votesCount = proposal.votes.size;

                // Besoin d'au moins 50% de participation pour consensus valide
                if (votesCount < totalDrones * 0.5) return;

                let forWeight = 0, againstWeight = 0, totalWeight = 0;

                for (let [voterId, voteData] of proposal.votes) {
                    totalWeight += voteData.weight;
                    if (voteData.vote === 'FOR') {
                        forWeight += voteData.weight;
                    } else if (voteData.vote === 'AGAINST') {
                        againstWeight += voteData.weight;
                    }
                }

                const forRatio = forWeight / totalWeight;
                const againstRatio = againstWeight / totalWeight;

                // Consensus atteint si 70% ou plus d'accord pond√©r√©
                if (forRatio >= CONFIG.AI.consensusThreshold) {
                    this.finalizeDecision(proposalId, 'ACCEPTED', forRatio);
                } else if (againstRatio >= CONFIG.AI.consensusThreshold) {
                    this.finalizeDecision(proposalId, 'REJECTED', againstRatio);
                }
            }

            finalizeDecision(proposalId, decision, strength) {
                const proposal = this.proposals.get(proposalId);
                if (!proposal) return;

                proposal.status = decision;
                proposal.consensusStrength = strength;
                proposal.finalizedAt = Date.now();

                this.decisions.set(proposalId, {
                    type: proposal.type,
                    decision: decision,
                    data: proposal.data,
                    strength: strength,
                    timestamp: Date.now()
                });

                this.consensusHistory.push({
                    proposalId,
                    type: proposal.type,
                    decision,
                    strength,
                    participationRate: proposal.votes.size / window.drones.length,
                    duration: Date.now() - proposal.timestamp
                });

                // Appliquer la d√©cision
                this.implementDecision(proposal);

                console.log(`‚úÖ Consensus ${decision}: ${proposal.type} (force: ${(strength * 100).toFixed(1)}%)`);
            }

            implementDecision(proposal) {
                if (proposal.status !== 'ACCEPTED') return;

                switch (proposal.type) {
                    case 'PATTERN_CHANGE':
                        currentSearchPattern = SEARCH_PATTERNS.indexOf(proposal.data.newPattern);
                        console.log(`üîÑ Pattern chang√© vers: ${proposal.data.newPattern}`);
                        break;

                    case 'FORMATION_CHANGE':
                        if (window.drones && window.drones.length > 0) {
                            window.drones.forEach(drone => {
                                if (drone.setFormation) {
                                    drone.setFormation(proposal.data.formation);
                                }
                            });
                        }
                        break;

                    case 'PRIORITY_TARGET':
                        // Impl√©menter changement de priorit√© de cible
                        break;

                    case 'EMERGENCY_PROTOCOL':
                        this.activateEmergencyProtocol(proposal.data);
                        break;
                }
            }

            getVoterExpertise(voterId, proposalType) {
                if (!window.drones || !window.drones[voterId]) return 0.5; // Valeur par d√©faut

                const drone = window.drones[voterId];
                if (!drone || !drone.expertiseSystem) return 0.5; // Valeur par d√©faut

                // Mappage des types de propositions aux domaines d'expertise
                const expertiseDomainMap = {
                    'PATTERN_CHANGE': 'navigation',
                    'FORMATION_CHANGE': 'formation_flight',
                    'PRIORITY_TARGET': 'target_detection',
                    'EMERGENCY_PROTOCOL': 'risk_assessment'
                };

                const domain = expertiseDomainMap[proposalType] || 'navigation';
                return Math.max(0.1, drone.expertiseSystem.getExpertiseLevel(domain));
            }

            broadcastProposal(proposal) {
                // Diffuser la proposition √† tous les drones
                if (window.drones && window.drones.length > 0) {
                    window.drones.forEach((drone, index) => {
                        if (drone.receiveProposal) {
                            drone.receiveProposal(proposal);
                        }
                    });
                }
            }

            activateEmergencyProtocol(data) {
                console.log('üö® Activation protocole d\'urgence:', data);
                if (window.drones && window.drones.length > 0) {
                    window.drones.forEach(drone => {
                        if (drone.setEmergencyMode) {
                            drone.setEmergencyMode(data.type, data.severity);
                        }
                    });
                }
            }

            getActiveProposals() {
                return Array.from(this.proposals.values()).filter(p => p.status === 'ACTIVE');
            }

            getRecentDecisions(timeWindow = 60000) {
                const now = Date.now();
                return this.consensusHistory.filter(decision =>
                    now - decision.timestamp < timeWindow
                );
            }

            // Sant√© du consensus (0..1): participation et rapidit√© de d√©cision r√©centes
            getConsensusHealth(timeWindow = 30000) {
                const recent = this.getRecentDecisions(timeWindow);
                if (recent.length === 0) return 0.5;
                const avgParticipation = recent.reduce((s, d) => s + (d.participationRate || 0), 0) / recent.length;
                const avgDuration = recent.reduce((s, d) => s + (d.duration || 0), 0) / recent.length;
                const speedScore = 1 - Math.min(1, avgDuration / timeWindow);
                return Math.max(0, Math.min(1, 0.6 * avgParticipation + 0.4 * speedScore));
            }
        }

        // ===== SWARM MEMORY SYSTEM ENRICHI (Intelligence Collective Avanc√©e) =====
        class SwarmMemory {
            constructor() {
                this.stigmergyPoints = [];
                this.consensusData = new Map();
                this.communicationMatrix = new Map();
                this.adaptationLevel = 0;
                this.phaseEvolution = 'EXPLORATION';
                this.expertiseCount = 0;
                this.messageQueue = [];
                this.expertiseZones = new Map();

                // === NOUVEAUX SYST√àMES ENRICHIS ===
                this.distributedConsensus = new DistributedConsensus();
                this.globalNeuralNetwork = new NeuralNetwork(12, CONFIG.AI.neuralLayerSizes, 6);
                this.collectiveMemory = new Map();
                this.emergentBehaviors = new Set();
                this.performanceMetrics = new Map();
                this.adaptiveParameters = new Map();

                // M√©triques avanc√©es
                this.swarmIntelligenceLevel = 0;
                this.coherenceIndex = 0;
                this.emergenceStrength = 0;
                this.learningProgress = 0;
                this.innovationIndex = 0;

                // Historique des d√©cisions
                this.decisionHistory = [];
                this.strategyEffectiveness = new Map();

                // Pattern recognition syst√®me
                this.patternRecognition = {
                    detectedPatterns: new Set(),
                    confidence: new Map(),
                    predictions: new Map()
                };

                this.initializeIntelligenceCollective();
            }

            initializeIntelligenceCollective() {
                setInterval(() => this.updateIntelligenceCollective(), 200);
                setInterval(() => this.performGlobalOptimization(), 5000);
                setInterval(() => this.analyzeEmergentBehaviors(), 3000);
                console.log('üß† Intelligence Collective Enrichie initialis√©e');
            }

            updateIntelligenceCollective() {
                if (!window.drones || window.drones.length === 0) return;

                this.updateStigmergie();
                this.updateConsensus();
                this.updateCommunication();
                this.updateAdaptation();
                this.updatePhaseEvolution();
                this.updateExpertise();
                this.updateAdvancedMetrics();
                this.processGlobalLearning();
                this.updateUI();
            }

            // === M√âTRIQUES AVANC√âES ===
            updateAdvancedMetrics() {
                this.calculateSwarmIntelligence();
                this.calculateCoherence();
                this.calculateEmergence();
                this.calculateLearningProgress();
                this.calculateInnovationIndex();
            }

            // Nouveaux calculs manquants
            calculateLearningProgress() {
                if (!window.drones || window.drones.length === 0) {
                    this.learningProgress = 0;
                    return this.learningProgress;
                }

                // Bas√© sur l'entra√Ænement du r√©seau global et l'activit√© d'expertise
                let activity = 0;
                window.drones.forEach(d => {
                    activity += d.expertiseSystem ? (d.expertiseSystem.experienceCounter || 0) : 0;
                });
                // Normalisation simple
                const norm = Math.min(1, activity / Math.max(1, window.drones.length * 50));
                this.learningProgress = this.learningProgress * 0.9 + norm * 0.1;
                return this.learningProgress;
            }

            calculateInnovationIndex() {
                if (!window.drones || window.drones.length === 0) {
                    this.innovationIndex = 0;
                    return this.innovationIndex;
                }

                let sum = 0;
                window.drones.forEach(d => {
                    sum += d.innovation?.innovationScore || 0;
                });
                const avg = window.drones.length ? sum / window.drones.length : 0;
                this.innovationIndex = Math.max(0, Math.min(1, avg));
                return this.innovationIndex;
            }

            calculateSwarmIntelligence() {
                if (!window.drones || window.drones.length === 0) {
                    this.swarmIntelligenceLevel = 0;
                    return;
                }

                let totalIndividualIntelligence = 0;
                let totalCollectiveBonus = 0;

                window.drones.forEach(drone => {
                    totalIndividualIntelligence += drone.intelligence || 0;

                    // Bonus d'intelligence collective bas√© sur les interactions
                    const communicationBonus = (drone.communicationLevel || 0) * 0.1;
                    const expertiseBonus = (drone.expertiseSystem?.getBestSpecialization() ? 0.2 : 0);
                    const consensusBonus = (drone.lastConsensusParticipation || 0) * 0.15;

                    totalCollectiveBonus += communicationBonus + expertiseBonus + consensusBonus;
                });

                const baseIntelligence = window.drones.length > 0 ?
                    totalIndividualIntelligence / window.drones.length : 0;
                const collectiveMultiplier = 1 + (totalCollectiveBonus / window.drones.length);

                this.swarmIntelligenceLevel = baseIntelligence * collectiveMultiplier;
            }

            calculateCoherence() {
                if (!window.drones || window.drones.length < 2) {
                    this.coherenceIndex = 1.0;
                    return;
                }

                // Coh√©rence spatiale
                const center = new THREE.Vector3();
                window.drones.forEach(drone => center.add(drone.position));
                center.divideScalar(window.drones.length);

                let spatialVariance = 0;
                window.drones.forEach(drone => {
                    spatialVariance += center.distanceToSquared(drone.position);
                });
                spatialVariance /= window.drones.length;
                const spatialCoherence = Math.max(0, 1 - spatialVariance / 10000);

                // Coh√©rence directionnelle
                const avgVelocity = new THREE.Vector3();
                window.drones.forEach(drone => {
                    if (drone.velocity) avgVelocity.add(drone.velocity);
                });
                avgVelocity.divideScalar(window.drones.length);

                let directionalAlignment = 0;
                window.drones.forEach(drone => {
                    if (drone.velocity && drone.velocity.length() > 0.1) {
                        const alignment = drone.velocity.normalize().dot(avgVelocity.normalize());
                        directionalAlignment += Math.max(0, alignment);
                    }
                });
                directionalAlignment /= window.drones.length;

                // Coh√©rence comportementale
                const behaviorCounts = new Map();
                window.drones.forEach(drone => {
                    const behavior = drone.currentBehavior || 'exploration';
                    behaviorCounts.set(behavior, (behaviorCounts.get(behavior) || 0) + 1);
                });

                const maxBehaviorCount = Math.max(...behaviorCounts.values());
                const behavioralCoherence = maxBehaviorCount / window.drones.length;

                this.coherenceIndex = (spatialCoherence + directionalAlignment + behavioralCoherence) / 3;
            }

            calculateEmergence() {
                // D√©tection de patterns √©mergents non programm√©s
                const emergentIndicators = [];

                // 1. Formations spontan√©es
                const formations = this.detectFormations();
                if (formations.length > 0) {
                    emergentIndicators.push(formations.length * 0.2);
                }

                // 2. Oscillations synchronis√©es
                const synchronization = this.detectSynchronization();
                emergentIndicators.push(synchronization * 0.3);

                // 3. Sp√©cialisation √©mergente des r√¥les
                const roleSpecialization = this.detectRoleSpecialization();
                emergentIndicators.push(roleSpecialization * 0.25);

                // 4. Communication patterns complexes
                const communicationComplexity = this.analyzeCommunicationPatterns();
                emergentIndicators.push(communicationComplexity * 0.25);

                this.emergenceStrength = emergentIndicators.reduce((sum, val) => sum + val, 0);
                this.emergenceStrength = Math.min(1, this.emergenceStrength);
            }

            detectFormations() {
                const formations = [];
                const proximityThreshold = 5.0;
                const visited = new Set();

                window.drones.forEach((drone, i) => {
                    if (visited.has(i)) return;

                    const cluster = [i];
                    const queue = [i];
                    visited.add(i);

                    while (queue.length > 0) {
                        const current = queue.shift();
                        const currentDrone = window.drones[current];

                        window.drones.forEach((other, j) => {
                            if (!visited.has(j) &&
                                currentDrone.position.distanceTo(other.position) < proximityThreshold) {
                                cluster.push(j);
                                queue.push(j);
                                visited.add(j);
                            }
                        });
                    }

                    if (cluster.length > 2) {
                        formations.push(cluster);
                    }
                });

                return formations;
            }

            detectSynchronization() {
                if (window.drones.length < 3) return 0;

                const velocities = window.drones.map(drone => drone.velocity || new THREE.Vector3());
                let synchronization = 0;
                let pairs = 0;

                for (let i = 0; i < velocities.length; i++) {
                    for (let j = i + 1; j < velocities.length; j++) {
                        if (velocities[i].length() > 0.1 && velocities[j].length() > 0.1) {
                            const alignment = velocities[i].normalize().dot(velocities[j].normalize());
                            synchronization += Math.max(0, alignment);
                            pairs++;
                        }
                    }
                }

                return pairs > 0 ? synchronization / pairs : 0;
            }

            detectRoleSpecialization() {
                if (!window.drones.some(drone => drone.expertiseSystem)) return 0;

                const specializations = new Map();
                let totalSpecialized = 0;

                window.drones.forEach(drone => {
                    if (drone.expertiseSystem) {
                        const bestSpec = drone.expertiseSystem.getBestSpecialization();
                        if (bestSpec && drone.expertiseSystem.getExpertiseLevel(bestSpec) > 0.6) {
                            specializations.set(bestSpec, (specializations.get(bestSpec) || 0) + 1);
                            totalSpecialized++;
                        }
                    }
                });

                const diversity = specializations.size;
                const specializationRate = totalSpecialized / window.drones.length;

                return diversity > 1 ? specializationRate * (diversity / 5) : 0;
            }

            analyzeCommunicationPatterns() {
                const recentMessages = this.messageQueue.filter(msg =>
                    Date.now() - msg.timestamp < 10000
                );

                if (recentMessages.length < 5) return 0;

                // Analyser la diversit√© des types de messages
                const messageTypes = new Set(recentMessages.map(msg => msg.type));
                const typesDiversity = messageTypes.size / 10; // Normaliser sur 10 types max

                // Analyser la distribution des communications
                const senderCounts = new Map();
                recentMessages.forEach(msg => {
                    senderCounts.set(msg.sender, (senderCounts.get(msg.sender) || 0) + 1);
                });

                const maxMessages = Math.max(...senderCounts.values());
                const minMessages = Math.min(...senderCounts.values());
                const distributionBalance = minMessages / maxMessages;

                return (typesDiversity + distributionBalance) / 2;
            }

            // === APPRENTISSAGE GLOBAL ===
            processGlobalLearning() {
                // Collecter les donn√©es d'exp√©rience de tous les drones
                const trainingData = this.collectTrainingData();

                if (trainingData.length > 10) {
                    // Entra√Æner le r√©seau de neurones global
                    trainingData.slice(-10).forEach(data => {
                        this.globalNeuralNetwork.train(data.inputs, data.outputs);
                    });

                    this.learningProgress = Math.min(1, this.learningProgress + 0.001);
                }

                // Partager les apprentissages avec les drones
                this.distributeGlobalKnowledge();
            }

            collectTrainingData() {
                const trainingData = [];

                window.drones.forEach(drone => {
                    if (drone.expertiseSystem && drone.expertiseSystem.experienceCounter > 0) {
                        // Cr√©er des exemples d'entra√Ænement bas√©s sur les exp√©riences r√©ussites
                        drone.expertiseSystem.knowledgeBase.forEach((experiences, domain) => {
                            experiences.filter(exp => exp.success).slice(-3).forEach(exp => {
                                const inputs = this.createInputVector(drone, exp.context);
                                const outputs = this.createOutputVector(domain, exp.success);
                                trainingData.push({ inputs, outputs });
                            });
                        });
                    }
                });

                return trainingData;
            }

            createInputVector(drone, context) {
                return [
                    (drone.position.x + 75) / 150,  // Position normalis√©e
                    (drone.position.z + 75) / 150,
                    drone.velocity.length() / 5,    // Vitesse normalis√©e
                    drone.intelligence / 50,        // Intelligence normalis√©e
                    (drone.communicationLevel || 0) / 10,
                    context.nearbyDrones / 20,      // Densit√© locale
                    (context.timeOfDay % 86400000) / 86400000, // Heure normalis√©e
                    drone.type?.speed / 5 || 0.5,   // Capacit√©s du drone
                    this.coherenceIndex,            // M√©triques globales
                    this.swarmIntelligenceLevel / 100,
                    this.emergenceStrength,
                    Math.random() * 0.1             // Bruit pour g√©n√©ralisation
                ];
            }

            createOutputVector(domain, success) {
                const outputs = new Array(6).fill(0);
                const domainIndex = {
                    'navigation': 0,
                    'communication': 1,
                    'formation_flight': 2,
                    'target_detection': 3,
                    'obstacle_avoidance': 4,
                    'energy_optimization': 5
                }[domain] || 0;

                outputs[domainIndex] = success ? 1 : 0;
                return outputs;
            }

            distributeGlobalKnowledge() {
                window.drones.forEach(drone => {
                    if (drone.receiveGlobalKnowledge) {
                        const knowledge = {
                            swarmIntelligence: this.swarmIntelligenceLevel,
                            emergentPatterns: Array.from(this.emergentBehaviors),
                            optimalStrategies: this.getOptimalStrategies(),
                            riskAssessments: this.getCurrentRiskAssessments()
                        };
                        drone.receiveGlobalKnowledge(knowledge);
                    }
                });
            }

            // === OPTIMISATION GLOBALE ===
            performGlobalOptimization() {
                this.optimizeSearchPattern();
                this.optimizeFormation();
                // Nouvelle fonction: allocation de ressources
                this.optimizeResourceAllocation();
                this.adaptParameters();
            }

            // Ajout: optimisation de l'allocation des ressources (bouchon raisonnable)
            optimizeResourceAllocation() {
                try {
                    const tasks = ['exploration', 'mapping', 'coordination'];
                    const drones = window.drones || [];
                    if (drones.length === 0) return;

                    // Heuristique simple: r√©partir les r√¥les selon type/capacit√©s
                    drones.forEach((drone, i) => {
                        const preferred = drone.type?.role || 'reconnaissance';
                        if (preferred === 'coordination') {
                            drone.currentBehavior = 'collaboration';
                        } else if (preferred === 'transport') {
                            drone.currentBehavior = 'patrol';
                        } else {
                            drone.currentBehavior = 'exploration';
                        }
                    });

                    // Mettre √† jour un score d'√©quilibre (√† utiliser par getCoherenceIndex)
                    this.resourceBalance = Math.min(1, tasks.length / Math.max(1, drones.length));
                } catch (e) {
                    console.warn('optimizeResourceAllocation fallback:', e);
                }
            }

            adaptParameters() {
                try {
                    // Adaptation dynamique des param√®tres DIAMANTS bas√©e sur la performance
                    const drones = window.drones || [];
                    if (drones.length === 0) return;

                    // Calculer les m√©triques de performance globales
                    const avgIntelligence = drones.reduce((sum, drone) => sum + (drone.intelligence || 0), 0) / drones.length;
                    const avgVelocity = drones.reduce((sum, drone) => sum + (drone.velocity?.length() || 0), 0) / drones.length;
                    const coverage = this.calculateCoverageMetric();

                    // Adapter les param√®tres selon les conditions
                    if (avgIntelligence < 0.3) {
                        // Intelligence faible: augmenter exploration
                        this.adjustExplorationParameters(1.2);
                    } else if (avgIntelligence > 0.8) {
                        // Intelligence √©lev√©e: optimiser exploitation
                        this.adjustExploitationParameters(1.1);
                    }

                    if (avgVelocity < 0.5) {
                        // Vitesse faible: augmenter dynamisme
                        this.adjustDynamicParameters(1.15);
                    }

                    if (coverage < 0.4) {
                        // Couverture insuffisante: encourager dispersion
                        this.adjustDispersionParameters(1.1);
                    }

                    console.log(`üîß Param√®tres adapt√©s - Intel: ${avgIntelligence.toFixed(2)}, Vel: ${avgVelocity.toFixed(2)}, Cov: ${coverage.toFixed(2)}`);
                } catch (e) {
                    console.warn('adaptParameters fallback:', e);
                }
            }

            calculateCoverageMetric() {
                // Calculer une m√©trique simple de couverture spatiale
                const drones = window.drones || [];
                if (drones.length < 2) return 1.0;

                let totalDistance = 0;
                let pairs = 0;

                for (let i = 0; i < drones.length; i++) {
                    for (let j = i + 1; j < drones.length; j++) {
                        totalDistance += drones[i].position.distanceTo(drones[j].position);
                        pairs++;
                    }
                }

                const avgDistance = pairs > 0 ? totalDistance / pairs : 1.0;
                return Math.min(1.0, avgDistance / 10.0); // Normaliser √† [0,1]
            }

            adjustExplorationParameters(factor) {
                // Augmenter la tendance √† l'exploration
                if (typeof CONFIG !== 'undefined' && CONFIG.phiIntensity) {
                    CONFIG.phiIntensity *= factor;
                }
            }

            adjustExploitationParameters(factor) {
                // Optimiser l'exploitation des zones connues
                if (typeof CONFIG !== 'undefined' && CONFIG.sigmaIntensity) {
                    CONFIG.sigmaIntensity *= factor;
                }
            }

            adjustDynamicParameters(factor) {
                // Augmenter le dynamisme g√©n√©ral
                if (typeof CONFIG !== 'undefined' && CONFIG.gradientStrength) {
                    CONFIG.gradientStrength *= factor;
                }
            }

            adjustDispersionParameters(factor) {
                // Encourager la dispersion spatiale
                if (typeof CONFIG !== 'undefined' && CONFIG.domainScale) {
                    CONFIG.domainScale *= factor;
                }
            }

            optimizeSearchPattern() {
                const currentEffectiveness = this.calculateSearchEffectiveness();

                if (currentEffectiveness < 0.6) {
                    // Proposer un changement de pattern
                    const betterPattern = this.findBetterSearchPattern();
                    if (betterPattern !== SEARCH_PATTERNS[currentSearchPattern]) {
                        this.distributedConsensus.createProposal(
                            -1, // ID syst√®me
                            'PATTERN_CHANGE',
                            { newPattern: betterPattern, reason: 'optimization' },
                            1.2 // Urgence mod√©r√©e
                        );
                    }
                }
            }

            calculateSearchEffectiveness() {
                const totalArea = CONFIG.zoneSize * CONFIG.zoneSize;
                const exploredCells = explorationMap.flat().filter(cell => cell > 0).length;
                const totalCells = CONFIG.explorationGrid * CONFIG.explorationGrid;

                const coverageRate = exploredCells / totalCells;
                const timeElapsed = (Date.now() - startTime) / 1000;
                const efficiency = coverageRate / Math.max(1, timeElapsed / 60); // couverture par minute

                return Math.min(1, efficiency * 10); // Normaliser
            }

            findBetterSearchPattern() {
                const patternEffectiveness = new Map();

                // Analyser l'historique des patterns
                this.strategyEffectiveness.forEach((effectiveness, strategy) => {
                    if (SEARCH_PATTERNS.includes(strategy)) {
                        patternEffectiveness.set(strategy, effectiveness);
                    }
                });

                // Si pas assez d'historique, utiliser heuristiques
                if (patternEffectiveness.size === 0) {
                    const droneCount = window.drones.length;
                    if (droneCount < 3) return 'spiral';
                    if (droneCount < 8) return 'boustrophedon';
                    return 'coverage';
                }

                // Retourner le pattern le plus efficace
                let bestPattern = SEARCH_PATTERNS[currentSearchPattern];
                let bestEffectiveness = 0;

                patternEffectiveness.forEach((effectiveness, pattern) => {
                    if (effectiveness > bestEffectiveness) {
                        bestEffectiveness = effectiveness;
                        bestPattern = pattern;
                    }
                });

                return bestPattern;
            }

            optimizeFormation() {
                const currentFormationEfficiency = this.calculateFormationEfficiency();

                if (currentFormationEfficiency < 0.7) {
                    const optimalFormation = this.calculateOptimalFormation();
                    this.distributedConsensus.createProposal(
                        -1,
                        'FORMATION_CHANGE',
                        { formation: optimalFormation },
                        1.0
                    );
                }
            }

            calculateFormationEfficiency() {
                // Calculer l'efficacit√© bas√©e sur la couverture et la redondance
                const redundancyPenalty = this.calculateRedundancy();
                const coverageBonus = this.calculateCoverageBonus();

                return Math.max(0, coverageBonus - redundancyPenalty);
            }

            calculateRedundancy() {
                let redundantPairs = 0;
                const redundancyThreshold = 8; // Seuil de proximit√©

                for (let i = 0; i < window.drones.length; i++) {
                    for (let j = i + 1; j < window.drones.length; j++) {
                        const distance = window.drones[i].position.distanceTo(window.drones[j].position);
                        if (distance < redundancyThreshold) {
                            redundantPairs++;
                        }
                    }
                }

                const maxPairs = (window.drones.length * (window.drones.length - 1)) / 2;
                return maxPairs > 0 ? redundantPairs / maxPairs : 0;
            }

            calculateCoverageBonus() {
                const coveredArea = this.calculateCoveredArea();
                const totalArea = CONFIG.zoneSize * CONFIG.zoneSize;
                return coveredArea / totalArea;
            }

            calculateCoveredArea() {
                const sensorRange = 5; // Rayon de d√©tection moyen
                const gridResolution = 2; // R√©solution de calcul
                let coveredCells = 0;

                for (let x = -CONFIG.zoneSize / 2; x < CONFIG.zoneSize / 2; x += gridResolution) {
                    for (let z = -CONFIG.zoneSize / 2; z < CONFIG.zoneSize / 2; z += gridResolution) {
                        const cellPosition = new THREE.Vector3(x, 0, z);
                        const isCovered = window.drones.some(drone =>
                            drone.position.distanceTo(cellPosition) < sensorRange
                        );
                        if (isCovered) coveredCells++;
                    }
                }

                return coveredCells * (gridResolution * gridResolution);
            }

            calculateOptimalFormation() {
                const droneCount = window.drones.length;
                const areaSize = CONFIG.zoneSize;

                // Calcul de la formation optimale bas√©e sur la taille de l'essaim
                if (droneCount <= 4) return 'diamond';
                if (droneCount <= 9) return 'grid';
                if (droneCount <= 16) return 'hexagon';
                return 'adaptive';
            }

            // === ANALYSE DES COMPORTEMENTS √âMERGENTS ===
            analyzeEmergentBehaviors() {
                this.detectNewBehaviorPatterns();
                // Nouvelle fonction: validation des comportements √©mergents
                this.validateEmergentBehaviors();
                this.rewardInnovativeBehaviors();
            }

            // Ajout: validation basique des comportements √©mergents
            validateEmergentBehaviors() {
                try {
                    const valid = new Set();
                    this.emergentBehaviors.forEach(sig => {
                        // Crit√®re simple: ignorer signatures vides et d√©dupliquer
                        if (typeof sig === 'string' && sig.length > 0) valid.add(sig);
                    });
                    this.emergentBehaviors = valid;
                } catch (e) {
                    console.warn('validateEmergentBehaviors fallback:', e);
                }
            }

            detectNewBehaviorPatterns() {
                // Analyser les patterns de mouvement non programm√©s
                const movementPatterns = this.analyzMovementPatterns();

                movementPatterns.forEach(pattern => {
                    if (!this.emergentBehaviors.has(pattern.signature)) {
                        this.emergentBehaviors.add(pattern.signature);
                        console.log(`üé≠ Nouveau comportement √©mergent d√©tect√©: ${pattern.description}`);

                        // √âvaluer la valeur du nouveau comportement
                        this.evaluateNewBehavior(pattern);
                    }
                });
            }

            analyzMovementPatterns() {
                const patterns = [];
                const timeWindow = 5000; // 5 secondes
                const now = Date.now();

                // Analyser les mouvements r√©cents
                window.drones.forEach(drone => {
                    if (drone.movementHistory && drone.movementHistory.length > 10) {
                        const recentMovements = drone.movementHistory.filter(move =>
                            now - move.timestamp < timeWindow
                        );

                        if (recentMovements.length > 5) {
                            const pattern = this.extractMovementPattern(recentMovements);
                            if (pattern.confidence > 0.7) {
                                patterns.push(pattern);
                            }
                        }
                    }
                });

                return patterns;
            }

            extractMovementPattern(movements) {
                // Analyser la s√©quence de mouvements pour d√©tecter des patterns
                const directions = movements.map(move => move.direction);
                const speeds = movements.map(move => move.speed);

                // D√©tecter patterns g√©om√©triques
                const geometricPattern = this.detectGeometricPattern(directions);

                // D√©tecter patterns temporels
                const temporalPattern = this.detectTemporalPattern(speeds);

                return {
                    signature: `${geometricPattern.type}_${temporalPattern.type}`,
                    description: `${geometricPattern.description} avec ${temporalPattern.description}`,
                    confidence: (geometricPattern.confidence + temporalPattern.confidence) / 2,
                    value: this.estimatePatternValue(geometricPattern, temporalPattern)
                };
            }

            detectGeometricPattern(directions) {
                // Simplification: d√©tecter spirales, zigzags, cercles
                if (directions.length < 4) return { type: 'linear', description: 'mouvement lin√©aire', confidence: 0.5 };

                // Calculer les changements de direction
                const angleChanges = [];
                for (let i = 1; i < directions.length; i++) {
                    const angleChange = Math.abs(directions[i] - directions[i - 1]);
                    angleChanges.push(Math.min(angleChange, 2 * Math.PI - angleChange));
                }

                const avgAngleChange = angleChanges.reduce((sum, angle) => sum + angle, 0) / angleChanges.length;

                if (avgAngleChange < 0.3) {
                    return { type: 'linear', description: 'mouvement lin√©aire', confidence: 0.8 };
                } else if (avgAngleChange > 2.8) {
                    return { type: 'erratic', description: 'mouvement erratique', confidence: 0.7 };
                } else if (Math.abs(avgAngleChange - Math.PI / 2) < 0.5) {
                    return { type: 'zigzag', description: 'mouvement en zigzag', confidence: 0.8 };
                } else {
                    return { type: 'curved', description: 'mouvement courbe', confidence: 0.6 };
                }
            }

            detectTemporalPattern(speeds) {
                if (speeds.length < 4) return { type: 'constant', description: 'vitesse constante', confidence: 0.5 };

                const speedVariation = Math.sqrt(
                    speeds.reduce((sum, speed) => {
                        const avgSpeed = speeds.reduce((s, sp) => s + sp, 0) / speeds.length;
                        return sum + Math.pow(speed - avgSpeed, 2);
                    }, 0) / speeds.length
                );

                const avgSpeed = speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;
                const variationRatio = speedVariation / Math.max(0.1, avgSpeed);

                if (variationRatio < 0.1) {
                    return { type: 'steady', description: 'rythme r√©gulier', confidence: 0.8 };
                } else if (variationRatio > 0.5) {
                    return { type: 'variable', description: 'rythme variable', confidence: 0.7 };
                } else {
                    return { type: 'adaptive', description: 'rythme adaptatif', confidence: 0.6 };
                }
            }

            estimatePatternValue(geometric, temporal) {
                // Estimer la valeur du pattern pour l'efficacit√© de l'essaim
                const geometricValue = {
                    'spiral': 0.8, 'zigzag': 0.7, 'curved': 0.6, 'linear': 0.5, 'erratic': 0.2
                }[geometric.type] || 0.3;

                const temporalValue = {
                    'adaptive': 0.9, 'steady': 0.7, 'variable': 0.4
                }[temporal.type] || 0.3;

                return (geometricValue + temporalValue) / 2;
            }

            rewardInnovativeBehaviors() {
                // R√©compenser les drones qui d√©veloppent des comportements innovants
                window.drones.forEach(drone => {
                    if (drone.innovationScore && drone.innovationScore > 0.8) {
                        // Augmenter l'intelligence du drone innovant
                        drone.intelligence += 0.1;

                        // Augmenter son pouvoir de vote
                        if (drone.expertiseSystem) {
                            drone.expertiseSystem.updateExpertise('innovation', true, 1.5);
                        }

                        console.log(`üèÜ Drone ${drone.id} r√©compens√© pour innovation`);
                    }
                });
            }

            // === GESTION DES RISQUES AVANC√âE ===
            assessGlobalRisks() {
                const risks = new Map();

                // Risque de collision
                risks.set('collision', this.assessCollisionRisk());

                // Risque de s√©paration excessive
                risks.set('separation', this.assessSeparationRisk());

                // Risque de stagnation
                risks.set('stagnation', this.assessStagnationRisk());

                // Risque de redondance
                risks.set('redundancy', this.assessRedundancyRisk());

                return risks;
            }

            assessCollisionRisk() {
                let riskLevel = 0;
                const dangerDistance = CONFIG.safetyDistance * 1.5;

                for (let i = 0; i < window.drones.length; i++) {
                    for (let j = i + 1; j < window.drones.length; j++) {
                        const distance = window.drones[i].position.distanceTo(window.drones[j].position);
                        if (distance < dangerDistance) {
                            const velocityApproach = window.drones[i].velocity.clone()
                                .sub(window.drones[j].velocity).length();
                            riskLevel += (dangerDistance - distance) * velocityApproach;
                        }
                    }
                }

                return Math.min(1, riskLevel / 100);
            }

            assessSeparationRisk() {
                if (window.drones.length < 2) return 0;

                let maxDistance = 0;
                const center = new THREE.Vector3();
                window.drones.forEach(drone => center.add(drone.position));
                center.divideScalar(window.drones.length);

                window.drones.forEach(drone => {
                    const distance = drone.position.distanceTo(center);
                    maxDistance = Math.max(maxDistance, distance);
                });

                const criticalDistance = CONFIG.swarmRadius * 1.5;
                return Math.min(1, Math.max(0, maxDistance - criticalDistance) / criticalDistance);
            }

            assessStagnationRisk() {
                const recentProgress = this.calculateRecentProgress();
                const expectedProgress = this.calculateExpectedProgress();

                if (expectedProgress === 0) return 0;

                const progressRatio = recentProgress / expectedProgress;
                return Math.max(0, 1 - progressRatio * 2); // Risque √©lev√© si < 50% du progr√®s attendu
            }

            calculateRecentProgress() {
                const timeWindow = 30000; // 30 secondes
                const now = Date.now();
                const recentExplorationGains = explorationMap.flat().filter((cell, index) => {
                    // Simplification: on consid√®re qu'une cellule r√©cemment explor√©e contribue au progr√®s
                    return cell > 0; // Dans un vrai syst√®me, on suivrait les timestamps
                }).length;

                return recentExplorationGains;
            }

            calculateExpectedProgress() {
                const droneCount = window.drones.length;
                const timeElapsed = Math.max(1, (Date.now() - startTime) / 1000);
                const expectedCellsPerMinute = droneCount * 2; // Heuristique

                return expectedCellsPerMinute * (timeElapsed / 60);
            }

            assessRedundancyRisk() {
                if (!window.drones || window.drones.length < 2) return 0;

                let redundancyScore = 0;
                const proximityThreshold = CONFIG.safetyDistance * 3;
                const similarBehaviorThreshold = 0.8;

                // √âvaluer la redondance spatiale
                for (let i = 0; i < window.drones.length; i++) {
                    for (let j = i + 1; j < window.drones.length; j++) {
                        const drone1 = window.drones[i];
                        const drone2 = window.drones[j];

                        const distance = drone1.position.distanceTo(drone2.position);

                        if (distance < proximityThreshold) {
                            // Calculer la similarit√© des vitesses (direction)
                            const velocity1 = drone1.velocity.clone().normalize();
                            const velocity2 = drone2.velocity.clone().normalize();
                            const velocitySimilarity = velocity1.dot(velocity2);

                            // √âvaluer si les drones ont des comportements similaires
                            const behavior1 = drone1.behaviorState || 'exploration';
                            const behavior2 = drone2.behaviorState || 'exploration';
                            const behaviorSimilar = behavior1 === behavior2;

                            if (velocitySimilarity > similarBehaviorThreshold && behaviorSimilar) {
                                redundancyScore += (proximityThreshold - distance) / proximityThreshold;
                            }
                        }
                    }
                }

                // Normaliser le score de redondance
                const maxPossiblePairs = (window.drones.length * (window.drones.length - 1)) / 2;
                return Math.min(1, redundancyScore / maxPossiblePairs);
            }

            getCurrentRiskAssessments() {
                const risks = this.assessGlobalRisks();
                const assessments = {};

                risks.forEach((level, type) => {
                    assessments[type] = {
                        level: level,
                        severity: level > 0.7 ? 'HIGH' : level > 0.4 ? 'MEDIUM' : 'LOW',
                        recommendation: this.getRecommendationForRisk(type, level)
                    };
                });

                return assessments;
            }

            getRecommendationForRisk(riskType, level) {
                const recommendations = {
                    collision: {
                        HIGH: 'Augmenter distance de s√©curit√© imm√©diatement',
                        MEDIUM: 'Am√©liorer coordination anti-collision',
                        LOW: 'Maintenir surveillance'
                    },
                    separation: {
                        HIGH: 'Forcer regroupement imm√©diat',
                        MEDIUM: 'Am√©liorer coh√©sion d\'essaim',
                        LOW: 'Formation acceptable'
                    },
                    stagnation: {
                        HIGH: 'Changer strat√©gie de recherche',
                        MEDIUM: 'Optimiser allocation des t√¢ches',
                        LOW: 'Progr√®s normal'
                    },
                    redundancy: {
                        HIGH: 'Redistribuer les zones',
                        MEDIUM: 'Am√©liorer coordination',
                        LOW: 'Couverture efficace'
                    }
                };

                return recommendations[riskType]?.[level > 0.7 ? 'HIGH' : level > 0.4 ? 'MEDIUM' : 'LOW'] || 'Surveiller';
            }

            getOptimalStrategies() {
                // Retourner les strat√©gies les plus efficaces bas√©es sur l'historique
                const strategies = Array.from(this.strategyEffectiveness.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([strategy, effectiveness]) => ({
                        strategy,
                        effectiveness,
                        confidence: Math.min(1, this.performanceMetrics.get(strategy + '_samples') / 10 || 0)
                    }));

                return strategies;
            }

            updateStigmergie() {
                // Simulation de stigmergie (traces ph√©romonales)
                const newStigmergie = [];
                window.drones.forEach(drone => {
                    if (drone.velocity.length() > 0.1) {
                        newStigmergie.push({
                            position: drone.position.clone(),
                            intensity: Math.min(100, drone.intelligence * 0.1),
                            timestamp: Date.now()
                        });
                    }
                });

                this.stigmergyPoints = this.stigmergyPoints.concat(newStigmergie);

                // √âvaporation des traces anciennes
                this.stigmergyPoints = this.stigmergyPoints.filter(point =>
                    Date.now() - point.timestamp < 10000
                );
            }

            // API simple appel√©e par les drones
            addStigmergyTrace(position, droneId, tag = 'COMM', intensity = 1.0) {
                try {
                    this.stigmergyPoints.push({ position: position.clone(), intensity, tag, droneId, timestamp: Date.now() });
                    // Limiter la taille
                    if (this.stigmergyPoints.length > 2000) this.stigmergyPoints.splice(0, this.stigmergyPoints.length - 2000);
                } catch (e) { /* noop */ }
            }

            updateConsensus() {
                // Calcul du consensus bas√© sur la convergence des positions
                let consensusValue = 0;
                if (window.drones.length > 1) {
                    const center = new THREE.Vector3();
                    window.drones.forEach(drone => center.add(drone.position));
                    center.divideScalar(window.drones.length);

                    let totalDeviation = 0;
                    window.drones.forEach(drone => {
                        totalDeviation += drone.position.distanceTo(center);
                    });

                    const averageDeviation = totalDeviation / window.drones.length;
                    consensusValue = Math.max(0, 100 - averageDeviation * 5);
                }

                this.consensusData.set('spatial', consensusValue);
            }

            updateCommunication() {
                // Simulation de communication inter-drone
                let totalCommunication = 0;
                const communicationRange = 8.0;

                window.drones.forEach(drone1 => {
                    let connections = 0;
                    window.drones.forEach(drone2 => {
                        if (drone1.id !== drone2.id) {
                            const distance = drone1.position.distanceTo(drone2.position);
                            if (distance < communicationRange) {
                                connections++;
                            }
                        }
                    });
                    drone1.communicationLevel = connections;
                    totalCommunication += connections;
                });

                this.communicationLevel = window.drones.length > 0 ?
                    totalCommunication / window.drones.length : 0;

                // Traiter les messages diffus√©s
                const now = Date.now();
                this.messageQueue = this.messageQueue.filter(msg => now - msg.timestamp < 5000);
                // Simple consensus sur formation si beaucoup de messages ALIGN_FORMATION
                const alignMsgs = this.messageQueue.filter(m => m.type === 'ALIGN_FORMATION');
                if (alignMsgs.length > Math.max(2, window.drones.length / 2)) {
                    window.drones.forEach(d => d.setFormation?.('grid'));
                }
            }

            submitConsensusVote(droneId, topic, vote, confidence = 0.5) {
                // Simplifi√©: enregistrer le vote dans consensusData et retourner true
                const key = `vote_${topic}`;
                if (!this.consensusData.has(key)) this.consensusData.set(key, new Map());
                this.consensusData.get(key).set(droneId, { vote, confidence, timestamp: Date.now() });
                return true;
            }

            updateAdaptation() {
                // Calcul du niveau d'adaptation bas√© sur l'apprentissage
                let adaptationSum = 0;
                window.drones.forEach(drone => {
                    const adaptability = Math.min(100, drone.intelligence * 0.5 +
                        (drone.communicationLevel || 0) * 10);
                    drone.adaptationLevel = adaptability;
                    adaptationSum += adaptability;
                });

                this.adaptationLevel = window.drones.length > 0 ?
                    adaptationSum / window.drones.length : 0;
            }

            updatePhaseEvolution() {
                const avgIntelligence = window.drones.length > 0 ?
                    window.drones.reduce((sum, d) => sum + d.intelligence, 0) / window.drones.length : 0;

                if (avgIntelligence < 5) {
                    this.phaseEvolution = 'EXPLORATION';
                } else if (avgIntelligence < 15) {
                    this.phaseEvolution = 'COORDINATION';
                } else if (avgIntelligence < 30) {
                    this.phaseEvolution = 'COLLABORATION';
                } else {
                    this.phaseEvolution = 'EMERGENCE';
                }
            }

            updateExpertise() {
                // Compter les "experts" (drones avec high intelligence)
                this.expertiseCount = window.drones.filter(drone =>
                    drone.intelligence > 20
                ).length;
            }

            updateUI() {
                const updates = {
                    'stigmergy_value': this.stigmergyPoints.length.toString(),
                    'consensus_value': this.consensusData.get('spatial')?.toFixed(0) || '0',
                    'communication_value': this.communicationLevel.toFixed(1),
                    'adaptation_value': `${this.adaptationLevel.toFixed(0)}%`
                };

                for (const [id, value] of Object.entries(updates)) {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                }
            }

            // Accesseurs pour l'interface (normalis√©s 0..1)
            getSwarmIntelligenceLevel() {
                // intelligence moyenne ramen√©e √† 0..1 par heuristique
                const norm = Math.min(1, (this.swarmIntelligenceLevel || 0) / 50);
                return Math.max(0, norm);
            }

            getCoherenceIndex() {
                return Math.max(0, Math.min(1, this.coherenceIndex || 0));
            }

            getEmergenceStrength() {
                return Math.max(0, Math.min(1, this.emergenceStrength || 0));
            }
        }

        // Variables globales suppl√©mentaires
        let animationId;
        let loadingScreen;
        let meshCache = {};

        // Configuration unifi√©e DIAMANTS_FRONTEND ENRICHIE
    const CONFIG = {
            maxDrones: 50,  // Augment√© pour permettre plus de drones
            spawnRadius: 15,
            flightHeight: 3,
            formationSpacing: 2.5,  // R√©duit pour permettre plus de drones
            safetyDistance: 1.8,    // R√©duit pour optimiser l'espace
            zoneSize: 150,          // Augment√© pour plus d'espace
            explorationGrid: 25,
            // From /sample/Crazyflie.html to /assets/... one level up
            meshPath: '../assets/crazyflie/meshes/',
            modelScale: 1.15,
            mass: 0.025, // kg (25g)
            maxThrust: 0.6, // N  
            maxRPM: 2618, // RPM max moteurs
            // Positions moteur r√©elles (plan horizontal: X & Y SDF => X & Z Three.js)
            motorPositions: [
                { x: 0.031, y: 0.031, height: 0.0115, direction: 'cw' },    // Front-right
                { x: -0.031, y: 0.031, height: 0.0115, direction: 'ccw' },  // Front-left
                { x: -0.031, y: -0.031, height: 0.0115, direction: 'cw' },  // Back-left
                { x: 0.031, y: -0.031, height: 0.0115, direction: 'ccw' }   // Back-right
            ],
            // Param√®tres DIAMANTS V3
            magneticForce: 5.0,
            swarmRadius: 30,
            BOIDS: {
                cohesion: 0.8,
                separation: 1.2,
                alignment: 0.6,
                maxSpeed: 3.0,
                maxForce: 0.5
            },
            // === ENRICHISSEMENTS AVANC√âS ===
            AI: {
                learningRate: 0.01,
                neuralLayerSizes: [12, 8, 4],  // R√©seau de neurones pour d√©cisions
                memoryCapacity: 1000,          // Capacit√© m√©moire √©pisodique
                expertiseThreshold: 0.8,       // Seuil pour devenir expert
                consensusThreshold: 0.7,       // Seuil pour accepter consensus
                adaptationSpeed: 0.05          // Vitesse d'adaptation comportementale
            },
            PHYSICS: {
                windStrength: 0.0,             // Force du vent
                turbulenceLevel: 0.0,          // Niveau de turbulence
                gravityCompensation: 9.81,     // Compensation gravitationnelle
                airDensity: 1.225,            // Densit√© air (kg/m¬≥)
                dragCoefficient: 0.1           // Coefficient de tra√Æn√©e
            },
            MISSIONS: {
                searchRescue: {
                    targetDetectionRange: 10,
                    urgencyFactor: 2.0,
                    teamFormationBonus: 1.5
                },
                surveillance: {
                    stealthMode: true,
                    coverageOptimization: true,
                    intrusionDetection: true
                },
                exploration: {
                    curiosityDriven: true,
                    riskAssessment: true,
                    scientificPriority: true
                }
            }
        };

        // Mat√©riaux Gazebo am√©lior√©s
        const GAZEBO_MATERIALS = {
            crazyflie_red: new THREE.MeshPhongMaterial({
                color: 0xCC0000,
                emissive: 0x220000,
                shininess: 30
            }),
            crazyflie_blue: new THREE.MeshPhongMaterial({
                color: 0x0066CC,
                emissive: 0x001122,
                shininess: 30
            }),
            propeller: new THREE.MeshPhongMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.8,
                shininess: 60
            }),
            ground_gazebo: new THREE.MeshStandardMaterial({
                color: 0x6d7f5f,
                roughness: 0.9,
                metalness: 0.0
            })
        };

        // ===== CLASSE CRAZYFLIE AVEC MOD√àLES D√âTAILL√âS + INTELLIGENCE COLLECTIVE (Legacy, renomm√©e) =====
        class AdvancedDetailedCrazyflieLegacy {
            constructor(id, startPosition) {
                this.id = id;
                this.name = `crazyflie${id === 0 ? '' : id}`;

                // Type de drone avec valeurs par d√©faut
                this.type = DRONE_TYPES.SCOUT;
                this.typeName = 'SCOUT';

                // Propri√©t√©s physiques Crazyflie
                this.position = startPosition.clone();
                this.targetPosition = startPosition.clone();
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.rotation = new THREE.Euler(0, 0, 0);
                this.angularVelocity = new THREE.Vector3(0, 0, 0);

                // Propri√©t√©s sp√©cifiques Crazyflie
                this.mass = 0.027; // kg
                this.motorRPM = [0, 0, 0, 0];
                this.batteryLevel = 100; // %
                this.thrust = 0;
                this.torque = new THREE.Vector3(0, 0, 0);

                // √âtats de vol
                this.state = 'IDLE'; // IDLE, TAKEOFF, FLYING, LANDING, EMERGENCY
                this.formationType = 'free';
                this.missionType = 'exploration';

                // Intelligence DIAMANTS
                this.phi = 0;           // Potentiel attractif DIAMANTS (coh√©sion scouting)
                this.sigma = 0;         // Potentiel r√©pulsif DIAMANTS (exploration/√©vitement)
                this.gradient = new THREE.Vector3(); // ‚àá(œÜ+œÉ) - Gradient DIAMANTS
                this.intelligence = 0;  // I(t) = |‚àá(œÜ+œÉ)| - M√©triques d'intelligence
                this.emergence = 0;     // Amplification non-lin√©aire

                // Propri√©t√©s de scouting collaboratif
                this.scoutingPriority = Math.random(); // Priorit√© de zone [0-1]
                this.scoutingEfficiency = 0; // Efficacit√© accumulative
                this.lastDiscoveryTime = 0; // Derni√®re d√©couverte
                this.collaborationScore = 0; // Score de collaboration

                // === SYST√àME BOUSTROPH√âDON SAR (espacement 18m) ===
                this.boustrophedonData = {
                    assigned: false,
                    row: 0,
                    direction: 1, // 1 = droite, -1 = gauche (alternance)
                    progress: 0,
                    sectorWidth: 18, // Espacement SAR standard : 18m
                    sectorHeight: 18, // M√™me espacement pour quadrillage r√©gulier
                    currentWaypoint: null,
                    completed: false
                };

                // === INTELLIGENCE COLLECTIVE AVANC√âE ===

                // Communication et m√©moire collective
                this.communicationRange = 30; // Port√©e de communication directe
                this.messageBuffer = []; // Buffer des messages re√ßus
                this.lastBroadcast = 0; // Derni√®re diffusion
                this.broadcastInterval = 1000; // Intervalle de diffusion (ms) - r√©duit pour plus d'activit√©

                // Expertise et sp√©cialisation √©mergente  
                this.expertiseLevel = 0; // Niveau d'expertise d√©velopp√© [0-1]
                this.specialization = null; // Sp√©cialisation √©mergente
                this.teachingAbility = 0; // Capacit√© √† enseigner aux autres
                this.learningRate = 0.1; // Vitesse d'apprentissage
                this.expertiseAreas = new Map(); // Map des domaines d'expertise et niveaux

                // Consensus et vote distribu√©
                this.votingHistory = new Map(); // Historique des votes
                this.consensusWeight = 1.0; // Poids dans les consensus
                this.leadershipPotential = Math.random(); // Potentiel de leadership
                this.appliedConsensus = new Set(); // Consensus d√©j√† appliqu√©s

                // Adaptation et plasticit√© comportementale
                this.behaviorAdaptation = {
                    currentStrategy: 'EXPLORATION',
                    adaptationScore: 0,
                    strategyHistory: [],
                    flexibilityIndex: Math.random() * 0.5 + 0.5
                };

                // M√©moire √©pisodique individuelle
                this.episodicMemory = {
                    discoveries: [],
                    interactions: [],
                    successfulStrategies: new Map(),
                    failurePatterns: new Set(),
                    expertiseExchanges: [], // Historique des √©changes d'expertise
                    expertiseAreas: new Set(), // Domaines d'expertise du drone
                    expertise: 0, // Niveau d'expertise global
                    collaborationScore: 0 // Score de collaboration avec l'essaim
                };

                // Stigmergie personnelle
                this.personalStigmergie = {
                    traceIntensity: 1.0,
                    traceDecay: 0.95,
                    readSensitivity: 0.8,
                    lastTraceTime: 0
                };

                // M√©triques d'intelligence collective
                this.collectiveMetrics = {
                    contributionScore: 0, // Contribution √† l'intelligence de l'essaim
                    syncLevel: 0, // Niveau de synchronisation avec l'essaim
                    emergenceParticipation: 0, // Participation aux comportements √©mergents
                    knowledgeSharing: 0, // Score de partage de connaissances
                    efficiency: 0, // Efficacit√© du drone
                    learningInteractions: 0 // Nombre d'interactions d'apprentissage
                };

                // Priorit√©s d'exploration dynamiques
                this.explorationPriorities = {
                    targets: 1.0,
                    unexplored: 0.8,
                    coordination: 0.6,
                    cleanup: 0.4
                };

                // Propri√©t√©s de simulation avanc√©e
                this.localMemory = [];
                this.lastMemoryUpdate = Date.now();
                this.memoryUpdateInterval = 2000;

                // Groupes Three.js
                this.group = new THREE.Group();
                this.motorArms = [];
                this.propellers = [];
                this.leds = [];
                this.emergenceRing = null;
                this.labelSprite = null;

                // Cr√©ation du mod√®le d√©taill√©
                this.createDetailedMesh();
                this.createIntelligenceIndicators();

                // Initialisation intelligence collective
                this.initializeCollectiveIntelligence();

                console.log(`‚úÖ Mod√®le Crazyflie d√©taill√© cr√©√© pour ${this.name} (${this.type.role})`);
            }

            // === CR√âATION DU MOD√àLE D√âTAILL√â R√âALISTE ===
            createDetailedMesh() {
                // Corps central en forme de X (forme iconique Crazyflie)
                const bodyGeometry = new THREE.BoxGeometry(
                    this.type.size * 0.8,
                    this.type.size * 0.15,
                    this.type.size * 0.8
                );
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: this.type.color,
                    shininess: 80,
                    specular: 0x666666,
                    metalness: 0.3
                });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.castShadow = true;
                this.body.receiveShadow = true;
                this.group.add(this.body);

                // Circuit board d√©taill√© (dessus du drone)
                const pcbGeometry = new THREE.BoxGeometry(
                    this.type.size * 0.6,
                    this.type.size * 0.02,
                    this.type.size * 0.6
                );
                const pcbMaterial = new THREE.MeshPhongMaterial({
                    color: 0x228B22,
                    shininess: 30
                });
                const pcb = new THREE.Mesh(pcbGeometry, pcbMaterial);
                pcb.position.y = 0.08;
                this.group.add(pcb);

                // Composants √©lectroniques sur le PCB
                for (let i = 0; i < 6; i++) {
                    const compGeometry = new THREE.BoxGeometry(0.02, 0.005, 0.015);
                    const compMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
                    const component = new THREE.Mesh(compGeometry, compMaterial);
                    component.position.set(
                        (Math.random() - 0.5) * this.type.size * 0.4,
                        0.09,
                        (Math.random() - 0.5) * this.type.size * 0.4
                    );
                    this.group.add(component);
                }

                // Bras moteurs avec structure en X
                const radius = this.type.size * 0.7;
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI / 2) + Math.PI / 4; // 45¬∞ d√©calage pour forme X

                    // Bras principal
                    const armGeometry = new THREE.CylinderGeometry(0.02, 0.015, radius * 0.6, 8);
                    const armMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2a2a2a,
                        metalness: 0.7,
                        shininess: 100
                    });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(
                        Math.cos(angle) * radius * 0.4,
                        0,
                        Math.sin(angle) * radius * 0.4
                    );
                    arm.rotation.z = angle + Math.PI / 2;
                    arm.castShadow = true;
                    this.group.add(arm);
                    this.motorArms.push(arm);

                    // Moteur d√©taill√© avec refroidissement
                    const motorGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.2, 12);
                    const motorMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2a2a2a,
                        metalness: 0.9,
                        shininess: 150
                    });
                    const motor = new THREE.Mesh(motorGeometry, motorMaterial);
                    motor.position.set(
                        Math.cos(angle) * radius,
                        0.12,
                        Math.sin(angle) * radius
                    );
                    motor.castShadow = true;
                    this.group.add(motor);

                    // Ailettes de refroidissement
                    for (let j = 0; j < 4; j++) {
                        const finGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.001);
                        const finMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                        const fin = new THREE.Mesh(finGeometry, finMaterial);
                        fin.position.set(
                            Math.cos(angle) * radius + Math.cos(j * Math.PI / 2) * 0.06,
                            0.12,
                            Math.sin(angle) * radius + Math.sin(j * Math.PI / 2) * 0.06
                        );
                        this.group.add(fin);
                    }

                    // H√©lices dynamiques avec effet blur de rotation
                    const propGeometry = new THREE.CylinderGeometry(0.01, 0.01, this.type.size * 0.6, 3);
                    const propMaterial = new THREE.MeshBasicMaterial({
                        color: 0xcccccc,
                        transparent: true,
                        opacity: 0.4
                    });
                    const prop = new THREE.Mesh(propGeometry, propMaterial);
                    prop.position.set(
                        Math.cos(angle) * radius,
                        0.18,
                        Math.sin(angle) * radius
                    );
                    prop.rotation.y = angle;
                    this.group.add(prop);
                    this.propellers.push(prop);

                    // Effet de blur rotatif pour les h√©lices en mouvement
                    const blurGeometry = new THREE.RingGeometry(0.02, this.type.size * 0.35, 16);
                    const blurMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    const blur = new THREE.Mesh(blurGeometry, blurMaterial);
                    blur.position.set(
                        Math.cos(angle) * radius,
                        0.18,
                        Math.sin(angle) * radius
                    );
                    blur.rotation.x = -Math.PI / 2;
                    this.group.add(blur);
                    this.propellers.push(blur);
                }

                // Syst√®me LED avanc√© avec clignotement
                const ledPositions = [
                    { x: this.type.size * 0.5, z: 0, color: 0xFF0000, intensity: 1.0 }, // Rouge avant
                    { x: -this.type.size * 0.5, z: 0, color: 0x00FF00, intensity: 0.8 }, // Vert arri√®re
                    { x: 0, z: this.type.size * 0.5, color: 0xFFFFFF, intensity: 0.6 }, // Blanc droite
                    { x: 0, z: -this.type.size * 0.5, color: 0xFFFFFF, intensity: 0.6 }, // Blanc gauche
                    { x: 0, y: 0.15, z: 0, color: this.type.color, intensity: 1.2 } // LED centrale status
                ];

                this.leds = [];
                ledPositions.forEach((pos, i) => {
                    const ledGeometry = new THREE.SphereGeometry(0.04, 8, 6);
                    const ledMaterial = new THREE.MeshBasicMaterial({
                        color: pos.color,
                        emissive: pos.color,
                        emissiveIntensity: pos.intensity
                    });
                    const led = new THREE.Mesh(ledGeometry, ledMaterial);
                    led.position.set(pos.x, pos.y || 0.12, pos.z);
                    this.group.add(led);
                    this.leds.push(led);

                    // Lumi√®re ponctuelle pour chaque LED
                    const ledLight = new THREE.PointLight(pos.color, pos.intensity * 0.5, 3);
                    ledLight.position.copy(led.position);
                    this.group.add(ledLight);
                });

                // Composants sp√©cialis√©s selon le r√¥le
                if (this.type.role === 'reconnaissance') {
                    // Cam√©ra gimbal stabilis√©e
                    const gimbalGeometry = new THREE.SphereGeometry(0.08, 12, 8);
                    const gimbalMaterial = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        shininess: 100
                    });
                    const gimbal = new THREE.Mesh(gimbalGeometry, gimbalMaterial);
                    gimbal.position.y = -0.1;
                    this.group.add(gimbal);

                    // Objectif de cam√©ra
                    const lensGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.06, 12);
                    const lensMaterial = new THREE.MeshPhongMaterial({
                        color: 0x001122,
                        transparent: true,
                        opacity: 0.8,
                        reflectivity: 0.9
                    });
                    const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                    lens.position.set(0, -0.12, 0.05);
                    lens.rotation.x = Math.PI / 2;
                    this.group.add(lens);
                }

                if (this.type.role === 'coordination') {
                    // Antenne de communication parabolique
                    const dishGeometry = new THREE.CylinderGeometry(0.15, 0.02, 0.02, 16);
                    const dishMaterial = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                        metalness: 0.8,
                        shininess: 200
                    });
                    const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                    dish.position.y = 0.3;
                    dish.rotation.x = Math.PI / 2;
                    this.group.add(dish);

                    // Antenne lin√©aire
                    const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.4, 8);
                    const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = 0.35;
                    this.group.add(antenna);
                }

                if (this.type.role === 'transport') {
                    // Module de transport sous le drone
                    const cargoGeometry = new THREE.BoxGeometry(
                        this.type.size * 0.8,
                        this.type.size * 0.3,
                        this.type.size * 0.6
                    );
                    const cargoMaterial = new THREE.MeshPhongMaterial({
                        color: 0x444444,
                        metalness: 0.6
                    });
                    const cargo = new THREE.Mesh(cargoGeometry, cargoMaterial);
                    cargo.position.y = -0.2;
                    cargo.castShadow = true;
                    this.group.add(cargo);

                    // Crochets de transport
                    for (let i = 0; i < 4; i++) {
                        const hookGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.08, 6);
                        const hookMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                        const hook = new THREE.Mesh(hookGeometry, hookMaterial);
                        hook.position.set(
                            (i % 2 - 0.5) * this.type.size * 0.6,
                            -0.35,
                            (Math.floor(i / 2) - 0.5) * this.type.size * 0.4
                        );
                        this.group.add(hook);
                    }
                }

                // Aura √©nerg√©tique DIAMANTS visible
                const auraGeometry = new THREE.SphereGeometry(this.type.size * 1.2, 16, 12);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: this.type.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                this.aura = new THREE.Mesh(auraGeometry, auraMaterial);
                this.group.add(this.aura);

                this.group.position.copy(this.position);
                this.group.scale.setScalar(1.5); // Agrandir pour meilleure visibilit√©

                // S√©curit√© : s'assurer que le groupe est ajout√© √† la sc√®ne
                if (!this.group.parent) {
                    scene.add(this.group);
                }
            }

            // === M√âTHODES D'INTELLIGENCE COLLECTIVE ===

            initializeCollectiveIntelligence() {
                // ACTIVATION FORC√âE DE L'INTELLIGENCE COLLECTIVE

                // Identifier le domaine d'expertise initial
                const initialDomain = this.identifyCurrentActivity();

                // Forcer l'expertise initiale
                this.specialization = initialDomain;
                this.expertiseLevel = 2.0 + Math.random() * 2.0; // Expertise imm√©diate
                this.episodicMemory.expertise = this.expertiseLevel;
                this.episodicMemory.expertiseAreas.add(initialDomain);
                this.episodicMemory.collaborationScore = 1.0 + Math.random(); // Collaboration active

                // D√©velopper l'expertise et capacit√© d'enseignement
                this.teachingAbility = this.expertiseLevel * 0.3;
                this.expertiseAreas.set(initialDomain, this.expertiseLevel);

                // Force l'√©mergence et la collaboration
                this.emergence = this.expertiseLevel * 0.5;
                this.collaborationScore = this.episodicMemory.collaborationScore;

                // Enregistrer dans la m√©moire collective (si disponible)
                if (typeof SWARM_MEMORY !== 'undefined' && SWARM_MEMORY && SWARM_MEMORY.expertiseZones) {
                    SWARM_MEMORY.expertiseZones.set(this.id, {
                        droneId: this.id,
                        position: this.position.clone(),
                        specialization: this.specialization,
                        expertiseLevel: this.expertiseLevel,
                        lastUpdate: Date.now()
                    });
                }

                // Voter pour la strat√©gie initiale
                this.submitConsensusVote('INITIAL_STRATEGY', this.behaviorAdaptation.currentStrategy, 0.8);

                console.log(`üß† Drone ${this.id} initialis√© avec intelligence collective ACTIVE - Expertise: ${initialDomain} (${this.expertiseLevel.toFixed(2)})`);
            }

            // Communication temps r√©el avec l'essaim
            broadcastToSwarm(messageType, content, priority = 1.0) {
                const now = Date.now();
                if (now - this.lastBroadcast < this.broadcastInterval * (1 / priority)) return;

                const message = {
                    type: messageType,
                    content,
                    senderId: this.id,
                    timestamp: now,
                    position: this.position.clone(),
                    priority,
                    range: this.communicationRange
                };

                // Ajouter √† la file de messages globale (si disponible)
                if (typeof SWARM_MEMORY !== 'undefined' && SWARM_MEMORY && SWARM_MEMORY.messageQueue) {
                    SWARM_MEMORY.messageQueue.push(message);
                    this.lastBroadcast = now;

                    // Trace de stigmergie pour la communication (si disponible)
                    if (SWARM_MEMORY.addStigmergyTrace) {
                        SWARM_MEMORY.addStigmergyTrace(
                            this.position,
                            this.id,
                            `COMM_${messageType}`,
                            priority * 0.5
                        );
                    }

                    console.log(`üì° Drone ${this.id} diffuse: ${messageType}`);
                }
            }

            // Vote de consensus distribu√©  
            submitConsensusVote(topic, vote, confidence = 1.0) {
                if (typeof SWARM_MEMORY === 'undefined' || !SWARM_MEMORY || !SWARM_MEMORY.submitConsensusVote) {
                    console.warn(`‚ö†Ô∏è SWARM_MEMORY non disponible pour vote: ${topic}`);
                    return null;
                }

                const adjustedConfidence = confidence * this.consensusWeight;

                const result = SWARM_MEMORY.submitConsensusVote(
                    this.id,
                    topic,
                    vote,
                    adjustedConfidence
                );

                // Enregistrer dans l'historique
                this.votingHistory.set(topic, {
                    vote,
                    confidence: adjustedConfidence,
                    timestamp: Date.now(),
                    result
                });

                return result;
            }

            // D√©veloppement d'expertise sp√©cialis√©e
            developExpertise(domain, experience) {
                if (!this.specialization) {
                    // Premi√®re sp√©cialisation
                    this.specialization = domain;
                    this.expertiseLevel = experience * 0.1;
                } else if (this.specialization === domain) {
                    // Renforcer expertise existante
                    this.expertiseLevel = Math.min(1.0,
                        this.expertiseLevel + experience * this.learningRate
                    );
                } else {
                    // Nouvelle sp√©cialisation - devenir polyvalent
                    this.expertiseLevel *= 0.9; // L√©g√®re perte
                    if (experience > 5.0) {
                        this.specialization = domain; // Changer de sp√©cialisation
                    }
                }

                // D√©velopper capacit√© d'enseignement
                if (this.expertiseLevel > 0.7) {
                    this.teachingAbility = Math.min(1.0, this.teachingAbility + 0.05);
                }

                // Offrir expertise aux autres
                if (this.expertiseLevel > 0.5 && this.teachingAbility > 0.3) {
                    this.broadcastToSwarm('EXPERTISE_OFFER', {
                        domain: this.specialization,
                        level: this.expertiseLevel,
                        teaching: this.teachingAbility
                    }, 2.0);
                }
            }

            identifyCurrentActivity() {
                // Identifier l'activit√© actuelle du drone pour d√©velopper l'expertise correspondante
                if (this.type.role === 'coordination') return 'coordination';
                if (this.type.role === 'reconnaissance') return 'reconnaissance';
                if (this.type.role === 'transport') return 'logistics';

                // Bas√© sur la strat√©gie actuelle
                const strategy = this.behaviorAdaptation.currentStrategy;
                if (strategy.includes('COORD')) return 'coordination';
                if (strategy.includes('SCOUT') || strategy.includes('EXPLORATION')) return 'exploration';

                return 'exploration'; // par d√©faut
            }
        }

        // ===== CLASSE GAZEBO CRAZYFLIE ENRICHIE AVEC IA AVANC√âE =====
        class AdvancedGazeboCrazyflie {
            constructor(id, startPosition) {
                this.id = id;
                this.name = `crazyflie${id === 0 ? '' : id}`;
                this.position = startPosition.clone();
                this.targetPosition = startPosition.clone();
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();

                // √âtats physiques r√©alistes
                this.state = 'IDLE';
                this.battery = 100;
                this.motorRPM = [0, 0, 0, 0]; // RPM des 4 moteurs
                this.mass = 0.027; // kg - masse Crazyflie

                // Mesh et props (initialiser pour √©viter les erreurs)
                this.props = [];
                this.group = null;
                this.labelSprite = null;

                // ===== PROPRI√âT√âS DIAMANTS V3 COMPL√àTES =====
                this.phi = 0;           // Potentiel attractif œÜ
                this.sigma = 0;         // Potentiel r√©pulsif œÉ
                this.gradient = new THREE.Vector3(0, 0, 0); // ‚àá(œÜ+œÉ)
                this.intelligence = 0;  // I(t) = ‚à¨|‚àá(œÜ+œÉ)|dŒ©
                this.emergence = 0;     // Amplification non-lin√©aire

                // Facteurs DIAMANTS avanc√©s
                this.wahooFactor = 1.0 + Math.random() * 0.5;
                this.scoutingPriority = Math.random();
                this.scoutingEfficiency = 0.1;
                this.collaborationScore = 0;

                // Type de drone selon DIAMANTS V3
                const droneTypes = [
                    { name: 'SCOUT', role: 'reconnaissance', size: 0.15, speed: 3.5, sensorRange: 8.0, color: 0x00FFAA },
                    { name: 'COORDINATOR', role: 'coordination', size: 0.18, speed: 3.0, sensorRange: 12.0, color: 0xFF6600 },
                    { name: 'HEAVY', role: 'transport', size: 0.22, speed: 2.5, sensorRange: 6.0, color: 0x0066FF }
                ];
                this.type = droneTypes[id % droneTypes.length];
                this.typeName = this.type.name;

                // Scouting boustroph√©don selon DIAMANTS V3
                this.boustrophedonData = {
                    assigned: false,
                    row: -1,
                    direction: 1,
                    progress: 0,
                    completed: false,
                    sectorWidth: 10,
                    sectorHeight: 10
                };

                // === SYST√àMES D'IA ENRICHIS ===

                // Syst√®me d'expertise individuel
                this.expertiseSystem = new ExpertiseSystem(id);

                // R√©seau de neurones personnel pour d√©cisions locales
                this.personalNeuralNetwork = new NeuralNetwork(8, [6, 4], 3);

                // M√©moire √† long terme enrichie
                this.longTermMemory = {
                    movementPatterns: new Map(),
                    collaborationHistory: [],
                    discoveryLog: [],
                    riskExperiences: [],
                    teachingExperiences: [],
                    innovationAttempts: []
                };

                // Historique de mouvement pour analyse de patterns
                this.movementHistory = [];
                this.maxMovementHistory = 50;

                // Syst√®me de prise de d√©cision avanc√©
                this.decisionMaking = {
                    currentDecisionTree: null,
                    confidence: 0.5,
                    alternatives: [],
                    riskTolerance: Math.random() * 0.3 + 0.4, // 0.4-0.7
                    creativityIndex: Math.random() * 0.6 + 0.2 // 0.2-0.8
                };

                // Innovation et comportements √©mergents
                this.innovation = {
                    experimentalBehaviors: new Set(),
                    successfulInnovations: [],
                    innovationScore: 0,
                    lastInnovationAttempt: 0,
                    innovationCooldown: 5000 // 5 secondes
                };

                // Communication avanc√©e
                this.communication = {
                    messageQueue: [],
                    broadcastHistory: [],
                    receivedProposals: new Map(),
                    activeVotes: new Map(),
                    trustNetwork: new Map(), // Confiance envers autres drones
                    reputationScore: 0.5
                };

                // Adaptation comportementale avanc√©e
                this.behaviorAdaptation = {
                    currentBehavior: 'exploration',
                    behaviorHistory: [],
                    adaptationRate: CONFIG.AI.adaptationSpeed,
                    contextAwareness: new Map(),
                    emergentRoles: new Set()
                };

                // Capteurs et perception enrichis
                this.sensors = {
                    range: this.type.sensorRange,
                    detectedObjects: [],
                    environmentMap: new Map(),
                    riskAssessment: new Map(),
                    opportunityDetection: new Map()
                };

                // M√©triques de performance
                this.performance = {
                    explorationEfficiency: 0,
                    collaborationEffectiveness: 0,
                    problemSolvingAbility: 0,
                    learningSpeed: 0,
                    adaptabilityScore: 0
                };

                // Communication et consensus
                this.lastConsensusParticipation = 0;
                this.communicationLevel = 0;
                this.currentBehavior = 'exploration';

                // Initialisation des syst√®mes
                this.initializeAdvancedSystems();
                this.createPhysicalDrone();
            }
            // === PHYSIQUE SIMPLE (fallback) ===
            updatePhysics(deltaTime = 0.016) {
                // Int√©grer acc√©l√©ration -> vitesse -> position (physique tr√®s simple)
                this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
                // Limiter la vitesse
                const maxSpeed = CONFIG.BOIDS?.maxSpeed || 3.0;
                if (this.velocity.length() > maxSpeed) {
                    this.velocity.setLength(maxSpeed);
                }
                // Frottements
                this.velocity.multiplyScalar(0.98);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                // Maintenir √† l'altitude de vol cible
                this.position.y = CONFIG.flightHeight || 3;
                // Reset acc√©l√©ration apr√®s int√©gration
                this.acceleration.set(0, 0, 0);
            }

            // Compat shim: certains appels utilisent ce nom pluriel
            updateDiamantsAlgorithms(deltaTime = 0.016) {
                // Calcul DIAMANTS local minimal: intelligence = norme du gradient fictif
                // Ici, approximation bas√©e sur vitesse et dispersion locale
                const localDensity = this.getNearbyDrones().length;
                const speed = this.velocity.length();
                const phi = Math.max(0, 1 - Math.min(1, localDensity / 10));
                const sigma = Math.min(1, speed / (CONFIG.BOIDS?.maxSpeed || 3));
                this.gradient.set(phi - sigma, 0, sigma - phi);
                this.intelligence = this.gradient.length() * 10;
                // L√©g√®re pouss√©e exploratoire vers zone inexplor√©e
                const target = this.findNearestUnexploredArea();
                const dir = target.clone().sub(this.position).setY(0);
                if (dir.length() > 0.001) {
                    dir.normalize();
                    this.acceleration.add(dir.multiplyScalar(0.5 * (1 - Math.min(1, localDensity / 8))));
                }
            }
            // Cr√©ation minimale du mesh physique pour √©viter erreurs avant chargements d√©taill√©s
            createPhysicalDrone() {
                try {
                    this.group = new THREE.Group();
                    this.group.position.copy(this.position);

                    // Corps simple
                    const bodyGeometry = new THREE.BoxGeometry(0.25, 0.06, 0.25);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: this.type.color || 0x00ffaa });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.castShadow = true;
                    body.receiveShadow = true;
                    this.group.add(body);

                    // 4 h√©lices simples
                    this.props = [];
                    const offsets = [
                        [0.15, 0.15],
                        [-0.15, 0.15],
                        [-0.15, -0.15],
                        [0.15, -0.15]
                    ];
                    offsets.forEach(([ox, oz], i) => {
                        const propGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.01, 8);
                        const prop = new THREE.Mesh(propGeom, new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.8 }));
                        prop.rotation.x = Math.PI / 2;
                        prop.position.set(ox, 0.05, oz);
                        this.group.add(prop);
                        this.props.push({ mesh: prop, direction: i % 2 === 0 ? 1 : -1, rpm: 0 });
                    });

                    // Indicateur label simple
                    const spriteMat = new THREE.SpriteMaterial({ color: 0x00ff88 });
                    this.labelSprite = new THREE.Sprite(spriteMat);
                    this.labelSprite.scale.set(0.4, 0.1, 1);
                    this.labelSprite.position.y = 0.2;
                    this.group.add(this.labelSprite);

                    if (typeof scene !== 'undefined') scene.add(this.group);
                } catch (e) {
                    console.warn('createPhysicalDrone fallback:', e);
                }
            }

            updateVisualization() {
                if (!this.group) return;
                // Faire tourner l√©g√®rement les h√©lices selon vitesse
                const rpmBase = 200 + this.velocity.length() * 100;
                (this.props || []).forEach(p => {
                    if (p.mesh) p.mesh.rotation.y += (rpmBase * p.direction) * 0.0005;
                });

                // Mettre √† jour le label (couleur indicative d'intelligence)
                if (this.labelSprite && this.labelSprite.material) {
                    const c = Math.min(1, this.intelligence / 20);
                    this.labelSprite.material.color.setRGB(1 - c, 1, 0.5);
                }
                // Aligner le groupe sur la position et l√©g√®re oscillation
                this.group.position.copy(this.position);
            }

            initializeAdvancedSystems() {
                // Initialiser la confiance vers les autres drones
                setTimeout(() => {
                    window.drones.forEach((other, index) => {
                        if (other.id !== this.id) {
                            this.communication.trustNetwork.set(other.id, 0.5 + Math.random() * 0.3);
                        }
                    });
                }, 1000);

                // Initialiser le contexte d'adaptation
                this.behaviorAdaptation.contextAwareness.set('terrain', 'forest');
                this.behaviorAdaptation.contextAwareness.set('mission', 'exploration');
                this.behaviorAdaptation.contextAwareness.set('weather', 'normal');

                console.log(`ü§ñ Drone ${this.id} (${this.typeName}) syst√®mes IA initialis√©s`);
            }

            // === M√âTHODES D'IA AVANC√âES ===

            makeIntelligentDecision(context) {
                // Utiliser le r√©seau de neurones pour prendre des d√©cisions
                const inputs = this.createDecisionInputs(context);
                const networkOutput = this.personalNeuralNetwork.forward(inputs);

                // Interpr√©ter la sortie du r√©seau
                const decisions = {
                    movement: networkOutput[0] > 0.5 ? 'aggressive' : 'conservative',
                    collaboration: networkOutput[1] > 0.5 ? 'active' : 'passive',
                    exploration: networkOutput[2] > 0.5 ? 'focused' : 'distributed'
                };

                // Mettre √† jour la confiance en fonction des r√©sultats
                this.decisionMaking.confidence = Math.max(0.1, Math.min(0.9,
                    this.decisionMaking.confidence + (this.getDecisionSuccess() - 0.5) * 0.1
                ));

                return decisions;
            }

            createDecisionInputs(context) {
                const nearbyDrones = this.getNearbyDrones();
                const threats = this.detectThreats();
                const opportunities = this.detectOpportunities();

                return [
                    (this.position.x + CONFIG.zoneSize / 2) / CONFIG.zoneSize, // Position normalis√©e
                    (this.position.z + CONFIG.zoneSize / 2) / CONFIG.zoneSize,
                    this.velocity.length() / CONFIG.BOIDS.maxSpeed,           // Vitesse normalis√©e
                    nearbyDrones.length / window.drones.length,              // Densit√© locale
                    threats.length / 10,                                      // Niveau de menace
                    opportunities.length / 10,                               // Niveau d'opportunit√©
                    this.intelligence / 50,                                   // Intelligence normalis√©e
                    this.battery / 100                                       // Niveau de batterie
                ];
            }

            getDecisionSuccess() {
                // √âvaluer le succ√®s des d√©cisions r√©centes
                const recentHistory = this.movementHistory.slice(-10);
                if (recentHistory.length < 5) return 0.5;

                let successScore = 0;
                recentHistory.forEach(move => {
                    if (move.discoveredTarget) successScore += 0.3;
                    if (move.avoidedCollision) successScore += 0.2;
                    if (move.improvedCoverage) successScore += 0.2;
                    if (move.collaboratedEffectively) successScore += 0.3;
                });

                return Math.min(1, successScore / recentHistory.length);
            }

            attemptInnovation() {
                const now = Date.now();
                if (now - this.innovation.lastInnovationAttempt < this.innovation.innovationCooldown) {
                    return false;
                }

                // Tenter une innovation si le drone est cr√©atif et que les m√©thodes actuelles sont inefficaces
                const shouldInnovate = this.decisionMaking.creativityIndex > 0.6 &&
                    this.performance.explorationEfficiency < 0.4;

                if (shouldInnovate) {
                    const innovation = this.generateInnovativeBehavior();
                    if (innovation) {
                        this.innovation.experimentalBehaviors.add(innovation.signature);
                        this.innovation.lastInnovationAttempt = now;
                        this.innovation.innovationScore += 0.1;

                        console.log(`üí° Drone ${this.id} tente innovation: ${innovation.description}`);
                        return innovation;
                    }
                }

                return false;
            }

            generateInnovativeBehavior() {
                const innovations = [
                    {
                        signature: 'spiral_adaptive',
                        description: 'Spirale adaptative bas√©e sur la densit√©',
                        implementation: () => this.implementAdaptiveSpiral()
                    },
                    {
                        signature: 'collaborative_leap',
                        description: 'Saut collaboratif vers zone inexplor√©e',
                        implementation: () => this.implementCollaborativeLeap()
                    },
                    {
                        signature: 'predictive_positioning',
                        description: 'Positionnement pr√©dictif bas√© sur patterns',
                        implementation: () => this.implementPredictivePositioning()
                    },
                    {
                        signature: 'energy_optimized_search',
                        description: 'Recherche optimis√©e √©nerg√©tiquement',
                        implementation: () => this.implementEnergyOptimizedSearch()
                    }
                ];

                // S√©lectionner une innovation al√©atoire non tent√©e r√©cemment
                const availableInnovations = innovations.filter(innovation =>
                    !this.innovation.experimentalBehaviors.has(innovation.signature)
                );

                if (availableInnovations.length > 0) {
                    return availableInnovations[Math.floor(Math.random() * availableInnovations.length)];
                }

                return null;
            }

            implementAdaptiveSpiral() {
                // Spirale qui s'adapte √† la densit√© locale des drones
                const nearbyDrones = this.getNearbyDrones();
                const density = nearbyDrones.length / (Math.PI * Math.pow(this.type.sensorRange, 2));

                const adaptiveRadius = 5 + (1 - density) * 10; // Plus large si moins dense
                const adaptiveSpeed = 1 + density * 2; // Plus rapide si plus dense

                const time = Date.now() * 0.001 * adaptiveSpeed;
                const angle = time + this.id * 0.5;

                return new THREE.Vector3(
                    Math.cos(angle) * adaptiveRadius,
                    0,
                    Math.sin(angle) * adaptiveRadius
                );
            }

            implementCollaborativeLeap() {
                // Saut vers une zone identifi√©e collectivement comme prioritaire
                const swarmCenter = new THREE.Vector3();
                window.drones.forEach(drone => swarmCenter.add(drone.position));
                swarmCenter.divideScalar(window.drones.length);

                // Trouver la zone la plus √©loign√©e du centre d'essaim
                const leapDirection = this.position.clone().sub(swarmCenter).normalize();
                const leapDistance = 20 + Math.random() * 15;

                return this.position.clone().add(leapDirection.multiplyScalar(leapDistance));
            }

            implementPredictivePositioning() {
                // Pr√©dire o√π les autres drones vont aller et s'positionner optimalement
                const predictedPositions = window.drones.map(drone => {
                    if (drone.id === this.id) return null;
                    return drone.position.clone().add(drone.velocity.clone().multiplyScalar(3));
                }).filter(pos => pos !== null);

                // Trouver la position qui maximise la couverture avec les positions pr√©dites
                let bestPosition = this.position.clone();
                let bestCoverage = 0;

                for (let attempts = 0; attempts < 10; attempts++) {
                    const candidatePosition = new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.zoneSize * 0.8,
                        CONFIG.flightHeight,
                        (Math.random() - 0.5) * CONFIG.zoneSize * 0.8
                    );

                    const coverage = this.calculatePositionCoverage(candidatePosition, predictedPositions);
                    if (coverage > bestCoverage) {
                        bestCoverage = coverage;
                        bestPosition = candidatePosition;
                    }
                }

                return bestPosition;
            }

            calculatePositionCoverage(position, otherPositions) {
                // Calculer la couverture unique que cette position apporterait
                const sensorRange = this.type.sensorRange;
                let uniqueCoverage = 0;

                // Grille de test pour calculer la couverture
                for (let x = -CONFIG.zoneSize / 2; x < CONFIG.zoneSize / 2; x += 5) {
                    for (let z = -CONFIG.zoneSize / 2; z < CONFIG.zoneSize / 2; z += 5) {
                        const testPoint = new THREE.Vector3(x, 0, z);
                        const distanceToCandidate = position.distanceTo(testPoint);

                        if (distanceToCandidate <= sensorRange) {
                            // V√©rifier si cette zone est d√©j√† couverte par d'autres drones
                            const alreadyCovered = otherPositions.some(otherPos =>
                                otherPos.distanceTo(testPoint) <= sensorRange
                            );

                            if (!alreadyCovered) {
                                uniqueCoverage += 1;
                            }
                        }
                    }
                }

                return uniqueCoverage;
            }

            implementEnergyOptimizedSearch() {
                // Recherche qui optimise l'√©nergie en fonction de la batterie
                const energyRatio = this.battery / 100;
                const conservationFactor = energyRatio < 0.3 ? 0.5 : 1.0;

                // R√©duire la vitesse et privil√©gier les mouvements efficaces
                const nearestUnexplored = this.findNearestUnexploredArea();
                const direction = nearestUnexplored.sub(this.position).normalize();

                return direction.multiplyScalar(2 * conservationFactor);
            }

            // === M√âTHODES DE PERCEPTION AVANC√âES ===

            getNearbyDrones(range = null) {
                const detectionRange = range || this.type.sensorRange;
                return window.drones.filter(drone =>
                    drone.id !== this.id &&
                    this.position.distanceTo(drone.position) <= detectionRange
                );
            }

            detectThreats() {
                const threats = [];

                // Collision imminente
                const nearbyDrones = this.getNearbyDrones(CONFIG.safetyDistance * 2);
                nearbyDrones.forEach(drone => {
                    const relativeVelocity = this.velocity.clone().sub(drone.velocity);
                    const timeToCollision = this.position.distanceTo(drone.position) / relativeVelocity.length();

                    if (timeToCollision < 3 && timeToCollision > 0) { // 3 secondes
                        threats.push({
                            type: 'collision',
                            source: drone.id,
                            severity: (3 - timeToCollision) / 3,
                            timeToImpact: timeToCollision
                        });
                    }
                });

                // Batterie faible
                if (this.battery < 20) {
                    threats.push({
                        type: 'low_battery',
                        severity: (20 - this.battery) / 20
                    });
                }

                // Isolement de l'essaim
                if (nearbyDrones.length === 0 && window.drones.length > 1) {
                    const distanceToNearestDrone = Math.min(...window.drones
                        .filter(d => d.id !== this.id)
                        .map(d => this.position.distanceTo(d.position))
                    );

                    if (distanceToNearestDrone > CONFIG.swarmRadius) {
                        threats.push({
                            type: 'isolation',
                            severity: Math.min(1, (distanceToNearestDrone - CONFIG.swarmRadius) / CONFIG.swarmRadius)
                        });
                    }
                }

                return threats;
            }

            detectOpportunities() {
                const opportunities = [];

                // Zones inexplor√©es √† proximit√©
                const unexploredAreas = this.findUnexploredAreasNearby();
                unexploredAreas.forEach(area => {
                    opportunities.push({
                        type: 'exploration',
                        location: area.position,
                        value: area.size / 100, // Normaliser
                        priority: area.priority || 0.5
                    });
                });

                // Opportunit√©s de collaboration
                const nearbyDrones = this.getNearbyDrones();
                if (nearbyDrones.length > 0) {
                    const collaborationPotential = nearbyDrones.reduce((sum, drone) => {
                        const trustLevel = this.communication.trustNetwork.get(drone.id) || 0.5;
                        const expertiseComplementarity = this.calculateExpertiseComplementarity(drone);
                        return sum + trustLevel * expertiseComplementarity;
                    }, 0) / nearbyDrones.length;

                    if (collaborationPotential > 0.6) {
                        opportunities.push({
                            type: 'collaboration',
                            partners: nearbyDrones.map(d => d.id),
                            value: collaborationPotential
                        });
                    }
                }

                // Opportunit√©s d'apprentissage/enseignement
                nearbyDrones.forEach(drone => {
                    if (drone.expertiseSystem) {
                        const canTeach = this.expertiseSystem.canTeach('navigation') &&
                            drone.expertiseSystem.getExpertiseLevel('navigation') < 0.5;
                        const canLearn = drone.expertiseSystem.canTeach('communication') &&
                            this.expertiseSystem.getExpertiseLevel('communication') < 0.5;

                        if (canTeach || canLearn) {
                            opportunities.push({
                                type: canTeach ? 'teaching' : 'learning',
                                partner: drone.id,
                                domain: canTeach ? 'navigation' : 'communication',
                                value: 0.7
                            });
                        }
                    }
                });

                return opportunities;
            }

            calculateExpertiseComplementarity(otherDrone) {
                if (!otherDrone.expertiseSystem || !this.expertiseSystem) return 0.5;

                let complementarity = 0;
                let domainCount = 0;

                this.expertiseSystem.expertiseDomains.forEach(domain => {
                    const myLevel = this.expertiseSystem.getExpertiseLevel(domain);
                    const otherLevel = otherDrone.expertiseSystem.getExpertiseLevel(domain);

                    // Compl√©mentarit√© maximale quand l'un est expert et l'autre novice
                    const levelDifference = Math.abs(myLevel - otherLevel);
                    complementarity += levelDifference;
                    domainCount++;
                });

                return domainCount > 0 ? complementarity / domainCount : 0.5;
            }

            findUnexploredAreasNearby(searchRadius = 20) {
                const areas = [];
                const gridSize = CONFIG.explorationGrid;
                const cellSize = CONFIG.zoneSize / gridSize;

                const myGridX = Math.floor((this.position.x + CONFIG.zoneSize / 2) / cellSize);
                const myGridZ = Math.floor((this.position.z + CONFIG.zoneSize / 2) / cellSize);

                const searchCells = Math.ceil(searchRadius / cellSize);

                for (let dx = -searchCells; dx <= searchCells; dx++) {
                    for (let dz = -searchCells; dz <= searchCells; dz++) {
                        const gridX = myGridX + dx;
                        const gridZ = myGridZ + dz;

                        if (gridX >= 0 && gridX < gridSize && gridZ >= 0 && gridZ < gridSize) {
                            if (explorationMap[gridX][gridZ] === 0) { // Non explor√©
                                const worldX = (gridX * cellSize) - CONFIG.zoneSize / 2 + cellSize / 2;
                                const worldZ = (gridZ * cellSize) - CONFIG.zoneSize / 2 + cellSize / 2;

                                areas.push({
                                    position: new THREE.Vector3(worldX, CONFIG.flightHeight, worldZ),
                                    size: cellSize,
                                    priority: this.calculateAreaPriority(gridX, gridZ)
                                });
                            }
                        }
                    }
                }

                return areas;
            }

            calculateAreaPriority(gridX, gridZ) {
                // Calculer la priorit√© d'une zone bas√©e sur divers facteurs
                let priority = 0.5;

                // Zones au centre ont priorit√© plus faible (probablement d√©j√† explor√©es)
                const centerX = CONFIG.explorationGrid / 2;
                const centerZ = CONFIG.explorationGrid / 2;
                const distanceFromCenter = Math.sqrt(Math.pow(gridX - centerX, 2) + Math.pow(gridZ - centerZ, 2));
                const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
                priority += (distanceFromCenter / maxDistance) * 0.3;

                // Zones avec beaucoup de voisins explor√©s ont priorit√© plus √©lev√©e (continuation logique)
                let exploredNeighbors = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const nx = gridX + dx;
                        const nz = gridZ + dz;
                        if (nx >= 0 && nx < CONFIG.explorationGrid && nz >= 0 && nz < CONFIG.explorationGrid) {
                            if (explorationMap[nx][nz] > 0) exploredNeighbors++;
                        }
                    }
                }
                priority += (exploredNeighbors / 8) * 0.2;

                return Math.min(1, priority);
            }

            // === COMMUNICATION ET CONSENSUS ENRICHIS ===

            receiveProposal(proposal) {
                if (this.communication.receivedProposals.has(proposal.id)) return;

                this.communication.receivedProposals.set(proposal.id, {
                    proposal: proposal,
                    receivedAt: Date.now(),
                    analyzed: false
                });

                // Analyser et voter sur la proposition
                setTimeout(() => this.analyzeAndVoteOnProposal(proposal), Math.random() * 2000 + 500);
            }

            analyzeAndVoteOnProposal(proposal) {
                if (!SWARM_MEMORY || !SWARM_MEMORY.distributedConsensus) return;

                const analysis = this.analyzeProposal(proposal);
                const vote = analysis.recommendation;
                const confidence = analysis.confidence;

                SWARM_MEMORY.distributedConsensus.castVote(this.id, proposal.id, vote, confidence);

                // Mettre √† jour les m√©triques de participation
                this.lastConsensusParticipation = Date.now();

                console.log(`üó≥Ô∏è Drone ${this.id} vote ${vote} sur ${proposal.type} (confiance: ${(confidence * 100).toFixed(1)}%)`);
            }

            analyzeProposal(proposal) {
                let supportScore = 0.5; // Neutre par d√©faut
                let confidence = 0.5;

                // Analyser bas√© sur l'expertise
                const relevantExpertise = this.getRelevantExpertiseForProposal(proposal.type);
                const expertiseBonus = relevantExpertise * 0.3;
                confidence += expertiseBonus;

                // Analyser bas√© sur la performance historique
                const historicalSuccess = this.getHistoricalSuccessRate(proposal.type);
                supportScore += (historicalSuccess - 0.5) * 0.4;

                // Analyser bas√© sur l'urgence
                if (proposal.urgency > 1.5) {
                    supportScore += 0.2; // Tendance √† soutenir les propositions urgentes
                }

                // Analyser bas√© sur la confiance envers le proposeur
                if (proposal.proposer >= 0) {
                    const trust = this.communication.trustNetwork.get(proposal.proposer) || 0.5;
                    supportScore += (trust - 0.5) * 0.2;
                }

                // D√©cision finale
                const recommendation = supportScore > 0.6 ? 'FOR' :
                    supportScore < 0.4 ? 'AGAINST' : 'ABSTAIN';

                return {
                    recommendation: recommendation,
                    confidence: Math.max(0.1, Math.min(0.9, confidence)),
                    reasoning: this.generateVoteReasoning(proposal, supportScore, relevantExpertise)
                };
            }

            getRelevantExpertiseForProposal(proposalType) {
                if (!this.expertiseSystem) return 0.5;

                const expertiseMapping = {
                    'PATTERN_CHANGE': 'navigation',
                    'FORMATION_CHANGE': 'formation_flight',
                    'PRIORITY_TARGET': 'target_detection',
                    'EMERGENCY_PROTOCOL': 'risk_assessment'
                };

                const relevantDomain = expertiseMapping[proposalType] || 'navigation';
                return this.expertiseSystem.getExpertiseLevel(relevantDomain);
            }

            getHistoricalSuccessRate(proposalType) {
                // Analyser l'historique pour ce type de proposition
                const relevantHistory = this.longTermMemory.collaborationHistory.filter(
                    event => event.type === proposalType
                );

                if (relevantHistory.length === 0) return 0.5; // Neutre si pas d'historique

                const successfulEvents = relevantHistory.filter(event => event.successful);
                return successfulEvents.length / relevantHistory.length;
            }

            generateVoteReasoning(proposal, supportScore, expertise) {
                const reasons = [];

                if (expertise > 0.7) {
                    reasons.push('expertise √©lev√©e dans le domaine');
                } else if (expertise < 0.3) {
                    reasons.push('expertise limit√©e, vote prudent');
                }

                if (supportScore > 0.7) {
                    reasons.push('forte confiance dans la proposition');
                } else if (supportScore < 0.3) {
                    reasons.push('doutes sur l\'efficacit√©');
                }

                if (proposal.urgency > 1.5) {
                    reasons.push('situation urgente n√©cessite action');
                }

                return reasons.join(', ') || 'analyse √©quilibr√©e';
            }

            receiveGlobalKnowledge(knowledge) {
                // Int√©grer les connaissances globales dans la prise de d√©cision
                this.longTermMemory.globalIntelligence = knowledge.swarmIntelligence;
                this.longTermMemory.emergentPatterns = knowledge.emergentPatterns;

                // Ajuster les param√®tres personnels bas√©s sur les patterns globaux
                if (knowledge.emergentPatterns.includes('formation_spontaneous')) {
                    this.behaviorAdaptation.emergentRoles.add('formation_keeper');
                }

                if (knowledge.emergentPatterns.includes('communication_hub')) {
                    this.behaviorAdaptation.emergentRoles.add('communication_relay');
                }

                // Utiliser les strat√©gies optimales identifi√©es
                knowledge.optimalStrategies.forEach(strategy => {
                    if (strategy.confidence > 0.7) {
                        this.longTermMemory.successfulStrategies.set(strategy.strategy, strategy.effectiveness);
                    }
                });

                // Int√©grer les √©valuations de risque
                this.sensors.riskAssessment = knowledge.riskAssessments;
            }

            updateMovementHistory() {
                const currentMovement = {
                    position: this.position.clone(),
                    velocity: this.velocity.clone(),
                    direction: Math.atan2(this.velocity.z, this.velocity.x),
                    speed: this.velocity.length(),
                    timestamp: Date.now(),
                    context: this.getCurrentMovementContext()
                };

                this.movementHistory.push(currentMovement);

                // Limiter la taille de l'historique
                if (this.movementHistory.length > this.maxMovementHistory) {
                    this.movementHistory.shift();
                }

                // Analyser les patterns si assez d'historique
                if (this.movementHistory.length >= 10) {
                    this.analyzeMovementPatterns();
                }
            }

            getCurrentMovementContext() {
                const nearbyDrones = this.getNearbyDrones();
                const threats = this.detectThreats();
                const opportunities = this.detectOpportunities();

                return {
                    nearbyDrones: nearbyDrones.length,
                    threatsDetected: threats.length,
                    opportunitiesDetected: opportunities.length,
                    battery: this.battery,
                    intelligence: this.intelligence,
                    currentBehavior: this.currentBehavior
                };
            }

            analyzeMovementPatterns() {
                // D√©tecter des patterns dans les mouvements r√©cents
                const recent = this.movementHistory.slice(-10);

                // Pattern de vitesse
                const speeds = recent.map(m => m.speed);
                const avgSpeed = speeds.reduce((sum, s) => sum + s, 0) / speeds.length;
                const speedVariation = Math.sqrt(speeds.reduce((sum, s) => sum + Math.pow(s - avgSpeed, 2), 0) / speeds.length);

                // Pattern directionnel
                const directions = recent.map(m => m.direction);
                const directionChanges = [];
                for (let i = 1; i < directions.length; i++) {
                    directionChanges.push(Math.abs(directions[i] - directions[i - 1]));
                }
                const avgDirectionChange = directionChanges.reduce((sum, d) => sum + d, 0) / directionChanges.length;

                // Stocker les patterns d√©tect√©s
                this.longTermMemory.movementPatterns.set('speed_consistency', 1 - (speedVariation / Math.max(0.1, avgSpeed)));
                this.longTermMemory.movementPatterns.set('directional_stability', 1 - (avgDirectionChange / Math.PI));
                this.longTermMemory.movementPatterns.set('exploration_efficiency', this.calculateExplorationEfficiency(recent));

                // D√©tecter des patterns inhabituels (innovations potentielles)
                if (speedVariation > avgSpeed * 0.8 || avgDirectionChange > Math.PI * 0.7) {
                    this.innovation.innovationScore += 0.05;
                }
            }

            calculateExplorationEfficiency(movementHistory) {
                if (movementHistory.length < 3) return 0.5;

                // Calculer la distance totale parcourue
                let totalDistance = 0;
                for (let i = 1; i < movementHistory.length; i++) {
                    totalDistance += movementHistory[i - 1].position.distanceTo(movementHistory[i].position);
                }

                // Calculer la distance directe du d√©but √† la fin
                const directDistance = movementHistory[0].position.distanceTo(
                    movementHistory[movementHistory.length - 1].position
                );

                // Efficacit√© = distance directe / distance totale (plus c'est proche de 1, plus c'est efficace pour aller d'un point A √† B)
                // Mais pour l'exploration, on veut parfois une efficacit√© plus faible (plus de zigzag)
                const efficiency = directDistance / Math.max(0.1, totalDistance);

                // Pour l'exploration, un m√©lange d'efficacit√© et de couverture est optimal
                return efficiency < 0.3 ? efficiency * 2 : // R√©compenser l'exploration d√©taill√©e
                    efficiency > 0.8 ? 1 - efficiency + 0.2 : // P√©naliser les lignes droites
                        efficiency; // Efficacit√© mod√©r√©e est bonne
            }

            // === M√âTHODES DE MISE √Ä JOUR ENRICHIES ===

            update(deltaTime) {
                // Sauvegarder l'ancienne position pour calculer les mouvements
                const oldPosition = this.position.clone();

                // Mise √† jour de base
                this.updatePhysics(deltaTime);
                this.updateDiamantsAlgorithms(deltaTime);
                this.updateAdvancedBehaviors(deltaTime);

                // Mise √† jour de l'historique de mouvement
                this.updateMovementHistory();

                // Apprentissage continu
                this.updateLearning(deltaTime);

                // Communication et consensus
                this.updateCommunication(deltaTime);

                // M√©triques de performance
                this.updatePerformanceMetrics(deltaTime);

                // Mise √† jour visuelle
                this.updateVisualization();
            }

            updateAdvancedBehaviors(deltaTime) {
                // Tentative d'innovation p√©riodique
                if (Math.random() < 0.001) { // 0.1% de chance par frame
                    const innovation = this.attemptInnovation();
                    if (innovation) {
                        // Appliquer l'innovation
                        const innovativeForce = innovation.implementation();
                        if (innovativeForce) {
                            this.acceleration.add(innovativeForce.multiplyScalar(0.3));
                        }
                    }
                }

                // Adaptation comportementale
                this.adaptBehaviorToContext();

                // Prise de d√©cision intelligente
                const context = this.createDecisionContext();
                const decision = this.makeIntelligentDecision(context);
                this.applyDecision(decision);

                // Interaction avec le syst√®me d'expertise
                this.updateExpertiseInteraction(deltaTime);
            }

            updateLearning(deltaTime) {
                // Apprentissage du r√©seau de neurones bas√© sur les r√©sultats
                if (this.movementHistory.length >= 10) {
                    const recentResults = this.evaluateRecentPerformance();
                    if (recentResults.success !== undefined) {
                        this.trainPersonalNetwork(recentResults);
                    }
                }

                // Mise √† jour de l'expertise bas√©e sur l'exp√©rience
                this.expertiseSystem.gainExperience('navigation', deltaTime * 0.001);

                if (this.collaborationScore > 0.7) {
                    this.expertiseSystem.gainExperience('collaboration', deltaTime * 0.002);
                }

                // Apprentissage adaptatif de l'environnement
                this.learnFromEnvironment();
            }

            adaptBehaviorToContext() {
                const context = this.behaviorAdaptation.contextAwareness;
                const nearbyDrones = this.getNearbyDrones();
                const threats = this.detectThreats();
                const opportunities = this.detectOpportunities();

                // Adapter selon le contexte
                let newBehavior = this.currentBehavior;

                if (threats.length > 0) {
                    newBehavior = 'avoidance';
                } else if (opportunities.some(op => op.type === 'collaboration' && op.value > 0.7)) {
                    newBehavior = 'collaboration';
                } else if (opportunities.some(op => op.type === 'exploration' && op.value > 0.6)) {
                    newBehavior = 'exploration';
                } else if (nearbyDrones.length > 3) {
                    newBehavior = 'formation';
                } else {
                    newBehavior = 'patrol';
                }

                // Changer de comportement si n√©cessaire
                if (newBehavior !== this.currentBehavior) {
                    this.changeBehavior(newBehavior);
                }
            }

            changeBehavior(newBehavior) {
                const oldBehavior = this.currentBehavior;
                this.currentBehavior = newBehavior;

                // Enregistrer le changement
                this.behaviorAdaptation.behaviorHistory.push({
                    from: oldBehavior,
                    to: newBehavior,
                    timestamp: Date.now(),
                    reason: this.getChangeReason(oldBehavior, newBehavior)
                });

                // Ajuster les param√®tres selon le nouveau comportement
                this.adjustParametersForBehavior(newBehavior);

                console.log(`üîÑ Drone ${this.id} change: ${oldBehavior} ‚Üí ${newBehavior}`);
            }

            updatePerformanceMetrics(deltaTime) {
                // Mettre √† jour les m√©triques de performance
                const dt = deltaTime * 0.001;

                // Efficacit√© d'exploration
                const recentMovement = this.movementHistory.slice(-5);
                if (recentMovement.length > 0) {
                    this.performance.explorationEfficiency = this.calculateExplorationEfficiency(recentMovement);
                }

                // Efficacit√© de collaboration
                const nearbyDrones = this.getNearbyDrones();
                if (nearbyDrones.length > 0) {
                    const avgCollaborationScore = nearbyDrones.reduce((sum, drone) => {
                        return sum + (this.communication.trustNetwork.get(drone.id) || 0.5);
                    }, 0) / nearbyDrones.length;

                    this.performance.collaborationEffectiveness =
                        this.performance.collaborationEffectiveness * 0.9 + avgCollaborationScore * 0.1;
                }

                // Capacit√© de r√©solution de probl√®mes
                const threatsResolved = this.countRecentThreatResolutions();
                this.performance.problemSolvingAbility =
                    this.performance.problemSolvingAbility * 0.95 + (threatsResolved * 0.1);

                // Vitesse d'apprentissage
                if (this.expertiseSystem) {
                    const recentLearning = this.expertiseSystem.getRecentLearningRate();
                    this.performance.learningSpeed =
                        this.performance.learningSpeed * 0.9 + recentLearning * 0.1;
                }

                // Score d'adaptabilit√©
                const behaviorChanges = this.behaviorAdaptation.behaviorHistory.filter(
                    change => Date.now() - change.timestamp < 60000 // Derni√®re minute
                ).length;

                this.performance.adaptabilityScore = Math.min(1, behaviorChanges / 10);
            }

            findNearestUnexploredArea() {
                // Trouver la zone inexplor√©e la plus proche
                const cellSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                let nearestDistance = Infinity;
                let nearestPosition = this.position.clone();

                for (let x = 0; x < CONFIG.explorationGrid; x++) {
                    for (let z = 0; z < CONFIG.explorationGrid; z++) {
                        if (explorationMap[x][z] === 0) { // Non explor√©
                            const worldX = (x * cellSize) - CONFIG.zoneSize / 2 + cellSize / 2;
                            const worldZ = (z * cellSize) - CONFIG.zoneSize / 2 + cellSize / 2;
                            const pos = new THREE.Vector3(worldX, CONFIG.flightHeight, worldZ);

                            const distance = this.position.distanceTo(pos);
                            if (distance < nearestDistance) {
                                nearestDistance = distance;
                                nearestPosition = pos;
                            }
                        }
                    }
                }

                return nearestPosition;
            }

            // Placeholders pour compatibilit√© avec appels plus loin dans le code
            createDecisionContext() { return { state: this.state, battery: this.battery, role: this.type.role }; }
            applyDecision(decision) { /* no-op fallback */ }
            updateExpertiseInteraction() { /* no-op fallback */ }
            trainPersonalNetwork() { /* no-op fallback */ }
            evaluateRecentPerformance() { return { success: Math.random() > 0.7 }; }
            learnFromEnvironment() { /* no-op fallback */ }
            updateCommunication() { /* no-op fallback */ }
            getChangeReason() { return 'context shift'; }
            adjustParametersForBehavior() { /* no-op */ }
            countRecentThreatResolutions() { return 0; }
        }

        // ===== CLASSE CRAZYFLIE D√âTAILL√âE (H√©ritage) =====
        class AdvancedDetailedCrazyflie extends AdvancedGazeboCrazyflie {
            constructor(id, startPosition) {
                super(id, startPosition);

                // Scouting boustroph√©don selon DIAMANTS V3
                this.boustrophedonData = {
                    assigned: false,
                    row: -1,
                    direction: 1,
                    progress: 0,
                    completed: false,
                    sectorWidth: 10,
                    sectorHeight: 10
                };

                // Intelligence collective
                this.communicationLevel = 0;
                this.adaptationLevel = 0;
                this.expertiseLevel = 0;
                this.localMemory = [];

                // Formation et mission
                this.formationType = 'free';
                this.missionType = 'exploration';
                // Strat√©gie courante (pour mapping des missions)
                this.behaviorAdaptation = { currentStrategy: 'EXPLORATION' };
                this.teamRole = this.type.role === 'coordination' ? 'leader' : 'follower';

                // Victoire modes
                this.currentMode = 'grid';
                this.patternStep = 0;
                this.searchPattern = null;
                this.lastSearchTime = 0;

                // ROS node
                this.rosNode = new ROSNode(this.name);
                this.setupROSCommunication();

                // Initialiser le groupe et ajouter imm√©diatement un mesh temporaire
                this.group = new THREE.Group();
                this.group.position.copy(this.position);

                // Cr√©er temporairement un mesh simple pendant le chargement
                this.createTemporaryMesh();
                scene.add(this.group);

                // Charger les vrais mesh de mani√®re asynchrone
                this.loadMeshes();
                this.startOdometryPublisher();

                console.log(`üöÅ Advanced Gazebo Crazyflie ${this.name} initialized`);
            }

            setupROSCommunication() {
                this.rosNode.subscribe(`/${this.name}/cmd_vel`, (msg) => {
                    this.handleVelocityCommand(msg);
                });

                this.rosNode.subscribe(`/${this.name}/takeoff`, (msg) => {
                    this.takeoff();
                });

                this.rosNode.subscribe(`/${this.name}/land`, (msg) => {
                    this.land();
                });

                this.rosNode.subscribe('/formation_command', (msg) => {
                    this.handleFormationCommand(msg);
                });

                this.rosNode.subscribe('/swarm_intelligence', (msg) => {
                    this.handleIntelligenceUpdate(msg);
                });
            }

            startOdometryPublisher() {
                this.odometryInterval = setInterval(() => {
                    try {
                        const odometryMsg = {
                            header: {
                                stamp: Date.now(),
                                frame_id: 'odom'
                            },
                            pose: {
                                pose: {
                                    position: {
                                        x: this.position.x,
                                        y: this.position.y,
                                        z: this.position.z
                                    },
                                    orientation: { x: 0, y: 0, z: 0, w: 1 }
                                }
                            },
                            twist: {
                                twist: {
                                    linear: {
                                        x: this.velocity.x,
                                        y: this.velocity.y,
                                        z: this.velocity.z
                                    }
                                }
                            }
                        };

                        this.rosNode.publish(`/${this.name}/odom`, odometryMsg);
                    } catch (error) {
                        console.error(`Error publishing odometry for ${this.name}:`, error);
                    }
                }, 20);
            }

            createTemporaryMesh() {
                // Cr√©er un mesh temporaire simple pendant le chargement - PLUS VISIBLE
                const tempGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5); // Plus gros
                const tempMaterial = new THREE.MeshBasicMaterial({
                    color: this.type.color || 0x00FFAA,
                    opacity: 0.9,
                    transparent: true
                });
                const tempMesh = new THREE.Mesh(tempGeometry, tempMaterial);
                this.group.add(tempMesh);

                // Ajouter une sph√®re brillante pour √™tre s√ªr qu'on voit quelque chose
                const sphereGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFF00, // Jaune brillant
                    wireframe: false
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.y = 0.5;
                this.group.add(sphere);

                // Initialiser props avec des donn√©es vides pour √©viter les erreurs
                this.props = [];
                for (let i = 0; i < 4; i++) {
                    this.props.push({
                        mesh: null,
                        pivot: null,
                        direction: 1,
                        rpm: 0
                    });
                }

                console.log(`üì¶ Mesh temporaire AGRANDI cr√©√© pour ${this.name}`);
            }

            async loadMeshes() {
                try {
                    // Vider le mesh temporaire
                    this.group.clear();
                    this.props = [];

                    if (!colladaLoader) {
                        console.warn(`‚ö†Ô∏è ColladaLoader non disponible pour ${this.name}, utilisation fallback`);
                        this.createFallbackMesh();
                        return;
                    }

                    console.log(`üîÑ Chargement mesh pour ${this.name}...`);

                    // Charger les mesh depuis cache ou fichiers
                    if (!meshCache.cf2_assembly) {
                        try {
                            const bodyCollada = await this.loadColladaFile('cf2_assembly.dae');
                            meshCache.cf2_assembly = bodyCollada.scene;
                            console.log('‚úÖ cf2_assembly.dae charg√©');
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Erreur cf2_assembly.dae, utilisation fallback');
                            this.createFallbackMesh();
                            return;
                        }
                    }

                    if (!meshCache.cw_prop) {
                        try {
                            const cwPropCollada = await this.loadColladaFile('cw_prop.dae');
                            meshCache.cw_prop = cwPropCollada.scene;
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Erreur cw_prop.dae');
                        }
                    }

                    if (!meshCache.ccw_prop) {
                        try {
                            const ccwPropCollada = await this.loadColladaFile('ccw_prop.dae');
                            meshCache.ccw_prop = ccwPropCollada.scene;
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Erreur ccw_prop.dae');
                        }
                    }

                    this.createMeshFromGazebo();

                } catch (error) {
                    console.warn(`‚ùå Erreur chargement mesh pour ${this.name}:`, error);
                    this.createFallbackMesh();
                }
            }

            loadColladaFile(filename) {
                return new Promise((resolve, reject) => {
                    if (!colladaLoader) {
                        reject(new Error('ColladaLoader not available'));
                        return;
                    }

                    const fullPath = CONFIG.meshPath + filename;
                    console.log(`üîÑ Tentative chargement: ${fullPath}`);

                    colladaLoader.load(
                        fullPath,
                        (collada) => {
                            console.log(`‚úÖ Charg√©: ${filename}`);
                            resolve(collada);
                        },
                        (progress) => {
                            const percent = progress.total > 0 ? (progress.loaded / progress.total * 100) : 0;
                            console.log(`üìà ${filename}: ${percent.toFixed(1)}%`);
                        },
                        (error) => {
                            console.warn(`‚ùå Erreur ${filename}:`, error);
                            reject(error);
                        }
                    );
                });
            }

            createMeshFromGazebo() {
                // Corps principal avec mat√©riau intelligent
                if (meshCache.cf2_assembly) {
                    this.body = meshCache.cf2_assembly.clone();
                    this.body.scale.setScalar(CONFIG.modelScale);
                    // Orienter le mod√®le COLLADA (Z-up) vers Y-up Three.js
                    this.body.rotation.x = -Math.PI / 2;

                    // Recentrer le corps pour aligner les coordonn√©es de moteur (0,0,0 au centre)
                    {
                        const bodyBox0 = new THREE.Box3().setFromObject(this.body);
                        const bodyCenter0 = bodyBox0.getCenter(new THREE.Vector3());
                        this.body.position.sub(bodyCenter0);
                    }

                    this.body.traverse((child) => {
                        if (child.isMesh) {
                            // Couleur bas√©e sur l'intelligence
                            const intelligenceColor = this.id % 2 === 0 ?
                                GAZEBO_MATERIALS.crazyflie_red :
                                GAZEBO_MATERIALS.crazyflie_blue;
                            child.material = intelligenceColor;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    this.group.add(this.body);

                    // Calculer la hauteur pour positionner correctement les h√©lices
                    const bodyBox = new THREE.Box3().setFromObject(this.body);
                    this.bodyTopY = bodyBox.max.y; // hauteur du dessus du drone
                }

                // H√©lices avec positions DIAMANTS_FRONTEND exactes
                this.props = [];
                CONFIG.motorPositions.forEach((motorPos, i) => {
                    const propMesh = motorPos.direction === 'cw' ?
                        meshCache.cw_prop?.clone() :
                        meshCache.ccw_prop?.clone();

                    if (propMesh) {
                        // Monter l'h√©lice sur un pivot pour garantir l'alignement et la rotation autour du centre
                        const pivot = new THREE.Group();
                        const pivotY = (typeof motorPos.height === 'number' ? motorPos.height * CONFIG.modelScale : (typeof this.bodyTopY === 'number' ? this.bodyTopY + 0.003 : 0.02));
                        // Appliquer la m√™me √©chelle que le corps pour garder l'alignement lat√©ral
                        const sx = (motorPos.x ?? 0) * CONFIG.modelScale;
                        const sz = ((motorPos.y !== undefined ? motorPos.y : motorPos.z) ?? 0) * CONFIG.modelScale;
                        pivot.position.set(sx, pivotY, sz);

                        // Orienter le mod√®le pour que le disque d'h√©lice soit horizontal (normal Y)
                        // 1) √âchelle d'abord
                        propMesh.scale.setScalar(CONFIG.modelScale);
                        // 2) Recentrer
                        let box = new THREE.Box3().setFromObject(propMesh);
                        let center = box.getCenter(new THREE.Vector3());
                        propMesh.position.sub(center);
                        // 3) D√©terminer l'axe le plus fin (√©paisseur), l'aligner sur Y
                        box = new THREE.Box3().setFromObject(propMesh);
                        const size = box.getSize(new THREE.Vector3());
                        const axes = [{ k: 'x', v: size.x }, { k: 'y', v: size.y }, { k: 'z', v: size.z }].sort((a, b) => a.v - b.v);
                        const thin = axes[0].k;
                        if (thin === 'z') {
                            // √âpaisseur sur Z -> faire Z devenir Y
                            propMesh.rotation.x = -Math.PI / 2;
                        } else if (thin === 'x') {
                            // √âpaisseur sur X -> faire X devenir Y
                            propMesh.rotation.z = Math.PI / 2;
                        } else {
                            // thin === 'y' -> d√©j√† correctement orient√©
                        }

                        propMesh.traverse((child) => {
                            if (child.isMesh) {
                                child.material = GAZEBO_MATERIALS.propeller;
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        pivot.add(propMesh);
                        this.group.add(pivot);
                        this.props.push({
                            mesh: propMesh,
                            pivot,
                            direction: motorPos.direction === 'cw' ? 1 : -1,
                            rpm: 0
                        });
                    }
                });

                this.createIntelligenceIndicators();
                this.group.position.copy(this.position);

                // Le groupe est d√©j√† ajout√© √† la sc√®ne dans le constructeur
                console.log(`‚úÖ Advanced Mesh Gazebo charg√© pour ${this.name}`);
            }

            createFallbackMesh() {
                // Vider le groupe temporaire
                this.group.clear();

                // Version simplifi√©e avec indicateurs d'intelligence - PLUS GROS pour √™tre visible
                const bodyGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5); // Beaucoup plus gros
                this.body = new THREE.Mesh(bodyGeometry, GAZEBO_MATERIALS.crazyflie_red);
                this.group.add(this.body);

                this.props = [];
                CONFIG.motorPositions.forEach((pos, i) => {
                    const propGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.01, 8); // Plus grosses h√©lices
                    const prop = new THREE.Mesh(propGeometry, GAZEBO_MATERIALS.propeller);
                    prop.position.set(pos.x * 2, 0.06, pos.z * 2); // Positions plus √©tal√©es
                    this.group.add(prop);
                    this.props.push({
                        mesh: prop,
                        direction: pos.direction === 'cw' ? 1 : -1,
                        rpm: 0
                    });
                });

                this.createIntelligenceIndicators();
                this.group.position.copy(this.position);

                // Le groupe est d√©j√† ajout√© √† la sc√®ne dans le constructeur

                console.log(`‚ö†Ô∏è Advanced Fallback mesh utilis√© pour ${this.name} - TAILLE AGRANDIE`);
            }

            createIntelligenceIndicators() {
                // Label avec nom et intelligence
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 160;
                canvas.height = 40;

                context.fillStyle = '#000000';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = '#00FFFF';
                context.font = 'Bold 12px Arial';
                context.textAlign = 'center';
                context.fillText(this.name, canvas.width / 2, 15);
                context.fillStyle = '#00FF88';
                context.font = '10px Arial';
                context.fillText(`I:${this.intelligence.toFixed(1)}`, canvas.width / 2, 30);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                this.labelSprite = new THREE.Sprite(spriteMaterial);
                this.labelSprite.scale.set(0.8, 0.2, 1);
                this.labelSprite.position.y = 0.3;
                this.group.add(this.labelSprite);

                // Indicateur d'√©mergence (anneau color√©)
                const ringGeometry = new THREE.RingGeometry(0.15, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FF88,
                    transparent: true,
                    opacity: 0.6
                });
                this.emergenceRing = new THREE.Mesh(ringGeometry, ringMaterial);
                this.emergenceRing.rotation.x = -Math.PI / 2;
                this.emergenceRing.position.y = -0.01;
                this.group.add(this.emergenceRing);
            }

            update(deltaTime, allDrones) {
                // ===== CALCUL DIAMANTS V3 COMPLET =====
                this.updateDIAMANTSAlgorithm(allDrones, deltaTime);

                // √âtats de vol avec physique r√©aliste  
                this.updateFlightPhysics(deltaTime, allDrones);

                // Mise √† jour des visuels (seulement si mesh charg√©s)
                if (this.group && this.props) {
                    this.updateAdvancedVisuals(deltaTime);
                }
            }

            updateDIAMANTSAlgorithm(allDrones, deltaTime = 0.016) {
                // ===== CALCUL DIAMANTS V3 COMPLET (depuis victoire) =====

                // 1. Calcul des potentiels œÜ (attractif) et œÉ (r√©pulsif)
                this.phi = 0;
                this.sigma = 0;

                // Variables pour le comportement d'essaim
                const cohesion = new THREE.Vector3(0, 0, 0);
                const separation = new THREE.Vector3(0, 0, 0);
                const alignment = new THREE.Vector3(0, 0, 0);
                let neighborCount = 0;

                allDrones.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = this.position.distanceTo(other.position);

                        if (dist > 0.1 && dist < CONFIG.swarmRadius || 30) {
                            neighborCount++;

                            // === DIAMANTS SCOUTING : œÜ (COH√âSION) et œÉ (EXPLORATION) ===
                            // œÜ (phi) : Force attractive pour coordination scouting
                            this.phi += CONFIG.magneticForce * Math.exp(-dist * 0.05) *
                                (other.type?.role === 'coordination' ? 1.5 : 1.0); // Attraction vers leaders

                            // œÉ (sigma) : Force r√©pulsive pour √©viter chevauchement zones scouting
                            this.sigma += 3.0 * Math.exp(-dist * dist * 0.02) *
                                (1.0 + this.scoutingPriority); // Plus fort si priorit√© haute

                            // Modulation DIAMANTS selon r√¥les
                            if (this.type.role === 'coordination' && other.type?.role !== 'coordination') {
                                this.phi *= 0.8; // Leaders moins attir√©s
                                this.sigma *= 1.3; // Mais maintiennent distance
                            }

                            // BOIDS - Coh√©sion (attraction vers le centre de masse)
                            cohesion.add(other.position);

                            // BOIDS - Alignement (align avec la vitesse moyenne)
                            alignment.add(other.velocity);

                            // BOIDS - S√©paration (√©vitement collision)
                            if (dist < 8) {
                                const separate = this.position.clone().sub(other.position);
                                separate.normalize().divideScalar(dist); // Plus proche = plus forte
                                separation.add(separate);
                            }
                        }
                    }
                });

                // Finaliser les forces BOIDS
                if (neighborCount > 0) {
                    // Coh√©sion - se diriger vers le centre de masse
                    cohesion.divideScalar(neighborCount);
                    cohesion.sub(this.position);
                    cohesion.normalize().multiplyScalar(CONFIG.swarmCohesion || 0.3);

                    // Alignement - s'aligner avec la vitesse moyenne
                    alignment.divideScalar(neighborCount);
                    alignment.normalize().multiplyScalar(CONFIG.swarmAlignment || 0.2);

                    // S√©paration - √©viter les collisions
                    if (separation.length() > 0) {
                        separation.normalize().multiplyScalar(CONFIG.swarmSeparation || 0.5);
                    }
                }

                // 2. Calcul du gradient ‚àá(œÜ+œÉ) - DIAMANTS SCOUTING AVANC√â
                const h = 0.8; // Pr√©cision adapt√©e au scouting

                // Gradient spatial complet avec composante d'altitude
                const gradX = (this.sampleScoutingPotential(this.position.x + h, this.position.y, this.position.z, allDrones) -
                    this.sampleScoutingPotential(this.position.x - h, this.position.y, this.position.z, allDrones)) / (2 * h);
                const gradY = (this.sampleScoutingPotential(this.position.x, this.position.y + h, this.position.z, allDrones) -
                    this.sampleScoutingPotential(this.position.x, this.position.y - h, this.position.z, allDrones)) / (2 * h);
                const gradZ = (this.sampleScoutingPotential(this.position.x, this.position.y, this.position.z + h, allDrones) -
                    this.sampleScoutingPotential(this.position.x, this.position.y, this.position.z - h, allDrones)) / (2 * h);

                // S√©curit√© num√©rique
                if (isFinite(gradX) && isFinite(gradY) && isFinite(gradZ)) {
                    this.gradient.set(gradX, gradY * 0.3, gradZ); // R√©duire Y pour vol horizontal
                } else {
                    this.gradient.set(0, 0, 0);
                }

                // 3. Intelligence DIAMANTS scouting : I(t) = ‚à¨|‚àá(œÜ+œÉ)|dŒ©
                const rawIntelligence = this.gradient.length();
                this.intelligence = rawIntelligence * this.wahooFactor * (1.0 + this.scoutingPriority);

                // 4. √âmergence collaborative : amplification non-lin√©aire
                const collaborationFactor = 1.0 + this.collaborationScore * 0.5;
                this.emergence = Math.pow(this.intelligence * collaborationFactor, 1.2);

                // 5. Mise √† jour des m√©triques de scouting
                this.updateScoutingMetrics();

                // 6. Force d'exploration optimale
                const explorationForce = this.getExplorationForce(allDrones);

                // 7. Force de pattern selon le mode
                const patternForce = this.getPatternForce(allDrones);

                // 8. Force collaborative pour scouting coordonn√©
                const collaborativeForce = this.getCollaborativeScoutingForce(allDrones);

                // 9. Force DIAMANTS pure
                const diamantForce = this.gradient.clone().multiplyScalar(0.3);

                // 10. Force combin√©e optimis√©e pour scouting collaboratif
                const totalForce = new THREE.Vector3()
                    .add(diamantForce.multiplyScalar(0.4))
                    .add(cohesion.multiplyScalar(0.6))
                    .add(separation.multiplyScalar(1.0))
                    .add(alignment.multiplyScalar(0.7))
                    .add(explorationForce.multiplyScalar(0.8)) // Force de recherche
                    .add(patternForce.multiplyScalar(CONFIG.autonomyPower || 0.5))
                    .add(collaborativeForce.multiplyScalar(1.2)); // Force collaborative importante

                // 11. Int√©gration physique optimis√©e avec deltaTime r√©el
                const accelerationFactor = 0.02 * (deltaTime / 0.016); // Adaptation √† deltaTime
                this.velocity.add(totalForce.multiplyScalar(accelerationFactor));
                this.velocity.clampLength(0, this.type.speed * 0.8); // Limite la vitesse maximum

                // Friction adapt√©e au deltaTime pour mouvement plus fluide
                const frictionFactor = Math.pow(0.92, deltaTime / 0.016);
                this.velocity.multiplyScalar(frictionFactor);

                // Mise √† jour position avec contraintes spatiales
                const oldPos = this.position.clone();
                const deltaPos = this.velocity.clone().multiplyScalar(deltaTime);

                // V√©rification de validit√© du d√©placement
                if (isFinite(deltaPos.x) && isFinite(deltaPos.y) && isFinite(deltaPos.z)) {
                    this.position.add(deltaPos);

                    // D√©tection de t√©l√©portation (mouvement trop brusque)
                    const maxMovement = 2.0; // Distance maximum raisonnable par frame
                    const movementDistance = oldPos.distanceTo(this.position);
                    if (movementDistance > maxMovement) {
                        console.warn(`‚ö†Ô∏è  Mouvement suspect d√©tect√© pour drone ${this.id}: ${movementDistance.toFixed(2)}m`);
                        this.position.copy(oldPos);
                        this.velocity.multiplyScalar(0.5); // R√©duire la vitesse
                    }
                } else {
                    console.warn(`Mouvement invalide d√©tect√© pour drone ${this.id}, arr√™t temporaire`);
                    this.velocity.set(0, 0, 0);
                }

                // Contraintes de zone foresti√®re - SANS T√âL√âPORTATION
                this.applyZoneConstraints();

                // Intelligence collective: traitement des messages de l'essaim
                this.receiveSwarmMessages(allDrones);
            }

            sampleScoutingPotential(x, y, z, allDrones) {
                let potential = 0;

                // Potentiel des autres drones
                allDrones.forEach(other => {
                    if (other.id !== this.id) {
                        const dx = x - other.position.x;
                        const dy = y - other.position.y;
                        const dz = z - other.position.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist > 0.1) {
                            // Attraction collaborative mod√©r√©e
                            potential += CONFIG.magneticForce * Math.exp(-dist * 0.05) / (1.0 + dist);
                            // R√©pulsion pour √©viter collision
                            potential -= 5.0 * Math.exp(-dist * dist * 0.1);
                        }
                    }
                });

                // Potentiel des cibles de scouting
                if (typeof scoutingTargets !== 'undefined') {
                    scoutingTargets.forEach(target => {
                        if (!target.discovered) {
                            const dx = x - target.position.x;
                            const dz = z - target.position.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            // Attraction vers cibles non d√©couvertes
                            potential += target.value * Math.exp(-dist * 0.2) * 2.0;
                        }
                    });
                }

                // Potentiel d'√©vitement d'obstacles
                if (typeof trees !== 'undefined') {
                    trees.forEach(tree => {
                        const dx = x - tree.position.x;
                        const dz = z - tree.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < tree.radius + 5) {
                            potential -= 100.0 * Math.exp(-dist * 0.5); // Forte r√©pulsion arbres
                        }
                    });
                }

                return potential;
            }

            updateScoutingMetrics() {
                // Mise √† jour efficacit√© scouting
                this.scoutingEfficiency = Math.min(1.0, this.scoutingEfficiency + this.intelligence * 0.001);

                // Score de collaboration bas√© sur proximit√© avec autres drones
                this.collaborationScore = 0;
                const collaborationRange = 20;

                if (typeof drones !== 'undefined') {
                    drones.forEach(other => {
                        if (other.id !== this.id) {
                            const dist = this.position.distanceTo(other.position);
                            if (dist < collaborationRange) {
                                // Bonus collaboration pour coordination optimale
                                const efficiency = (collaborationRange - dist) / collaborationRange;
                                this.collaborationScore += efficiency * 0.1;
                            }
                        }
                    });
                }

                this.collaborationScore = Math.min(1.0, this.collaborationScore);
            }

            applyZoneConstraints() {
                const boundary = CONFIG.zoneSize / 2 - 5; // Marge de s√©curit√©

                // Contraintes douces par rebond progressif (Z√âRO T√âL√âPORTATION)
                if (Math.abs(this.position.x) > boundary) {
                    const overshoot = Math.abs(this.position.x) - boundary;
                    const reboundForce = -Math.sign(this.position.x) * Math.min(2.0, overshoot * 0.5);
                    this.velocity.x = this.velocity.x * 0.3 + reboundForce;
                }

                if (Math.abs(this.position.z) > boundary) {
                    const overshoot = Math.abs(this.position.z) - boundary;
                    const reboundForce = -Math.sign(this.position.z) * Math.min(2.0, overshoot * 0.5);
                    this.velocity.z = this.velocity.z * 0.3 + reboundForce;
                }

                // Contrainte d'altitude GRADUELLE
                const groundLevel = 2.0;
                const maxAltitude = 15.0;

                if (this.position.y < groundLevel) {
                    const deficit = groundLevel - this.position.y;
                    this.velocity.y += deficit * 0.5;
                    this.velocity.y = Math.max(0.1, this.velocity.y);
                } else if (this.position.y > maxAltitude) {
                    const excess = this.position.y - maxAltitude;
                    this.velocity.y -= excess * 0.5;
                    this.velocity.y = Math.min(-0.1, this.velocity.y);
                }

                // Force naturelle vers l'altitude optimale
                const targetAlt = this.calculateOptimalAltitude();
                const altitudeDifference = targetAlt - this.position.y;

                if (Math.abs(altitudeDifference) > 0.5) {
                    const altForce = altitudeDifference * 0.3;
                    this.velocity.y += altForce * 0.02;
                }

                // Limiter la vitesse verticale
                this.velocity.y = Math.max(-2.0, Math.min(2.0, this.velocity.y));
            }

            calculateOptimalAltitude() {
                // Altitude optimale selon le r√¥le
                switch (this.type.role) {
                    case 'reconnaissance': return 8.0; // Niveau troncs pour scouting
                    case 'coordination': return 12.0; // Plus haut pour vue d'ensemble
                    case 'transport': return 6.0; // Plus bas, plus stable
                    default: return 8.0;
                }
            }

            receiveSwarmMessages(allDrones) {
                // Traitement basique des messages d'intelligence collective
                if (typeof SWARM_MEMORY !== 'undefined' && SWARM_MEMORY && SWARM_MEMORY.messageQueue) {
                    SWARM_MEMORY.messageQueue.forEach(msg => {
                        if (msg.senderId !== this.id) {
                            // Bonus intelligence pour communication
                            this.intelligence += 0.01;
                        }
                    });
                } else {
                    // SWARM_MEMORY pas encore initialis√©e, passer silencieusement
                    return;
                }
            }

            // === EXPLORATION FORCE DEPUIS DIAMANTS V3 ===
            getExplorationForce(allDrones) {
                // Pattern de recherche en essaim optimis√© pour for√™t dense
                const pattern = SEARCH_PATTERNS ? SEARCH_PATTERNS[currentSearchPattern || 0] : 'grid';
                const force = new THREE.Vector3(0, 0, 0);
                const time = Date.now() * 0.001;

                switch (pattern) {
                    case 'grid':
                        // === BOUSTROPH√âDON OPTIMIS√â ===
                        if (!this.boustrophedonData.assigned) {
                            this.assignBoustrophedonSector();
                        }

                        const boustTarget = this.getBoustrophedonWaypoint();
                        if (boustTarget) {
                            const targetForce = new THREE.Vector3(
                                boustTarget.x - this.position.x,
                                0,
                                boustTarget.z - this.position.z
                            );
                            const distance = targetForce.length();

                            if (distance < 3) {
                                this.advanceBoustrophedonProgress();
                            } else {
                                targetForce.normalize().multiplyScalar(3.0);
                                force.add(targetForce);
                            }
                        }
                        break;

                    case 'spiral':
                        const spiralRadius = 8 + this.patternStep * 0.8;
                        const spiralAngle = time * 0.4 + this.id * 0.8;
                        const spiralCenter = this.findNearestUnexploredArea();

                        const spiralX = spiralCenter.x + Math.cos(spiralAngle) * spiralRadius;
                        const spiralZ = spiralCenter.z + Math.sin(spiralAngle) * spiralRadius;

                        force.set(spiralX - this.position.x, 0, spiralZ - this.position.z);
                        force.normalize().multiplyScalar(2.0);

                        if (spiralRadius > 25) this.patternStep = 0;
                        else this.patternStep += 0.015;
                        break;

                    case 'random':
                        if (!this.searchPattern || time - this.lastSearchTime > 3.5) {
                            const unexploredArea = this.findBestUnexploredSector();
                            this.searchPattern = {
                                x: unexploredArea.x + (Math.random() - 0.5) * 10,
                                z: unexploredArea.z + (Math.random() - 0.5) * 10
                            };
                            this.lastSearchTime = time;
                        }

                        if (this.searchPattern) {
                            const dist = Math.sqrt(
                                Math.pow(this.searchPattern.x - this.position.x, 2) +
                                Math.pow(this.searchPattern.z - this.position.z, 2)
                            );

                            if (dist < 6) {
                                this.searchPattern = null;
                            } else {
                                force.set(
                                    this.searchPattern.x - this.position.x,
                                    0,
                                    this.searchPattern.z - this.position.z
                                );
                                force.normalize().multiplyScalar(2.0);
                            }
                        }
                        break;
                }

                return force;
            }

            // === FORCE COLLABORATIVE DEPUIS DIAMANTS V3 ===
            getCollaborativeScoutingForce(allDrones) {
                const force = new THREE.Vector3();
                const scoutingRange = 20;

                // 1. ANTI-REDONDANCE: √âviter les zones d√©j√† scout√©es
                const avoidanceForce = this.calculateRedundancyAvoidance(allDrones);
                force.add(avoidanceForce.multiplyScalar(3.0));

                // 2. ASSIGNMENT OPTIMAL: Secteur d√©di√© par drone
                const sectorForce = this.getOptimalSectorAssignment(allDrones);
                force.add(sectorForce.multiplyScalar(4.0));

                return force;
            }

            calculateRedundancyAvoidance(allDrones) {
                const avoidanceForce = new THREE.Vector3();
                const redundancyRadius = 15;

                allDrones.forEach(other => {
                    if (other === this) return;

                    const distance = this.position.distanceTo(other.position);
                    if (distance < redundancyRadius) {
                        const repulsion = this.position.clone().sub(other.position);
                        repulsion.y = 0;

                        if (repulsion.length() > 0.1) {
                            repulsion.normalize();
                            const intensity = (redundancyRadius - distance) / redundancyRadius;
                            avoidanceForce.add(repulsion.multiplyScalar(intensity * intensity * 5.0));
                        }
                    }
                });

                return avoidanceForce;
            }

            getOptimalSectorAssignment(allDrones) {
                const sectorForce = new THREE.Vector3();
                const totalDrones = allDrones.length;
                const optimalGrid = this.calculateOptimalGridSize(totalDrones);

                // Assignment basique mais adaptatif
                const droneIndex = allDrones.indexOf(this);
                const adaptiveIndex = (droneIndex + Math.floor(Date.now() / 10000)) % totalDrones;
                const sectorSize = CONFIG.zoneSize / optimalGrid;
                const sectorX = (adaptiveIndex % optimalGrid) - Math.floor(optimalGrid / 2);
                const sectorZ = Math.floor(adaptiveIndex / optimalGrid) - Math.floor(optimalGrid / 2);

                const targetSectorX = sectorX * sectorSize;
                const targetSectorZ = sectorZ * sectorSize;

                sectorForce.set(
                    targetSectorX - this.position.x,
                    0,
                    targetSectorZ - this.position.z
                );
                sectorForce.normalize().multiplyScalar(3.0);

                return sectorForce;
            }

            calculateOptimalGridSize(totalDrones) {
                if (totalDrones <= 4) return 3;
                if (totalDrones <= 9) return 4;
                if (totalDrones <= 16) return 5;
                if (totalDrones <= 25) return 6;
                return Math.ceil(Math.sqrt(totalDrones)) + 1;
            }

            // === BOUSTROPH√âDON DEPUIS DIAMANTS V3 ===
            assignBoustrophedonSector() {
                const totalRows = CONFIG.explorationGrid || 8;
                this.boustrophedonData.row = this.id % totalRows;
                this.boustrophedonData.direction = (this.boustrophedonData.row % 2 === 0) ? 1 : -1;
                this.boustrophedonData.progress = 0;
                this.boustrophedonData.assigned = true;
                this.boustrophedonData.sectorWidth = 10;
                this.boustrophedonData.sectorHeight = 10;
            }

            getBoustrophedonWaypoint() {
                const data = this.boustrophedonData;
                if (!data.assigned || data.completed) return null;

                const totalCols = CONFIG.explorationGrid || 8;
                let currentCol = Math.floor(data.progress);

                if (data.direction === -1) {
                    currentCol = totalCols - 1 - currentCol;
                }

                if (Math.floor(data.progress) >= totalCols) {
                    data.completed = true;
                    return null;
                }

                const x = (currentCol - totalCols / 2 + 0.5) * data.sectorWidth;
                const z = (data.row - totalCols / 2 + 0.5) * data.sectorHeight;

                return { x, z };
            }

            advanceBoustrophedonProgress() {
                this.boustrophedonData.progress += 1;

                const totalCols = CONFIG.explorationGrid || 8;
                let currentCol = Math.floor(this.boustrophedonData.progress - 1);

                if (this.boustrophedonData.direction === -1) {
                    currentCol = totalCols - 1 - currentCol;
                }

                if (typeof explorationMap !== 'undefined' && explorationMap[currentCol] &&
                    currentCol >= 0 && currentCol < totalCols &&
                    this.boustrophedonData.row >= 0 && this.boustrophedonData.row < totalCols) {
                    explorationMap[currentCol][this.boustrophedonData.row] = 1.0;
                }
            }

            findNearestUnexploredArea() {
                let bestArea = { x: 0, z: 0 };
                let minExploration = Infinity;

                const grid = CONFIG.explorationGrid || 8;
                for (let i = 0; i < grid; i++) {
                    for (let j = 0; j < grid; j++) {
                        const exploration = (typeof explorationMap !== 'undefined' && explorationMap[i]) ? explorationMap[i][j] : 0;
                        if (exploration < minExploration) {
                            minExploration = exploration;
                            const gridSize = CONFIG.zoneSize / grid;
                            bestArea.x = (i - grid / 2 + 0.5) * gridSize;
                            bestArea.z = (j - grid / 2 + 0.5) * gridSize;
                        }
                    }
                }

                return bestArea;
            }

            findBestUnexploredSector() {
                const grid = CONFIG.explorationGrid || 8;
                const sectorSize = CONFIG.zoneSize / grid;
                let bestSector = { x: 0, z: 0 };
                let bestScore = -Infinity;

                for (let i = 0; i < grid; i++) {
                    for (let j = 0; j < grid; j++) {
                        const sectorX = (i - grid / 2 + 0.5) * sectorSize;
                        const sectorZ = (j - grid / 2 + 0.5) * sectorSize;
                        const distance = Math.sqrt(
                            Math.pow(sectorX - this.position.x, 2) +
                            Math.pow(sectorZ - this.position.z, 2)
                        );

                        const exploration = (typeof explorationMap !== 'undefined' && explorationMap[i]) ? explorationMap[i][j] : 0;
                        const score = (1 - exploration) / (distance + 5) * 100;

                        if (score > bestScore) {
                            bestScore = score;
                            bestSector = { x: sectorX, z: sectorZ };
                        }
                    }
                }

                return bestSector;
            }

            updateCollectiveIntelligence(allDrones) {
                // Communication range-based
                this.communicationLevel = 0;
                const commRange = 8.0;

                allDrones.forEach(other => {
                    if (other.id !== this.id) {
                        const distance = this.position.distanceTo(other.position);
                        if (distance < commRange) {
                            this.communicationLevel++;
                            // Partage d'information (simple)
                            this.shareInformation(other);
                        }
                    }
                });

                // Adaptation bas√©e sur l'exp√©rience
                this.adaptationLevel = Math.min(100,
                    this.localMemory.length * 0.5 + this.intelligence * 0.2);

                // Expertise bas√©e sur l'intelligence et l'adaptation
                this.expertiseLevel = (this.intelligence + this.adaptationLevel) / 2;

                // Mise √† jour de la m√©moire locale
                this.updateLocalMemory();
            }

            shareInformation(otherDrone) {
                // Partage simple d'information entre drones
                if (this.intelligence > otherDrone.intelligence * 1.2) {
                    // Ce drone est "expert", partage sa connaissance
                    otherDrone.localMemory.push({
                        source: this.name,
                        data: 'expertise_share',
                        value: this.intelligence * 0.1,
                        timestamp: Date.now()
                    });
                }
            }

            updateLocalMemory() {
                // Ajouter nouvelle exp√©rience
                this.localMemory.push({
                    position: this.position.clone(),
                    intelligence: this.intelligence,
                    timestamp: Date.now(),
                    context: this.state
                });

                // Limiter la taille de la m√©moire
                if (this.localMemory.length > 50) {
                    this.localMemory.shift();
                }

                // Nettoyer les anciennes entr√©es
                this.localMemory = this.localMemory.filter(entry =>
                    Date.now() - entry.timestamp < 30000
                );
            }

            updateFlightPhysics(deltaTime, allDrones) {
                switch (this.state) {
                    case 'TAKEOFF':
                        this.handleTakeoff(deltaTime);
                        break;
                    case 'FLYING':
                        this.handleFlying(deltaTime, allDrones);
                        break;
                    case 'LANDING':
                    case 'EMERGENCY':
                        this.handleLanding(deltaTime);
                        break;
                }

                // Mise √† jour des RPM des moteurs
                this.updateMotorRPM();
            }

            handleTakeoff(deltaTime) {
                const targetAlt = this.targetPosition.y || CONFIG.flightHeight;
                if (this.position.y < targetAlt - 0.05) {
                    // Simple ascent profile with capped RPM
                    const climb = 2.0; // m/s
                    this.motorRPM.fill(Math.min(CONFIG.maxRPM, 1800));
                    this.velocity.y = climb;
                    this.position.y += this.velocity.y * deltaTime;
                } else {
                    this.state = 'FLYING';
                    this.velocity.y = 0;
                    this.position.y = targetAlt;
                }
            }

            handleFlying(deltaTime, allDrones) {
                if (this.behaviorAdaptation?.currentStrategy === 'BOUSTROPHEDON' && this.boustro) {
                    this.followBoustrophedon(deltaTime, allDrones);
                } else {
                    this.calculateFormationTarget();
                    // Apply pattern steering on top of formation
                    const pf = this.getPatternForce(allDrones);
                    this.targetPosition.add(pf.multiplyScalar(0.3));
                    const avoidanceForce = this.calculateIntelligentAvoidance(allDrones);

                    const targetDirection = this.targetPosition.clone().sub(this.position);
                    const distance = targetDirection.length();

                    if (distance > 0.5) {
                        targetDirection.normalize().multiplyScalar(Math.min(3.0, distance));
                        this.velocity.lerp(targetDirection, deltaTime * 2);
                    }

                    // Application des forces d'√©vitement intelligentes
                    this.velocity.add(avoidanceForce.multiplyScalar(deltaTime));
                    this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                }

                // Contraintes spatiales dans la zone
                this.position.x = Math.max(-CONFIG.zoneSize / 2 + 1, Math.min(CONFIG.zoneSize / 2 - 1, this.position.x));
                this.position.z = Math.max(-CONFIG.zoneSize / 2 + 1, Math.min(CONFIG.zoneSize / 2 - 1, this.position.z));
                this.position.y = Math.max(0.1, Math.min(15, this.position.y));

                // Marquer la cellule explor√©e (mapping)
                if (typeof explorationMap !== 'undefined' && explorationMap.length) {
                    const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                    const i = Math.floor((this.position.x + CONFIG.zoneSize / 2) / sectorSize);
                    const j = Math.floor((this.position.z + CONFIG.zoneSize / 2) / sectorSize);
                    if (explorationMap[i] && explorationMap[i][j] !== undefined) {
                        explorationMap[i][j] = 1;
                    }
                }

                // D√©tection simple de "d√©couverte" et diffusion au swarm
                if (typeof scoutingTargets !== 'undefined') {
                    for (const t of scoutingTargets) {
                        if (!t.discovered && this.position.distanceTo(t.position) < 2.5) {
                            t.discovered = true;
                            // Notification au swarm si disponible
                            if (typeof SWARM_MEMORY !== 'undefined' && SWARM_MEMORY && SWARM_MEMORY.messageQueue) {
                                SWARM_MEMORY.messageQueue.push({
                                    type: 'TARGET_DISCOVERED',
                                    senderId: this.id,
                                    position: t.position.clone(),
                                    timestamp: Date.now()
                                });
                            }
                        }
                    }
                }
            }

            // Victoire-like mode switch
            setMode(mode) {
                this.currentMode = mode;
                this.patternStep = 0;
                this.searchPattern = null;
                if (mode === 'boustrophedon') {
                    this.behaviorAdaptation.currentStrategy = 'BOUSTROPHEDON';
                    try { assignBoustrophedonLanes(); } catch (e) { }
                } else if (this.missionType === 'mapping') {
                    // Keep mapping strategy when user sets another pattern
                    this.behaviorAdaptation.currentStrategy = 'BOUSTROPHEDON';
                }
            }

            // Compute a small steering force by mode (subset of victoire behaviors)
            getPatternForce(allDrones) {
                const v = new THREE.Vector3(0, 0, 0);
                switch (this.currentMode) {
                    case 'grid': {
                        // Mild alignment to nearest grid point
                        const g = 4;
                        const gx = Math.round(this.position.x / g) * g;
                        const gz = Math.round(this.position.z / g) * g;
                        v.x += (gx - this.position.x) * 0.05;
                        v.z += (gz - this.position.z) * 0.05;
                        break;
                    }
                    case 'boustrophedon': {
                        if (this.boustro) {
                            const lateralError = this.boustro.xCenter - this.position.x;
                            v.x += THREE.MathUtils.clamp(lateralError, -1, 1) * 0.2;
                        }
                        break;
                    }
                    case 'spiral': {
                        const r = 6 + this.patternStep * 0.6;
                        const a = this.patternStep * 1.2;
                        const tx = Math.cos(a) * r;
                        const tz = Math.sin(a) * r;
                        v.x += (tx - this.position.x) * 0.05;
                        v.z += (tz - this.position.z) * 0.05;
                        this.patternStep += 0.01;
                        if (r > 25) this.patternStep = 0;
                        break;
                    }
                    case 'coverage': {
                        // Move towards least explored nearby grid cell
                        if (typeof explorationMap !== 'undefined' && explorationMap.length) {
                            const sector = CONFIG.zoneSize / CONFIG.explorationGrid;
                            let best = null;
                            for (let di = -1; di <= 1; di++) {
                                for (let dj = -1; dj <= 1; dj++) {
                                    const i = Math.floor((this.position.x + CONFIG.zoneSize / 2) / sector) + di;
                                    const j = Math.floor((this.position.z + CONFIG.zoneSize / 2) / sector) + dj;
                                    if (explorationMap[i]?.[j] === 0) {
                                        const wx = -CONFIG.zoneSize / 2 + (i + 0.5) * sector;
                                        const wz = -CONFIG.zoneSize / 2 + (j + 0.5) * sector;
                                        best = new THREE.Vector3(wx, 0, wz);
                                    }
                                }
                            }
                            if (best) v.add(best.sub(this.position).multiplyScalar(0.05));
                        }
                        break;
                    }
                    case 'follow_leader': {
                        const leader = allDrones?.find(d => d.teamRole === 'leader') || allDrones?.[0];
                        if (leader && leader !== this) {
                            const offset = new THREE.Vector3(2, 0, 2);
                            v.add(leader.position.clone().add(offset).sub(this.position).multiplyScalar(0.05));
                        }
                        break;
                    }
                    case 'random': {
                        v.x += (Math.random() - 0.5) * 0.2;
                        v.z += (Math.random() - 0.5) * 0.2;
                        break;
                    }
                }
                return v;
            }

            followBoustrophedon(deltaTime, allDrones) {
                const plan = this.boustro;
                if (!plan) return;

                // Corriger lat√©ralement vers le centre de la voie (axe X)
                const lateralError = plan.xCenter - this.position.x;
                const lateralCorr = THREE.MathUtils.clamp(lateralError, -2, 2);

                // Avancer sur Z entre zMin et zMax, inversion aux extr√©mit√©s
                const dir = plan.dir; // 1 -> +z, -1 -> -z
                const forward = new THREE.Vector3(0, 0, dir).multiplyScalar(plan.speed);

                if ((dir > 0 && this.position.z >= plan.zMax - plan.tolerance) ||
                    (dir < 0 && this.position.z <= plan.zMin + plan.tolerance)) {
                    plan.dir *= -1;
                    this.targetPosition.y = CONFIG.flightHeight + 0.2; // petite variation visuelle
                }

                const lateral = new THREE.Vector3(lateralCorr, 0, 0);
                const desired = forward.add(lateral);
                // Blend in small pattern steering so selected mode remains influential
                const pf = this.getPatternForce?.(allDrones) || new THREE.Vector3();
                desired.add(new THREE.Vector3(pf.x, 0, pf.z));
                this.velocity.lerp(desired, deltaTime * 1.5);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                // Maintenir l'altitude cible
                const altErr = CONFIG.flightHeight - this.position.y;
                this.position.y += THREE.MathUtils.clamp(altErr, -2, 2) * deltaTime;
            }

            handleLanding(deltaTime) {
                if (this.position.y > 0.2) {
                    this.velocity.y = this.state === 'EMERGENCY' ? -3.0 : -1.5;
                    this.position.y += this.velocity.y * deltaTime;

                    // R√©duction progressive des RPM
                    const landingRPM = Math.max(0, 800 * (this.position.y / 3.0));
                    this.motorRPM.fill(landingRPM);
                } else {
                    this.state = 'IDLE';
                    this.position.y = 0.1;
                    this.velocity.set(0, 0, 0);
                    this.motorRPM.fill(0);
                }
            }

            calculateIntelligentAvoidance(allDrones) {
                const avoidance = new THREE.Vector3();

                allDrones.forEach(other => {
                    if (other.id === this.id) return;

                    const distance = this.position.distanceTo(other.position);
                    const safetyDistance = CONFIG.safetyDistance +
                        (this.intelligence + other.intelligence) * 0.05; // Distance adaptative

                    if (distance < safetyDistance) {
                        const away = this.position.clone().sub(other.position).normalize();
                        const force = (safetyDistance - distance) / safetyDistance;
                        const intelligentForce = force * (5 + this.intelligence * 0.1);
                        avoidance.add(away.multiplyScalar(intelligentForce));
                    }
                });

                return avoidance;
            }

            calculateFormationTarget() {
                const formationSpacing = CONFIG.formationSpacing + this.intelligence * 0.1;

                switch (this.formationType) {
                    case 'line':
                        this.targetPosition.set(
                            (this.id - drones.length / 2) * formationSpacing,
                            CONFIG.flightHeight,
                            0
                        );
                        break;

                    case 'circle':
                        const angle = (this.id / drones.length) * Math.PI * 2;
                        const radius = 8 + this.intelligence * 0.2;
                        this.targetPosition.set(
                            Math.cos(angle) * radius,
                            CONFIG.flightHeight,
                            Math.sin(angle) * radius
                        );
                        break;

                    case 'triangle':
                        const triangleAngle = (this.id / 3) * (Math.PI * 2 / 3);
                        this.targetPosition.set(
                            Math.cos(triangleAngle) * 6,
                            CONFIG.flightHeight,
                            Math.sin(triangleAngle) * 6
                        );
                        break;

                    case 'grid':
                        const gridSize = Math.ceil(Math.sqrt(drones.length));
                        this.targetPosition.set(
                            (this.id % gridSize - gridSize / 2) * formationSpacing,
                            CONFIG.flightHeight,
                            (Math.floor(this.id / gridSize) - gridSize / 2) * formationSpacing
                        );
                        break;
                }
            }

            updateMotorRPM() {
                // Calcul RPM bas√© sur l'√©tat de vol et l'intelligence
                let baseRPM = 0;

                switch (this.state) {
                    case 'IDLE':
                        baseRPM = 0;
                        break;
                    case 'TAKEOFF':
                        baseRPM = CONFIG.maxRPM * 0.8;
                        break;
                    case 'FLYING':
                        const speed = this.velocity.length();
                        baseRPM = 1200 + speed * 200 + this.intelligence * 10;
                        break;
                    case 'LANDING':
                        baseRPM = 800;
                        break;
                    case 'EMERGENCY':
                        baseRPM = 400;
                        break;
                }

                // Application avec variations pour r√©alisme
                this.motorRPM = this.motorRPM.map((rpm, i) => {
                    const variation = Math.sin(Date.now() * 0.01 + i) * 50;
                    return Math.max(0, Math.min(CONFIG.maxRPM, baseRPM + variation));
                });
            }

            updateAdvancedVisuals(deltaTime) {
                if (!this.group) return;

                this.group.position.copy(this.position);

                // Rotation des h√©lices bas√©e sur RPM r√©els (rotation du pivot autour de Y)
                if (this.props && Array.isArray(this.props)) {
                    this.props.forEach((prop, i) => {
                        if (prop.pivot && this.motorRPM[i] !== undefined) {
                            const rotSpeed = (this.motorRPM[i] / CONFIG.maxRPM) * 30 * deltaTime;
                            prop.pivot.rotation.y += rotSpeed * prop.direction;
                            prop.rpm = this.motorRPM[i];
                        }
                    });
                }

                // Mise √† jour du label d'intelligence
                if (this.labelSprite) {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 160;
                    canvas.height = 40;

                    context.fillStyle = '#000000';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    context.fillStyle = '#00FFFF';
                    context.font = 'Bold 12px Arial';
                    context.textAlign = 'center';
                    context.fillText(this.name, canvas.width / 2, 15);
                    context.fillStyle = '#00FF88';
                    context.font = '10px Arial';
                    context.fillText(`I:${this.intelligence.toFixed(1)} E:${this.emergence.toFixed(0)}`, canvas.width / 2, 30);

                    // Protection contre les textures null
                    if (this.labelSprite.material.map) {
                        this.labelSprite.material.map.dispose();
                    }
                    this.labelSprite.material.map = new THREE.CanvasTexture(canvas);
                    this.labelSprite.material.needsUpdate = true;
                }

                // Mise √† jour de l'anneau d'√©mergence
                if (this.emergenceRing) {
                    const emergenceLevel = this.emergence / 100;
                    this.emergenceRing.material.color.setHSL(emergenceLevel * 0.3, 1, 0.5);
                    this.emergenceRing.material.opacity = 0.3 + emergenceLevel * 0.5;
                    this.emergenceRing.scale.set(1 + emergenceLevel * 0.5, 1 + emergenceLevel * 0.5, 1);
                }

                // Attitude r√©aliste: cap vers la vitesse, inclinaison et roulis subtils
                if (this.body) {
                    const v = this.velocity.clone();
                    const speed = v.length();
                    if (speed > 0.01) {
                        const targetYaw = Math.atan2(v.x, v.z);
                        const currentYaw = this.group.rotation.y || 0;
                        const yawDelta = ((targetYaw - currentYaw + Math.PI) % (2 * Math.PI)) - Math.PI;
                        this.group.rotation.y = currentYaw + yawDelta * Math.min(1, deltaTime * 2.5);

                        const targetPitch = -Math.min(0.35, speed * 0.08);
                        const baseRx = -Math.PI / 2;
                        const curPitchExtra = this.body.userData.pitchExtra || 0;
                        const newPitchExtra = THREE.MathUtils.lerp(curPitchExtra, targetPitch, deltaTime * 3.0);
                        this.body.userData.pitchExtra = newPitchExtra;
                        this.body.rotation.x = baseRx + newPitchExtra;

                        const targetRoll = THREE.MathUtils.clamp(-yawDelta * 0.5, -0.35, 0.35);
                        const curRoll = this.group.userData.roll || 0;
                        const newRoll = THREE.MathUtils.lerp(curRoll, targetRoll, deltaTime * 3.0);
                        this.group.userData.roll = newRoll;
                        this.group.rotation.z = newRoll;
                    } else {
                        this.group.rotation.z = THREE.MathUtils.lerp(this.group.rotation.z, 0, deltaTime * 1.5);
                        const baseRx = -Math.PI / 2;
                        const curPitchExtra = this.body.userData.pitchExtra || 0;
                        const newPitchExtra = THREE.MathUtils.lerp(curPitchExtra, 0, deltaTime * 1.5);
                        this.body.userData.pitchExtra = newPitchExtra;
                        this.body.rotation.x = baseRx + newPitchExtra;
                    }
                }
            }

            // M√©thodes de contr√¥le am√©lior√©es
            takeoff() {
                if (this.state !== 'FLYING') {
                    this.state = 'TAKEOFF';
                    this.targetPosition.y = CONFIG.flightHeight;
                    this.rosNode.logTopic(`Advanced takeoff initiated - target altitude: ${CONFIG.flightHeight}m`);
                }
            }

            land() {
                if (this.state === 'FLYING') {
                    this.state = 'LANDING';
                    this.targetPosition.y = 0.1;
                    this.rosNode.logTopic(`Intelligent landing sequence initiated`);
                }
            }

            emergencyLand() {
                this.state = 'EMERGENCY';
                this.targetPosition.y = 0.1;
                this.rosNode.logTopic(`üö® EMERGENCY LANDING! Intelligence: ${this.intelligence.toFixed(1)}`);
            }

            setFormation(type) {
                this.formationType = type;
                this.rosNode.logTopic(`Formation changed to: ${type} (Intelligence: ${this.intelligence.toFixed(1)})`);
            }

            setMission(type) {
                this.missionType = type;
                // Adapter comportement en fonction de la mission
                switch (type) {
                    case 'exploration':
                        this.setFormation('grid');
                        this.behaviorAdaptation.currentStrategy = 'EXPLORATION';
                        break;
                    case 'mapping':
                        this.setFormation('line');
                        this.behaviorAdaptation.currentStrategy = 'BOUSTROPHEDON';
                        // Lancer l'assignation des voies si possible
                        try { assignBoustrophedonLanes(); } catch (e) { }
                        break;
                    case 'surveillance':
                        this.setFormation('circle');
                        this.behaviorAdaptation.currentStrategy = 'PATROL';
                        break;
                    case 'formation_flight':
                        this.setFormation('triangle');
                        this.behaviorAdaptation.currentStrategy = 'FORMATION';
                        break;
                }
                this.rosNode.logTopic(`Mission updated: ${type} -> strategy ${this.behaviorAdaptation.currentStrategy}`);
            }

            handleVelocityCommand(msg) {
                if (this.state === 'FLYING') {
                    this.velocity.set(msg.linear.x, msg.linear.y, msg.linear.z);
                    this.rosNode.logTopic(`Velocity command received: ${JSON.stringify(msg.linear)}`);
                }
            }

            handleFormationCommand(msg) {
                this.setFormation(msg.formation_type);
                if (msg.position) {
                    this.targetPosition.set(msg.position.x, msg.position.y, msg.position.z);
                }
            }

            handleIntelligenceUpdate(msg) {
                // Traitement des mises √† jour d'intelligence collective
                if (msg.global_intelligence) {
                    this.intelligence = Math.max(this.intelligence, msg.global_intelligence * 0.1);
                }
            }

            destroy() {
                if (this.odometryInterval) {
                    clearInterval(this.odometryInterval);
                }
                if (this.group && scene) {
                    scene.remove(this.group);
                }
                this.rosNode.logTopic(`${this.name} destroyed`);
            }
        }
        // Initialisation de la sc√®ne avec for√™t r√©aliste
        function initScene() {
            console.log('üîß Initializing realistic forest scene...');

            scene = new THREE.Scene();

            // Ciel atmosph√©rique dynamique
            const skyGradient = new THREE.Color(0x87CEEB);
            scene.background = skyGradient;

            // Brouillard atmosph√©rique r√©aliste avec variation de densit√©
            const fogColor = 0xa8c8ec; // Bleu-gris atmosph√©rique
            scene.fog = new THREE.FogExp2(fogColor, 0.008); // FogExp2 pour un rendu plus naturel

            // Camera tactique
            camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 350) / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 45); // Position sur√©lev√©e pour vue tactique
            camera.lookAt(0, 0, 0); // Regarder vers le centre

            // Renderer
            const container = document.getElementById('canvas_container');
            if (!container) {
                throw new Error('Canvas container not found');
            }

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 350, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            container.appendChild(renderer.domElement);

            // ===== √âCLAIRAGE PLEIN JOUR R√âALISTE =====

            // Lumi√®re ambiante naturelle jour
            const dayAmbient = new THREE.AmbientLight(0xffffff, 0.6); // Lumi√®re blanche naturelle
            scene.add(dayAmbient);

            // Soleil principal - lumi√®re directionnelle forte
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 80, 30); // Position haute du soleil
            sunLight.target.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 150;
            sunLight.shadow.camera.left = -60;
            sunLight.shadow.camera.right = 60;
            sunLight.shadow.camera.top = 60;
            sunLight.shadow.camera.bottom = -60;
            scene.add(sunLight);
            scene.add(sunLight.target);

            // Lumi√®re diffuse du ciel
            const skyLight = new THREE.HemisphereLight(0x87ceeb, 0x98fb98, 0.4); // Ciel bleu, herbe verte
            scene.add(skyLight);

            // Quelques rayons de soleil ponctuels √† travers les arbres
            for (let i = 0; i < 4; i++) {
                const sunRay = new THREE.SpotLight(0xfffff0, 0.3, 25, Math.PI / 8, 0.2, 1);
                sunRay.position.set(
                    (Math.random() - 0.5) * CONFIG.zoneSize * 0.8,
                    20 + Math.random() * 15,
                    (Math.random() - 0.5) * CONFIG.zoneSize * 0.8
                );
                sunRay.target.position.set(sunRay.position.x, 0, sunRay.position.z);
                scene.add(sunRay);
                scene.add(sunRay.target);
            }

            // Lumi√®re d'appoint pour les drones
            const droneLight = new THREE.PointLight(0x00FFFF, 1, 100);
            droneLight.position.set(0, 30, 0);
            scene.add(droneLight);

            // ===== EFFETS ATMOSPH√âRIQUES R√âALISTES =====

            // Particules de poussi√®re/pollen dans l'air
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 200;
            const dustPositions = new Float32Array(dustCount * 3);

            for (let i = 0; i < dustCount * 3; i += 3) {
                dustPositions[i] = (Math.random() - 0.5) * CONFIG.zoneSize;
                dustPositions[i + 1] = Math.random() * 30 + 5;
                dustPositions[i + 2] = (Math.random() - 0.5) * CONFIG.zoneSize;
            }

            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.3,
                sizeAttenuation: true
            });

            const dustParticles = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dustParticles);

            // Animation des particules
            function animateDust() {
                const positions = dustParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    positions[i + 1] += Math.cos(Date.now() * 0.0008 + i) * 0.005;
                    positions[i + 2] += Math.sin(Date.now() * 0.0012 + i) * 0.008;

                    // R√©initialiser si trop haut
                    if (positions[i + 1] > 35) {
                        positions[i + 1] = 5;
                    }
                }
                dustParticles.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateDust);
            }
            animateDust();

            // ===== FOR√äT DENSE √âCLAIR√âE POUR SCOUTING =====
            createDenseForest();

            console.log('‚úÖ Realistic forest scene initialized');
            updateSystemStatus('‚úÖ Realistic forest ready');
        }

        // Variables globales pour l'environnement (d√©clarations supprim√©es - d√©j√† d√©finies en haut)
        // SAR/Boustrophedon planning
        let showSAR = true;
        let sarLaneLines = [];
        let boustrophedonPlan = new Map(); // droneId -> { xCenter, zMin, zMax, dir, speed }

        function initializeExplorationMap() {
            explorationMap = [];
            for (let i = 0; i < CONFIG.explorationGrid; i++) {
                explorationMap[i] = [];
                for (let j = 0; j < CONFIG.explorationGrid; j++) {
                    explorationMap[i][j] = 0;
                }
            }
            console.log(`üó∫Ô∏è Exploration map initialized: ${CONFIG.explorationGrid}x${CONFIG.explorationGrid}`);
        }

        function createDenseForest() {
            const environment = new THREE.Group();

            // Initialiser la carte d'exploration
            initializeExplorationMap();

            // Sol forestier r√©aliste avec mousse
            const groundGeometry = new THREE.PlaneGeometry(CONFIG.zoneSize * 2, CONFIG.zoneSize * 2, 128, 128);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                // Subtle rolling hills
                const x = vertices[i];
                const z = vertices[i + 1];
                const h = Math.sin(x * 0.01) * 1.2 + Math.cos(z * 0.008) * 1.0 + Math.sin(x * 0.05 + z * 0.03) * 0.3;
                vertices[i + 2] = h;
            }
            groundGeometry.computeVertexNormals();

            // Vertex colors based on height for subtle variation
            const colors = [];
            for (let i = 0; i < vertices.length; i += 3) {
                const y = vertices[i + 2];
                const x = vertices[i];
                const z = vertices[i + 1];
                const n = (Math.sin(x * 0.02) * Math.cos(z * 0.021) + 1) * 0.5; // simple noise
                const t = THREE.MathUtils.clamp((y + 2) / 6, 0, 1);
                // blend from earthy brown to lush green
                const base = new THREE.Color(0x5a4d3a); // earth
                const grass = new THREE.Color(0x3a6b2f); // grass
                const c = base.lerp(grass, 0.4 * n + 0.6 * t);
                colors.push(c.r, c.g, c.b);
            }
            groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const groundMaterial = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.95,
                metalness: 0.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            environment.add(ground);

            // Cr√©ation de la for√™t optimis√©e pour recherche
            const forestDensity = 30; // Nombre d'arbres r√©duit pour visibilit√©
            for (let i = 0; i < forestDensity; i++) {
                const tree = createRealisticTree();

                // Position al√©atoire dans la zone
                let validPosition = false;
                let attempts = 0;
                let x, z;

                while (!validPosition && attempts < 50) {
                    x = (Math.random() - 0.5) * CONFIG.zoneSize * 0.9;
                    z = (Math.random() - 0.5) * CONFIG.zoneSize * 0.9;

                    // V√©rifier la distance minimale entre arbres
                    validPosition = true;
                    for (let existingTree of trees) {
                        const dist = Math.sqrt(
                            Math.pow(x - existingTree.position.x, 2) +
                            Math.pow(z - existingTree.position.z, 2)
                        );
                        if (dist < 15) { // Distance minimale augment√©e pour plus d'espace
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    tree.position.set(x, 0, z);
                    trees.push({
                        mesh: tree,
                        position: new THREE.Vector3(x, 0, z),
                        radius: 4 + Math.random() * 2,
                        height: 12 + Math.random() * 8,
                        isExplored: false
                    });
                    forestObstacles.push({
                        position: new THREE.Vector3(x, 0, z),
                        radius: 4 + Math.random() * 2
                    });
                    environment.add(tree);
                }
            }

            // Points d'int√©r√™t cach√©s dans la for√™t (cibles de scouting)
            for (let i = 0; i < 15; i++) {
                const target = createScoutingTarget();
                let validPos = false;
                let attempts = 0;

                while (!validPos && attempts < 30) {
                    const x = (Math.random() - 0.5) * CONFIG.zoneSize * 0.8;
                    const z = (Math.random() - 0.5) * CONFIG.zoneSize * 0.8;

                    // V√©rifier qu'il n'y a pas d'arbre trop proche
                    validPos = true;
                    for (let tree of trees) {
                        const dist = Math.sqrt(
                            Math.pow(x - tree.position.x, 2) +
                            Math.pow(z - tree.position.z, 2)
                        );
                        if (dist < 6) {
                            validPos = false;
                            break;
                        }
                    }

                    if (validPos) {
                        target.position.set(x, 1, z);
                        scoutingTargets.push({
                            mesh: target,
                            position: new THREE.Vector3(x, 1, z),
                            discovered: false,
                            value: Math.random() * 100, // Valeur de la cible
                            type: i % 3 === 0 ? 'emergency' : i % 3 === 1 ? 'resource' : 'intel'
                        });
                        environment.add(target);
                    }
                    attempts++;
                }
            }

            // Grille de scouting optimis√©e
            createScoutingGrid();

            scene.add(environment);
            console.log(`üå≤ For√™t dense cr√©√©e: ${trees.length} arbres, ${scoutingTargets.length} cibles`);
        }

        function createRealisticTree() {
            const tree = new THREE.Group();

            // Tronc avec √©corce textur√©e
            const trunkHeight = 12 + Math.random() * 8;
            const trunkRadius = 0.8 + Math.random() * 0.6;
            const trunkGeometry = new THREE.CylinderGeometry(
                trunkRadius * 0.8, trunkRadius, trunkHeight, 8
            );
            const trunkMaterial = new THREE.MeshLambertMaterial({
                color: 0x4a3728
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            tree.add(trunk);

            // Feuillage simplifi√© et moins dense
            const foliageColors = [0x1e3a0a, 0x2d5016, 0x3a6b1c];
            for (let layer = 0; layer < 2; layer++) { // R√©duit de 4 √† 2 couches
                const radius = 3 + Math.random() * 2 - layer * 0.3; // Plus petit
                const foliageGeometry = new THREE.SphereGeometry(radius, 8, 6); // Moins de d√©tails
                const foliageMaterial = new THREE.MeshLambertMaterial({
                    color: foliageColors[layer % foliageColors.length],
                    transparent: true,
                    opacity: 0.6 + Math.random() * 0.2 // Plus transparent
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(
                    (Math.random() - 0.5) * 1.5, // Moins de variation
                    trunkHeight * 0.8 + layer * 1.5, // Plus haut
                    (Math.random() - 0.5) * 1.5
                );
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }

            return tree;
        }

        function createScoutingTarget() {
            const target = new THREE.Group();

            // Base lumineuse pour indiquer l'importance
            const baseGeometry = new THREE.CylinderGeometry(0.8, 1.2, 0.3, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0x331100,
                emissiveIntensity: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            target.add(base);

            // Antenne ou marqueur visible
            const markerGeometry = new THREE.ConeGeometry(0.3, 2, 6);
            const markerMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff88,
                emissive: 0x003322,
                emissiveIntensity: 0.5
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.5;
            target.add(marker);

            // Lumi√®re pour rendre visible aux drones
            const targetLight = new THREE.PointLight(0x00ff88, 0.8, 12);
            targetLight.position.y = 2;
            target.add(targetLight);

            return target;
        }

        function createScoutingGrid() {
            // Grille de secteurs pour scouting optimis√©
            const gridMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.15
            });

            const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
            for (let i = 0; i <= CONFIG.explorationGrid; i++) {
                const pos = (i - CONFIG.explorationGrid / 2) * sectorSize;

                // Lignes de scouting horizontales
                const hGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-CONFIG.zoneSize / 2, 2, pos),
                    new THREE.Vector3(CONFIG.zoneSize / 2, 2, pos)
                ]);
                scene.add(new THREE.Line(hGeometry, gridMaterial));

                // Lignes de scouting verticales  
                const vGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(pos, 2, -CONFIG.zoneSize / 2),
                    new THREE.Vector3(pos, 2, CONFIG.zoneSize / 2)
                ]);
                scene.add(new THREE.Line(vGeometry, gridMaterial));
            }
        }

        // ===== BOUSTROPH√âDON SAR PLANNER =====
        function assignBoustrophedonLanes() {
            if (!scene || drones.length === 0) return;

            // Clear previous plan and overlay
            clearSAROverlay();
            boustrophedonPlan.clear();

            const half = CONFIG.zoneSize / 2;
            // Lane width based on safety and spacing
            const laneWidth = Math.max(CONFIG.safetyDistance * 2.5, CONFIG.formationSpacing * 2, 6);
            let laneCount = Math.max(drones.length, Math.floor(CONFIG.zoneSize / laneWidth));
            if (laneCount < drones.length) laneCount = drones.length;

            // Recompute laneWidth to evenly cover the zone
            const effectiveLaneWidth = CONFIG.zoneSize / laneCount;

            // Assign one lane per drone; if more drones than lanes, share lanes round-robin
            for (let i = 0; i < drones.length; i++) {
                const laneIndex = i % laneCount;
                const xCenter = -half + effectiveLaneWidth * (laneIndex + 0.5);
                const dir = (laneIndex % 2 === 0) ? 1 : -1; // alternate directions per lane
                const zMin = -half + 1; // small margin
                const zMax = half - 1;
                const speed = 3.0; // m/s sweep speed
                boustrophedonPlan.set(drones[i].id, { xCenter, zMin, zMax, dir, speed });
                // Attach to drone for use in its controller
                drones[i].boustro = { xCenter, zMin, zMax, dir, speed, tolerance: 0.5 };
            }

            // Draw overlay
            if (showSAR) createSAROverlay();
            updateSystemStatus(`üß≠ SAR lanes assigned (${boustrophedonPlan.size})`);
        }

        function createSAROverlay() {
            clearSAROverlay();
            if (!scene) return;
            const half = CONFIG.zoneSize / 2;
            for (const drone of drones) {
                if (!drone.boustro) continue;
                const color = new THREE.Color().setHSL((drone.id % 12) / 12, 0.8, 0.5);
                const mat = new THREE.LineDashedMaterial({ color: color.getHex(), dashSize: 1, gapSize: 0.5 });
                const geom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(drone.boustro.xCenter, 0.2, -half),
                    new THREE.Vector3(drone.boustro.xCenter, 0.2, half)
                ]);
                const line = new THREE.Line(geom, mat);
                line.computeLineDistances();
                scene.add(line);
                sarLaneLines.push(line);
            }
        }

        function clearSAROverlay() {
            if (!scene) return;
            for (const line of sarLaneLines) {
                scene.remove(line);
            }
            sarLaneLines = [];
        }

        // Initialisation du loader Collada
        function initLoaders() {
            try {
                if (typeof THREE.ColladaLoader !== 'undefined') {
                    colladaLoader = new THREE.ColladaLoader();
                    console.log('‚úÖ ColladaLoader initialized');
                } else {
                    console.warn('‚ö†Ô∏è ColladaLoader not available, using fallback');
                    colladaLoader = null;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è ColladaLoader error:', error);
                colladaLoader = null;
            }
        }

        // Initialisation de la minimap
        function initMinimap() {
            minimapCanvas = document.getElementById('minimap_canvas');
            if (minimapCanvas) {
                minimapCtx = minimapCanvas.getContext('2d');
                console.log('‚úÖ Minimap initialized');
            }
        }

        // Mise √† jour de la minimap
        function updateMinimap() {
            if (!minimapCanvas || !minimapCtx || !minimapVisible) return;

            const width = minimapCanvas.width;
            const height = minimapCanvas.height;
            const scale = 4;
            const centerX = width / 2;
            const centerY = height / 2;

            // Fond style mission tactique
            const gradient = minimapCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) / 2);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            minimapCtx.fillStyle = gradient;
            minimapCtx.fillRect(0, 0, width, height);

            // Bordure de mission
            minimapCtx.strokeStyle = '#00ff88';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(2, 2, width - 4, height - 4);

            // Grille tactique
            minimapCtx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();

            for (let i = -25; i <= 25; i += 5) {
                const x = centerX + i * scale;
                const y = centerY + i * scale;
                minimapCtx.moveTo(x, 0);
                minimapCtx.lineTo(x, height);
                minimapCtx.moveTo(0, y);
                minimapCtx.lineTo(width, y);
            }
            minimapCtx.stroke();

            // Axes de r√©f√©rence
            minimapCtx.strokeStyle = '#00ff88';
            minimapCtx.lineWidth = 1;
            minimapCtx.setLineDash([5, 5]);
            minimapCtx.beginPath();
            minimapCtx.moveTo(centerX, 0);
            minimapCtx.lineTo(centerX, height);
            minimapCtx.moveTo(0, centerY);
            minimapCtx.lineTo(width, centerY);
            minimapCtx.stroke();
            minimapCtx.setLineDash([]);

            // Zone de mission (p√©rim√®tre de s√©curit√©)
            minimapCtx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            const missionRadius = (CONFIG.zoneSize / 2) * scale;
            minimapCtx.arc(centerX, centerY, missionRadius, 0, 2 * Math.PI);
            minimapCtx.stroke();

            // Couverture d'exploration avanc√©e avec gradient
            if (explorationMap && explorationMap.length) {
                const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                let totalCovered = 0;
                let totalSectors = 0;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        totalSectors++;
                        const coverage = explorationMap[i][j];
                        if (coverage > 0) {
                            totalCovered++;
                            const wx = -CONFIG.zoneSize / 2 + (i + 0.5) * sectorSize;
                            const wz = -CONFIG.zoneSize / 2 + (j + 0.5) * sectorSize;
                            const x = centerX + wx * scale;
                            const y = centerY - wz * scale;

                            // Gradient de couverture selon intensit√©
                            const intensity = Math.min(1, coverage);
                            minimapCtx.fillStyle = `rgba(0, 255, 136, ${0.2 + intensity * 0.4})`;
                            minimapCtx.fillRect(x - sectorSize * scale / 2, y - sectorSize * scale / 2,
                                sectorSize * scale, sectorSize * scale);

                            // Marqueur de zone bien explor√©e
                            if (intensity > 0.7) {
                                minimapCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                                minimapCtx.fillRect(x - 1, y - 1, 2, 2);
                            }
                        }
                    }
                }

                // Affichage du pourcentage de couverture
                const coveragePercent = (totalCovered / totalSectors * 100).toFixed(1);
                minimapCtx.fillStyle = '#00ff88';
                minimapCtx.font = 'bold 11px Arial';
                minimapCtx.textAlign = 'left';
                minimapCtx.fillText(`Coverage: ${coveragePercent}%`, 5, 15);
            }

            // Cibles de mission
            if (scoutingTargets) {
                scoutingTargets.forEach((target, idx) => {
                    const x = centerX + target.position.x * scale;
                    const y = centerY - target.position.z * scale;

                    if (target.discovered) {
                        // Cible d√©couverte
                        minimapCtx.fillStyle = '#00ff00';
                        minimapCtx.beginPath();
                        minimapCtx.arc(x, y, 3, 0, 2 * Math.PI);
                        minimapCtx.fill();
                        minimapCtx.strokeStyle = '#ffffff';
                        minimapCtx.lineWidth = 1;
                        minimapCtx.stroke();
                    } else {
                        // Cible non d√©couverte
                        minimapCtx.fillStyle = target.type === 'emergency' ? '#ff6b6b' :
                            target.type === 'resource' ? '#feca57' : '#48dbfb';
                        minimapCtx.beginPath();
                        minimapCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        minimapCtx.fill();

                        // Pulsation pour les cibles importantes
                        if (target.type === 'emergency') {
                            const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                            minimapCtx.strokeStyle = `rgba(255, 107, 107, ${pulse})`;
                            minimapCtx.lineWidth = 2;
                            minimapCtx.beginPath();
                            minimapCtx.arc(x, y, 4 + pulse * 2, 0, 2 * Math.PI);
                            minimapCtx.stroke();
                        }
                    }
                });
            }

            // Drones avec informations tactiques avanc√©es
            if (drones && drones.length > 0) {
                drones.forEach((drone) => {
                    const x = centerX + drone.position.x * scale;
                    const y = centerY - drone.position.z * scale;

                    // Couleur selon r√¥le et √©tat
                    let droneColor = '#00aa00'; // Par d√©faut vert
                    if (drone.state === 'EMERGENCY') {
                        droneColor = '#ff0000';
                    } else if (drone.typeName === 'LEADER' || drone.type?.role === 'coordination') {
                        droneColor = '#ffd700'; // Or pour les leaders
                    } else if (drone.typeName === 'SCOUT') {
                        droneColor = '#00ffff'; // Cyan pour les scouts
                    } else if (drone.typeName === 'HEAVY') {
                        droneColor = '#ff8800'; // Orange pour les lourds
                    } else if (drone.typeName === 'STEALTH') {
                        droneColor = '#8800ff'; // Violet pour les furtifs
                    }

                    // Trace de trajectoire r√©cente
                    if (drone.movementHistory && drone.movementHistory.length > 1) {
                        minimapCtx.strokeStyle = droneColor + '40'; // Transparence
                        minimapCtx.lineWidth = 1;
                        minimapCtx.beginPath();
                        const historyLength = Math.min(10, drone.movementHistory.length);
                        for (let i = drone.movementHistory.length - historyLength; i < drone.movementHistory.length - 1; i++) {
                            if (i >= 0) {
                                const pos1 = drone.movementHistory[i];
                                const pos2 = drone.movementHistory[i + 1];
                                const x1 = centerX + pos1.x * scale;
                                const y1 = centerY - pos1.z * scale;
                                const x2 = centerX + pos2.x * scale;
                                const y2 = centerY - pos2.z * scale;

                                if (i === drone.movementHistory.length - historyLength) {
                                    minimapCtx.moveTo(x1, y1);
                                }
                                minimapCtx.lineTo(x2, y2);
                            }
                        }
                        minimapCtx.stroke();
                    }

                    // Zone d'influence/d√©tection
                    if (drone.state === 'FLYING' && drone.intelligence > 0.5) {
                        const influenceRadius = (drone.intelligence * 3 + 2) * scale;
                        minimapCtx.strokeStyle = droneColor + '30';
                        minimapCtx.lineWidth = 1;
                        minimapCtx.beginPath();
                        minimapCtx.arc(x, y, influenceRadius, 0, 2 * Math.PI);
                        minimapCtx.stroke();
                    }

                    // Corps du drone
                    minimapCtx.fillStyle = droneColor;
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 4, 0, 2 * Math.PI);
                    minimapCtx.fill();

                    // Bordure selon √©tat
                    minimapCtx.strokeStyle = drone.state === 'EMERGENCY' ? '#ffffff' : '#000000';
                    minimapCtx.lineWidth = 1;
                    minimapCtx.stroke();

                    // Indicateur de direction (fl√®che)
                    if (drone.velocity && drone.velocity.length() > 0.1) {
                        const velNorm = drone.velocity.clone().normalize();
                        const arrowLength = 6;
                        minimapCtx.strokeStyle = '#ffffff';
                        minimapCtx.lineWidth = 2;
                        minimapCtx.beginPath();
                        minimapCtx.moveTo(x, y);
                        minimapCtx.lineTo(x + velNorm.x * arrowLength, y - velNorm.z * arrowLength);
                        minimapCtx.stroke();
                    }

                    // ID et information
                    minimapCtx.fillStyle = '#ffffff';
                    minimapCtx.font = 'bold 9px Arial';
                    minimapCtx.textAlign = 'center';
                    minimapCtx.fillText(drone.id.toString(), x, y + 2);

                    // Intelligence level (petit indicateur)
                    if (drone.intelligence > 0.3) {
                        const intelligenceSize = Math.max(1, drone.intelligence * 3);
                        minimapCtx.fillStyle = '#00ff88';
                        minimapCtx.fillRect(x - intelligenceSize / 2, y - 8, intelligenceSize, 1);
                    }
                });
            }

            // Informations de mission en bas
            minimapCtx.fillStyle = '#00ff88';
            minimapCtx.font = 'bold 10px Arial';
            minimapCtx.textAlign = 'left';
            const discovered = scoutingTargets ? scoutingTargets.filter(t => t.discovered).length : 0;
            const total = scoutingTargets ? scoutingTargets.length : 0;
            minimapCtx.fillText(`Targets: ${discovered}/${total}`, 5, height - 25);

            if (drones && drones.length > 0) {
                const avgIntel = drones.reduce((sum, d) => sum + (d.intelligence || 0), 0) / drones.length;
                minimapCtx.fillText(`Swarm Intel: ${(avgIntel * 100).toFixed(0)}%`, 5, height - 10);
            }
        }

        // Initialisation des drones
        async function initializeDrones() {
            console.log('üöÅ Initializing Gazebo Crazyflie swarm...');
            updateLoadingProgress(10);

            // D√©marrer avec fallback si mesh non disponibles
            let useFallback = !colladaLoader;
            if (useFallback) {
                console.log('‚ö†Ô∏è Utilisation fallback mesh (g√©om√©tries simples)');
                updateSystemStatus('‚ö†Ô∏è Mesh DAE non disponibles - utilisation fallback');
            }

            // Initialiser la m√©moire collective AVANT de cr√©er les drones
            if (!SWARM_MEMORY) {
                SWARM_MEMORY = new SwarmMemory();
                console.log('üß† SWARM_MEMORY initialis√©e AVANT cr√©ation drones');
            }

            // Cr√©ation de l'essaim avec types vari√©s (comme dans diamants-crazyflie-victoire)
            const droneTypes = ['SCOUT', 'HEAVY', 'STEALTH', 'LEADER', 'SCOUT', 'STEALTH'];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const position = new THREE.Vector3(
                    Math.cos(angle) * CONFIG.spawnRadius,
                    0.1,
                    Math.sin(angle) * CONFIG.spawnRadius
                );

                // Instancier le mod√®le Gazebo D√âTAILL√â avec vrais mesh Crazyflie
                const drone = new AdvancedDetailedCrazyflie(i, position);
                // Optionnel: m√©moriser un type s√©mantique pour l'UI
                drone.typeName = droneTypes[i % droneTypes.length];
                drones.push(drone);

                updateLoadingProgress(10 + (i + 1) * 15);
                await new Promise(resolve => setTimeout(resolve, 100)); // D√©lai r√©duit
            }

            updateDroneCount();

            // SWARM_MEMORY d√©j√† initialis√©e avant la cr√©ation des drones

            updateSystemStatus(`‚úÖ DIAMANTS swarm ready: ${drones.length} Crazyflie avec intelligence collective`);

            // Forcer la mise √† jour de la minimap apr√®s initialisation
            setTimeout(() => {
                if (minimapCanvas && minimapCtx) {
                    updateMinimap();
                }
            }, 500);

            hideLoadingScreen();
        }

        // Fonctions utilitaires
        function updateLoadingProgress(percent) {
            const progress = document.getElementById('loading_progress');
            if (progress) {
                progress.textContent = `${percent}%`;
            }
        }

        function hideLoadingScreen() {
            const loading = document.getElementById('loading_screen');
            if (loading) {
                loading.style.display = 'none';
            }
        }





        function updateDroneCount() {
            const droneCount = document.getElementById('drone_count');
            if (droneCount) {
                droneCount.textContent = drones.length;
            }

            // Mettre √† jour le s√©lecteur de drones
            updateDroneSelector();

            // Mettre √† jour les status des drones
            const statusList = document.getElementById('drone_status_list');
            if (statusList) {
                statusList.innerHTML = '';
                drones.forEach(drone => {
                    const statusDiv = document.createElement('div');
                    statusDiv.className = `drone_status ${drone.state === 'FLYING' ? '' : 'inactive'}`;
                    statusDiv.innerHTML = `
                        <span onclick="zoomToDrone(drones[${drone.id}])" style="cursor: pointer; color: #00FFFF;">
                            ${drone.name} (${drone.typeName || 'SCOUT'})
                        </span>
                        <span>${drone.state} ${Math.round(drone.battery)}%</span>
                    `;
                    statusList.appendChild(statusDiv);
                });
            }
        }

        function updateSystemStatus(message) {
            const status = document.getElementById('system_status');
            if (status) {
                status.textContent = message;
            }
            console.log(message);
        }

        // Fonctions de contr√¥le
        window.toggleSwarm = function () {
            if (drones.length === 0) return;

            const isFlying = drones.some(drone => drone.state === 'FLYING');

            if (isFlying) {
                drones.forEach(drone => {
                    if (drone.state === 'FLYING') drone.land();
                });
                updateSystemStatus('üõ¨ Landing Gazebo swarm...');
            } else {
                drones.forEach(drone => {
                    if (drone.state === 'IDLE') drone.takeoff();
                });
                updateSystemStatus('üöÅ Taking off Gazebo swarm...');
            }
        };

        window.changePattern = function (patternName) {
            // Nouveau syst√®me de patterns bas√© sur DIAMANTS-victoire
            if (patternName) {
                // Pattern sp√©cifique fourni
                const patternIndex = SEARCH_PATTERNS.indexOf(patternName);
                if (patternIndex !== -1) {
                    currentSearchPattern = patternIndex;
                }
            } else {
                // Cycle automatique
                currentSearchPattern = (currentSearchPattern + 1) % SEARCH_PATTERNS.length;
            }

            const newPattern = SEARCH_PATTERNS[currentSearchPattern];
            console.log('üåü Nouveau pattern de recherche:', newPattern);

            // Mettre √† jour l'affichage
            const patternDisplay = document.getElementById('currentPattern');
            if (patternDisplay) {
                patternDisplay.textContent = newPattern.charAt(0).toUpperCase() + newPattern.slice(1);
            }

            // Mettre √† jour aussi le s√©lecteur de mode
            const modeSelect = document.getElementById('mode_select');
            if (modeSelect) {
                modeSelect.value = newPattern;
            }

            // R√©initialise les donn√©es pour les patterns boustroph√©don
            if (newPattern === 'grid' || newPattern === 'boustrophedon' || newPattern === 'coverage') {
                drones.forEach(drone => {
                    // R√©initialisation du boustroph√©don
                    if (drone.boustrophedonData) {
                        drone.boustrophedonData.assigned = false;
                        drone.boustrophedonData.completed = false;
                        drone.boustrophedonData.progress = 0;
                    }

                    // Anciens syst√®mes
                    if (drone.explorationGrid) drone.explorationGrid = new Set();
                    drone.currentTarget = null;
                    drone.gridIndex = 0;
                    drone.patternStep = 0;
                    drone.searchPattern = null;
                    drone.lastSearchTime = 0;
                });

                // R√©initialiser la grille d'exploration
                if (explorationMap) {
                    explorationMap = Array(CONFIG.explorationGrid).fill().map(() => Array(CONFIG.explorationGrid).fill(0));
                }

                console.log('üîÑ Syst√®me boustroph√©don r√©initialis√© pour tous les drones');
            }

            // Appliquer le nouveau pattern √† tous les drones
            drones.forEach(drone => {
                if (drone.setFormation) {
                    drone.setFormation(newPattern);
                }
                // Nouveau champ pour le pattern de recherche
                drone.currentMode = newPattern;
            });

            updateSystemStatus(`üîÑ Pattern: ${newPattern}`);
        };

        window.addDrone = function () {
            if (drones.length >= CONFIG.maxDrones) return;

            const newId = drones.length;
            const angle = (newId / 8) * Math.PI * 2;
            const position = new THREE.Vector3(
                Math.cos(angle) * (CONFIG.spawnRadius + 2),
                0.1,
                Math.sin(angle) * (CONFIG.spawnRadius + 2)
            );

            // Choisir un type de drone al√©atoire
            const droneTypes = ['SCOUT', 'HEAVY', 'STEALTH', 'LEADER'];
            const randomType = droneTypes[Math.floor(Math.random() * droneTypes.length)];

            const newDrone = new AdvancedDetailedCrazyflie(newId, position);
            newDrone.typeName = randomType;
            drones.push(newDrone);

            updateDroneCount();
            updateDroneSelector();
            updateSystemStatus(`‚ûï DIAMANTS drone added: ${newDrone.name} (${randomType})`);
        };

        window.emergencyLand = function () {
            drones.forEach(drone => drone.emergencyLand());
            updateSystemStatus('üö® EMERGENCY LANDING ALL GAZEBO DRONES!');
        };

        window.resetSimulation = function () {
            drones.forEach(drone => drone.destroy());
            drones.length = 0;
            updateDroneCount();
            updateDroneSelector();
            updateSystemStatus('üîÑ Gazebo simulation reset');

            setTimeout(() => {
                initializeDrones();
            }, 500);
        };

        window.toggleMinimap = function () {
            const minimap = document.getElementById('minimap');
            if (minimap) {
                minimapVisible = !minimapVisible;
                minimap.style.display = minimapVisible ? 'block' : 'none';

                if (minimapVisible) {
                    updateMinimap();
                    updateSystemStatus('üìã Gazebo minimap activated');
                } else {
                    updateSystemStatus('üìã Minimap deactivated');
                }
            }
        };

        window.toggleSAROverlay = function () {
            showSAR = !showSAR;
            if (showSAR) {
                createSAROverlay();
                updateSystemStatus('üß≠ SAR lanes overlay ON');
            } else {
                clearSAROverlay();
                updateSystemStatus('üß≠ SAR lanes overlay OFF');
            }
        };

        window.launchMission = function () {
            const missionSelect = document.getElementById('mission_type');
            const type = missionSelect ? missionSelect.value : 'exploration';
            drones.forEach(d => {
                d.setMission?.(type);
                if (d.state === 'IDLE') {
                    d.takeoff();
                }
            });
            if (type === 'mapping') {
                // Assign SAR lanes for boustroph√©don coverage
                assignBoustrophedonLanes();
                showSAR = true;
                createSAROverlay();
            }
            updateSystemStatus(`üöÄ Mission launched: ${type} (auto takeoff)`);
        };

        window.resetSwarm = function () {
            window.resetSimulation();
        };

        window.toggleFormation = function () {
            const order = ['free', 'line', 'circle', 'triangle', 'grid'];
            const current = drones[0]?.formationType || 'free';
            const next = order[(order.indexOf(current) + 1) % order.length];
            window.changePattern(next);
        };

        // === CONTR√îLES DE CAM√âRA ===
        window.resetCamera = function () {
            if (!camera) return;
            camera.position.set(0, 12, 25);
            camera.lookAt(0, 2, 0);
            window.selectedDrone = null;
            window.followMode = false;
            updateSystemStatus('üìπ Camera reset to default view');
        };

        window.topView = function () {
            if (!camera) return;
            camera.position.set(0, 40, 0);
            camera.lookAt(0, 0, 0);
            window.selectedDrone = null;
            window.followMode = false;
            updateSystemStatus('üìπ Top view activated');
        };

        window.toggleFollowMode = function () {
            window.followMode = !window.followMode;
            if (!window.followMode) {
                window.selectedDrone = null;
                updateSystemStatus('üìπ Follow mode disabled');
            } else if (window.selectedDrone) {
                updateSystemStatus(`üìπ Following ${window.selectedDrone.name}`);
            } else {
                updateSystemStatus('üìπ Follow mode enabled - select a drone');
            }
        };

        window.zoomToSwarm = function () {
            if (!camera || drones.length === 0) return;

            // Calculer le centre et l'√©tendue de l'essaim
            let center = new THREE.Vector3(0, 0, 0);
            let maxDistance = 0;

            drones.forEach(drone => {
                center.add(drone.position);
            });
            center.divideScalar(drones.length);

            drones.forEach(drone => {
                const distance = drone.position.distanceTo(center);
                maxDistance = Math.max(maxDistance, distance);
            });

            const cameraDistance = Math.max(20, maxDistance * 2.5);
            camera.position.set(center.x, center.y + 15, center.z + cameraDistance);
            camera.lookAt(center);

            window.selectedDrone = null;
            window.followMode = false;
            updateSystemStatus(`üìπ Viewing swarm (${drones.length} drones)`);
        };

        window.selectDroneToFollow = function () {
            const selector = document.getElementById('drone_selector');
            if (!selector) return;

            const droneId = parseInt(selector.value);
            if (isNaN(droneId)) {
                window.selectedDrone = null;
                window.followMode = false;
                return;
            }

            const drone = drones.find(d => d.id === droneId);
            if (drone) {
                window.selectedDrone = drone;
                window.followMode = true;
                zoomToDrone(drone);
                updateSystemStatus(`üìπ Now following ${drone.name}`);
            }
        };

        window.setFormation = function (type) {
            window.changePattern(type);
        };

        window.applyMode = function () {
            const sel = document.getElementById('mode_select');
            const mode = sel ? sel.value : 'grid';
            window.setMode(mode);
        };

        window.setMode = function (mode) {
            // Utiliser le syst√®me de changePattern am√©lior√©
            window.changePattern(mode);
            updateSystemStatus(`üåü Mode set: ${mode}`);
        };

        window.updateSafetyDistance = function (val) {
            const v = Number(val);
            const label = document.getElementById('safety_distance_value');
            if (label) label.textContent = `${v.toFixed(1)}m`;
            if (positionCoordinator) positionCoordinator.setSafetyDistance(v);
        };
        // M√©triques
        function updateMetrics() {
            if (!drones || drones.length === 0) return;

            let totalIntelligence = 0;
            let totalPhi = 0;
            let totalSigma = 0;
            let totalEmergence = 0;

            drones.forEach(drone => {
                if (drone) {
                    totalIntelligence += drone.intelligence || 0;
                    totalPhi += drone.phi || 0;
                    totalSigma += drone.sigma || 0;
                    totalEmergence += drone.emergence || 0;
                }
            });

            const avgIntelligence = totalIntelligence / drones.length;
            const avgPhi = totalPhi / drones.length;
            const avgSigma = totalSigma / drones.length;
            const avgEmergence = totalEmergence / drones.length;

            updateMetricDisplay('intelligence', avgIntelligence);
            updateMetricDisplay('phi', avgPhi);
            updateMetricDisplay('sigma', avgSigma);
            updateMetricDisplay('emergence', avgEmergence);
        }

        function updateMetricDisplay(metric, value) {
            const valueElement = document.getElementById(`${metric}_value`);
            const barElement = document.getElementById(`${metric}_bar`);

            if (valueElement) {
                valueElement.textContent = value.toFixed(2);
            }

            if (barElement) {
                const percentage = Math.min(100, Math.max(0, value * 5));
                barElement.style.width = `${percentage}%`;
            }
        }

        // Contr√¥les cam√©ra
        function initCameraControls() {
            if (!renderer || !renderer.domElement) return;

            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let selectedDrone = null;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            window.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            window.addEventListener('mousemove', (event) => {
                if (!mouseDown || !camera) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                const distance = camera.position.length();
                const phi = Math.atan2(camera.position.z, camera.position.x) - deltaX * 0.01;
                const theta = Math.max(0.1, Math.min(Math.PI - 0.1,
                    Math.acos(camera.position.y / distance) + deltaY * 0.01));

                camera.position.x = distance * Math.sin(theta) * Math.cos(phi);
                camera.position.y = distance * Math.cos(theta);
                camera.position.z = distance * Math.sin(theta) * Math.sin(phi);
                camera.lookAt(0, 0, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                if (!camera) return;

                const distance = camera.position.length();
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                const newDistance = Math.max(0.5, Math.min(200, distance * zoomFactor));  // Zoom plus proche et plus loin
                camera.position.multiplyScalar(newDistance / distance);
            });

            // Click pour s√©lectionner un drone et zoomer dessus
            renderer.domElement.addEventListener('click', (event) => {
                if (!scene || !camera) return;
                const rect = renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x, y }, camera);
                const candidates = drones.map(d => d.group).filter(Boolean);
                const intersects = raycaster.intersectObjects(candidates, true);
                if (intersects.length > 0) {
                    let node = intersects[0].object;
                    let owningGroup = null;
                    while (node) {
                        if (candidates.includes(node)) { owningGroup = node; break; }
                        node = node.parent;
                    }
                    const drone = drones.find(d => d.group === owningGroup);
                    if (drone) {
                        selectedDrone = drone;
                        zoomToDrone(drone);
                    }
                }
            });

            // API publique
            window.zoomToDrone = zoomToDrone;
            window.followDrone = followDrone;
            window.selectedDrone = null;

            function zoomToDrone(drone) {
                if (!drone || !camera) return;
                window.selectedDrone = drone;
                const target = drone.position.clone();
                const offset = new THREE.Vector3(2, 1.5, 2);  // Plus proche pour mieux voir le Crazyflie
                camera.position.copy(target.clone().add(offset));
                camera.lookAt(target);
                console.log(`üéØ Zoom sur ${drone.name} (ID: ${drone.id})`);
            }

            function followDrone(drone) {
                if (!drone) return;
                window.selectedDrone = drone;
                window.followMode = true;
                console.log(`üìç Suivi activ√© pour ${drone.name} (ID: ${drone.id})`);
            }
        }

        // Gestion des √©v√©nements
        window.addEventListener('resize', () => {
            try {
                if (camera && renderer) {
                    camera.aspect = (window.innerWidth - 350) / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth - 350, window.innerHeight);
                }
            } catch (error) {
                console.error('Error during resize:', error);
            }
        });

        // Boucle d'animation
        let lastTime = 0;
        let frameCount = 0;
        let lastFPSUpdate = 0;

        function animate(currentTime = 0) {
            animationId = requestAnimationFrame(animate);

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Mise √† jour des drones (seulement s'ils existent)
            if (drones && drones.length > 0) {
                drones.forEach(drone => {
                    if (drone && typeof drone.update === 'function') {
                        drone.update(deltaTime, drones);
                    }
                });
            }

            // Suivi de cam√©ra automatique
            if (window.followMode && window.selectedDrone && camera) {
                const target = window.selectedDrone.position.clone();
                const currentDistance = camera.position.distanceTo(target);
                const idealDistance = 5;

                if (currentDistance > idealDistance * 1.5) {
                    // Rattraper doucement si trop loin
                    const direction = target.clone().sub(camera.position).normalize();
                    camera.position.add(direction.multiplyScalar(deltaTime * 2));
                } else {
                    // Suivi fluide √† distance constante
                    const offset = new THREE.Vector3(3, 2, 3);
                    const targetPos = target.clone().add(offset);
                    camera.position.lerp(targetPos, deltaTime * 2);
                }
                camera.lookAt(target);
            }

            // Mise √† jour des m√©triques
            if (currentTime - lastFPSUpdate > 500) {
                updateMetrics();

                if (minimapVisible) {
                    updateMinimap();
                }

                const fps = Math.round(frameCount * 2);
                const fpsDisplay = document.getElementById('fps_display');
                if (fpsDisplay) {
                    fpsDisplay.textContent = fps;
                }

                frameCount = 0;
                lastFPSUpdate = currentTime;
            }
            frameCount++;

            // Rendu
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Note: Removed legacy window 'load' initializer to avoid double init/dual canvases

        // Instantiate ROS-like systems
        positionCoordinator = new DronePositionCoordinator();
        diamantMetrics = new DiamantMetrics();
        swarmMemory = new SwarmMemory();

        // ===== FONCTIONS DE CONTR√îLE INTERFACE UTILISATEUR =====
        // Conserver une seule impl√©mentation (les versions duplicatives ont √©t√© retir√©es)

        // ===== MISE √Ä JOUR DES M√âTRIQUES INTERFACE =====

        function updateMetricsDisplay() {
            if (!drones || drones.length === 0) return;

            // Calcul des m√©triques DIAMANTS de base
            let totalIntelligence = 0;
            let totalEmergence = 0;
            let totalCohesion = 0;
            let totalCoordination = 0;

            // Nouvelles m√©triques d'IA avanc√©es
            let totalInnovationScore = 0;
            let totalExplorationEfficiency = 0;
            let totalCollaborationEffectiveness = 0;
            let totalLearningSpeed = 0;
            let totalAdaptabilityScore = 0;
            let totalReputationScore = 0;
            let avgTrustLevel = 0;
            let emergentBehaviors = new Set();
            let totalRiskAssessments = 0;

            drones.forEach(drone => {
                // M√©triques de base
                totalIntelligence += drone.intelligence || 0;
                totalEmergence += drone.emergence || 0;
                totalCohesion += drone.collaborationScore || 0;
                totalCoordination += drone.collectiveMetrics?.contributionScore || 0;

                // Nouvelles m√©triques d'IA
                if (drone.innovation) {
                    totalInnovationScore += drone.innovation.innovationScore || 0;
                }
                if (drone.performance) {
                    totalExplorationEfficiency += drone.performance.explorationEfficiency || 0;
                    totalCollaborationEffectiveness += drone.performance.collaborationEffectiveness || 0;
                    totalLearningSpeed += drone.performance.learningSpeed || 0;
                    totalAdaptabilityScore += drone.performance.adaptabilityScore || 0;
                }
                if (drone.communication) {
                    totalReputationScore += drone.communication.reputationScore || 0;
                    if (drone.communication.trustNetwork) {
                        let trustSum = 0;
                        let trustCount = 0;
                        drone.communication.trustNetwork.forEach(trust => {
                            trustSum += trust;
                            trustCount++;
                        });
                        if (trustCount > 0) avgTrustLevel += trustSum / trustCount;
                    }
                }
                if (drone.behaviorAdaptation?.emergentRoles) {
                    drone.behaviorAdaptation.emergentRoles.forEach(role => emergentBehaviors.add(role));
                }
                if (drone.sensors?.riskAssessment) {
                    totalRiskAssessments += drone.sensors.riskAssessment.size || 0;
                }
            });

            const droneCount = drones.length;

            // Calcul des m√©triques de mission et couverture
            let totalCovered = 0;
            let totalSectors = 0;
            let discoveredTargets = 0;
            let totalTargets = 0;

            // Calcul de la couverture d'exploration
            if (explorationMap && explorationMap.length) {
                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        totalSectors++;
                        if (explorationMap[i][j] > 0) {
                            totalCovered++;
                        }
                    }
                }
            }

            // Calcul des cibles d√©couvertes
            if (scoutingTargets) {
                totalTargets = scoutingTargets.length;
                discoveredTargets = scoutingTargets.filter(t => t.discovered).length;
            }

            const coveragePercent = totalSectors > 0 ? (totalCovered / totalSectors * 100) : 0;
            const targetProgress = totalTargets > 0 ? (discoveredTargets / totalTargets * 100) : 0;
            const missionEfficiency = (coveragePercent + targetProgress) / 2;

            // Mise √† jour de l'interface - m√©triques de base
            const elements = {
                'total_intelligence': totalIntelligence.toFixed(1),
                'emergence_level': totalEmergence.toFixed(1),
                'cohesion_index': totalCohesion.toFixed(1),
                'coordination_score': totalCoordination.toFixed(1)
            };

            // M√©triques de mission
            const missionElements = {
                'mission_coverage': coveragePercent.toFixed(1) + '%',
                'targets_discovered': `${discoveredTargets}/${totalTargets}`,
                'mission_efficiency': missionEfficiency.toFixed(1) + '%',
                'exploration_speed': ((totalCovered / Math.max(1, Date.now() - startTime)) * 60000).toFixed(2) + ' zones/min'
            };

            // Nouvelles m√©triques d'IA pour l'interface
            const advancedElements = {
                'innovation_index': (totalInnovationScore / droneCount).toFixed(3),
                'exploration_efficiency': (totalExplorationEfficiency / droneCount * 100).toFixed(1) + '%',
                'collaboration_effectiveness': (totalCollaborationEffectiveness / droneCount * 100).toFixed(1) + '%',
                'learning_velocity': (totalLearningSpeed / droneCount * 100).toFixed(1) + '%',
                'adaptability_score': (totalAdaptabilityScore / droneCount * 100).toFixed(1) + '%',
                'trust_network_health': (avgTrustLevel / droneCount * 100).toFixed(1) + '%',
                'emergent_behaviors_count': emergentBehaviors.size,
                'collective_reputation': (totalReputationScore / droneCount).toFixed(3),
                'active_risks': Math.round(totalRiskAssessments / droneCount)
            };

            // Mettre √† jour les √©l√©ments de base
            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            });

            // Mettre √† jour les m√©triques de mission
            Object.entries(missionElements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            });

            // Mettre √† jour les nouvelles m√©triques si les √©l√©ments existent
            Object.entries(advancedElements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            });

            // Mise √† jour des m√©triques SWARM_MEMORY avanc√©es
            if (SWARM_MEMORY) {
                const swarmIntelligence = SWARM_MEMORY.getSwarmIntelligenceLevel();
                const coherenceIndex = SWARM_MEMORY.getCoherenceIndex();
                const emergenceStrength = SWARM_MEMORY.getEmergenceStrength();

                const swarmElements = {
                    'swarm_intelligence_level': (swarmIntelligence * 100).toFixed(1) + '%',
                    'coherence_index': (coherenceIndex * 100).toFixed(1) + '%',
                    'emergence_strength': (emergenceStrength * 100).toFixed(1) + '%'
                };

                Object.entries(swarmElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Consensus et propositions actives
                if (SWARM_MEMORY.distributedConsensus) {
                    const activeProposals = SWARM_MEMORY.distributedConsensus.getActiveProposals();
                    const consensusHealth = SWARM_MEMORY.distributedConsensus.getConsensusHealth();

                    const consensusElements = {
                        'active_proposals': activeProposals.length,
                        'consensus_health': (consensusHealth * 100).toFixed(1) + '%'
                    };

                    Object.entries(consensusElements).forEach(([id, value]) => {
                        const element = document.getElementById(id);
                        if (element) element.textContent = value;
                    });
                }
            }

            // Barre d'√©mergence
            const emergeBar = document.getElementById('emergence_bar');
            if (emergeBar) {
                const avgEmergence = drones.length > 0 ? totalEmergence / drones.length : 0;
                emergeBar.style.width = `${Math.min(100, avgEmergence)}%`;
            }

            // Nouvelle barre de progression pour l'intelligence collective
            const intelligenceBar = document.getElementById('intelligence_progress_bar');
            if (intelligenceBar && SWARM_MEMORY) {
                const swarmIntelligence = SWARM_MEMORY.getSwarmIntelligenceLevel();
                intelligenceBar.style.width = `${Math.min(100, swarmIntelligence * 100)}%`;

                // Couleur dynamique bas√©e sur le niveau
                if (swarmIntelligence > 0.8) {
                    intelligenceBar.style.backgroundColor = '#00ff88';
                } else if (swarmIntelligence > 0.6) {
                    intelligenceBar.style.backgroundColor = '#ffaa00';
                } else if (swarmIntelligence > 0.4) {
                    intelligenceBar.style.backgroundColor = '#ff6600';
                } else {
                    intelligenceBar.style.backgroundColor = '#ff4444';
                }
            }

            // Affichage des comportements √©mergents
            const emergentBehaviorsElement = document.getElementById('emergent_behaviors_list');
            if (emergentBehaviorsElement) {
                emergentBehaviorsElement.innerHTML = Array.from(emergentBehaviors).map(behavior =>
                    `<span class="emergent-behavior-tag">${behavior}</span>`
                ).join(' ') || '<em>Aucun comportement √©mergent d√©tect√©</em>';
            }

            // Logging p√©riodique pour d√©bogage
            if (Math.random() < 0.01) { // 1% de chance
                console.log('ü§ñ M√©triques IA globales:', {
                    intelligence: (totalIntelligence / droneCount).toFixed(2),
                    innovation: (totalInnovationScore / droneCount).toFixed(3),
                    adaptation: (totalAdaptabilityScore / droneCount).toFixed(3),
                    comportements√âmergents: emergentBehaviors.size,
                    sant√©Consensus: SWARM_MEMORY?.distributedConsensus?.getConsensusHealth() || 0
                });
            }
        }

        // Mise √† jour p√©riodique des m√©triques
        setInterval(updateMetricsDisplay, 200);

        // Mise √† jour du s√©lecteur de drones
        function updateDroneSelector() {
            const selector = document.getElementById('drone_selector');
            if (!selector) return;

            // Sauver la s√©lection actuelle
            const currentValue = selector.value;

            // Vider le s√©lecteur
            selector.innerHTML = '<option value="">No Selection</option>';

            // Ajouter chaque drone
            drones.forEach(drone => {
                const option = document.createElement('option');
                option.value = drone.id;
                option.textContent = `${drone.name} (${drone.typeName || drone.type?.role || 'SCOUT'})`;
                selector.appendChild(option);
            });

            // Restaurer la s√©lection si le drone existe encore
            if (currentValue && drones.find(d => d.id == currentValue)) {
                selector.value = currentValue;
            }
        }

        swarmMemory = new SwarmMemory();
        // Alias global simple
        window.SWARM_MEMORY = swarmMemory;
        window.rosSystem = rosSystem;
        window.positionCoordinator = positionCoordinator;
        window.diamantMetrics = diamantMetrics;
        window.swarmMemory = swarmMemory;

        // === INITIALISATION AUTOMATIQUE ===
        document.addEventListener('DOMContentLoaded', function () {
            try {
                // === CODE ANTI-SPLIT RADICAL ===
                console.log('üõ°Ô∏è Activation protection anti-split...');

                // Forcer les styles body/html
                document.documentElement.style.width = '100vw';
                document.documentElement.style.height = '100vh';
                document.documentElement.style.margin = '0';
                document.documentElement.style.padding = '0';
                document.documentElement.style.overflow = 'hidden';
                document.documentElement.style.position = 'fixed';

                document.body.style.width = '100vw';
                document.body.style.height = '100vh';
                document.body.style.margin = '0';
                document.body.style.padding = '0';
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.top = '0';
                document.body.style.left = '0';

                // D√©sactiver le zoom et les gestes syst√®me
                document.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) e.preventDefault(); // Emp√™cher Ctrl+Scroll zoom
                }, { passive: false });

                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && (e.key === '=' || e.key === '-' || e.key === '0')) {
                        e.preventDefault(); // Emp√™cher Ctrl+Plus/Moins/0
                    }
                    if (e.key === 'F11') {
                        e.preventDefault(); // Emp√™cher F11
                    }
                });

                console.log('‚úÖ Protection anti-split activ√©e');

                // Forcer le focus sur cette fen√™tre
                if (window.focus) window.focus();

                // Note: D√©sactiv√© le redimensionnement automatique pour √©viter les probl√®mes de split
                // Le CSS fixed positioning g√®re d√©j√† le layout correctement

                // Initialiser la sc√®ne 3D
                initScene();

                // Initialiser les loaders
                initLoaders();

                // Initialiser le mapping et l'exploration
                initializeExplorationMap();
                createScoutingTargets();

                // Initialiser la minimap
                initMinimap();

                // Forcer l'affichage de la minimap
                const minimap = document.getElementById('minimap');
                if (minimap) {
                    minimap.style.display = 'block';
                    minimapVisible = true;
                }

                // Initialiser les contr√¥les de cam√©ra
                initCameraControls();

                // Lancer la boucle d'animation
                animate();

                // Initialiser les drones apr√®s un d√©lai
                setTimeout(() => {
                    initializeDrones();
                }, 1000);

                console.log('‚úÖ DIAMANTS V3 simulation initialized successfully');
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation:', error);
                updateSystemStatus('‚ùå Erreur d\'initialisation');
            }
        });
    </script>
</body>

</html>