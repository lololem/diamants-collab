<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIAMANTS Crazyflie Swarm - Effet Wahoo</title>
    <link rel="icon" href="data:,">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000011;
            color: #00FFFF;
        }

        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00FFFF;
            z-index: 100;
            font-size: 12px;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
        }

        .btn {
            padding: 10px 15px;
            margin: 5px;
            background: #0099FF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn:hover {
            background: #00CCFF;
            box-shadow: 0 0 10px #00CCFF;
        }

        #formula {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 50, 100, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #00FFFF;
            font-size: 14px;
            font-weight: bold;
            color: #00FFFF;
        }

        .metric {
            display: inline-block;
            margin: 5px 0;
            padding: 3px 8px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
        }

        .value {
            color: #00FF88;
            font-weight: bold;
        }

        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 330px;
            height: 200px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00FFFF;
            border-radius: 10px;
            z-index: 100;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FFAA00, #00FF88);
            border-radius: 5px;
            width: 0%;
            transition: width 0.5s ease;
        }
    </style>
</head>

<body>
    <div id="ui">
        <!-- M√©triques DIAMANTS classiques -->
        <div>üöÅ <span class="metric">Drones: <span class="value" id="droneCount">0</span></span></div>
        <div>‚ö° <span class="metric">I(t): <span class="value" id="intelligence">0.00</span></span></div>
        <div>üßÆ <span class="metric">œÜ (Attraction): <span class="value" id="phi">0.00</span></span></div>
        <div>üî• <span class="metric">œÉ (R√©pulsion): <span class="value" id="sigma">0.00</span></span></div>
        <div>üìê <span class="metric">|‚àá|: <span class="value" id="gradient">0.00</span></span></div>

        <!-- M√©triques Intelligence Collective -->
        <div>üåä <span class="metric">√âmergence: <span class="value" id="emergence">0.00</span></span></div>
        <div>ü§ù <span class="metric">Coh√©sion: <span class="value" id="cohesion">0.00</span></span></div>
        <div>üß† <span class="metric">Phase: <span class="value" id="phase">INIT</span></span></div>
        <div>üéì <span class="metric">Experts: <span class="value" id="expertise">0/0</span></span></div>
        <div>üì° <span class="metric">Communication: <span class="value" id="communication">0.0</span></span></div>
        <div>üó≥Ô∏è <span class="metric">Consensus: <span class="value" id="consensus">0</span></span></div>
        <div>üêú <span class="metric">Stigmergie: <span class="value" id="stigmergy">0</span></span></div>
        <div>üîÑ <span class="metric">Adaptation: <span class="value" id="adaptation">0%</span></span></div>

        <!-- Couverture et efficacit√© -->
        <div>üéØ <span class="metric">Zone couverte: <span class="value" id="coverage">0%</span></span></div>
        <div class="progress-bar">
            <div class="progress-fill" id="coverageProgress"></div>
        </div>
        <div>‚è±Ô∏è <span class="metric">Temps optimal: <span class="value" id="efficiency">0.0s</span></span></div>
        <div>üåü <span class="metric">Pattern: <span class="value" id="currentPattern">grid</span></span></div>
    </div>

    <div id="controls">
        <button class="btn" onclick="toggleSwarm()">üöÄ START WAHOO</button>
        <button class="btn" onclick="addDrone()">‚ûï Drone</button>
        <button class="btn" onclick="resetSwarm()">üîÑ Reset</button>
        <button class="btn" onclick="changePattern()">üåü Pattern</button>
        <button class="btn" onclick="toggleMinimap()">üó∫Ô∏è Map</button>
    </div>

    <canvas id="minimap"></canvas>

    <div id="formula">
        I(t) = ‚à¨|‚àá(œÜ+œÉ)|dŒ© - DIAMANTS Swarm Intelligence<br>
        <small>WASD: D√©placement | Souris: Rotation | Molette: Zoom</small>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // V√©rification que Three.js est charg√©
        if (typeof THREE === 'undefined') {
            console.error('‚ùå THREE.js non charg√©! V√©rifiez votre connexion internet.');
            document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 50px;">‚ùå Erreur: THREE.js non charg√©!<br>V√©rifiez votre connexion internet.</h1>';
        } else {
            console.log('‚úÖ THREE.js charg√©, version:', THREE.REVISION);
        }

        // === SYST√àME D'INTELLIGENCE COLLECTIVE DIAMANTS ===

        // M√©moire collective partag√©e - singleton global
        const SWARM_MEMORY = {
            // Carte de stigmergie num√©rique
            stigmergyMap: new Map(),

            // Historique des d√©couvertes collectives
            sharedDiscoveries: new Map(),

            // Zones d'expertise par drone
            expertiseZones: new Map(),

            // Consensus dynamique
            consensusVotes: new Map(),

            // M√©triques d'intelligence d'essaim
            swarmIntelligence: {
                totalI_t: 0,
                emergenceLevel: 0,
                cohesionIndex: 0,
                explorationEfficiency: 0,
                collectivePhaseState: 'INITIALIZATION'
            },

            // Communication temps r√©el
            messageQueue: [],
            broadcastRadius: 50,

            // Adaptation collective
            adaptationHistory: [],
            learningRate: 0.1,

            // √âtats √©mergents d√©tect√©s
            emergentBehaviors: new Set(),

            // M√©triques temps r√©el
            lastUpdate: Date.now(),
            updateFrequency: 100, // ms

            // === M√âTHODES DE M√âMOIRE COLLECTIVE ===

            // Ajouter trace de stigmergie
            addStigmergyTrace(position, droneId, traceType, intensity = 1.0) {
                const key = `${Math.round(position.x / 2)}_${Math.round(position.z / 2)}`;

                if (!this.stigmergyMap.has(key)) {
                    this.stigmergyMap.set(key, {
                        position: position.clone(),
                        traces: new Map(),
                        lastUpdate: Date.now(),
                        intensity: 0
                    });
                }

                const cell = this.stigmergyMap.get(key);
                const traceKey = `${droneId}_${traceType}`;

                cell.traces.set(traceKey, {
                    droneId,
                    traceType,
                    intensity,
                    timestamp: Date.now(),
                    decay: 0.95 // D√©croissance temporelle
                });

                cell.intensity = Math.min(1.0, cell.intensity + intensity * 0.1);
                cell.lastUpdate = Date.now();
            },

            // Lire traces de stigmergie dans une zone
            readStigmergyTraces(position, radius = 5) {
                const traces = [];
                const now = Date.now();

                this.stigmergyMap.forEach((cell, key) => {
                    const distance = position.distanceTo(cell.position);
                    if (distance <= radius) {
                        cell.traces.forEach((trace, traceKey) => {
                            // Calcul intensit√© avec d√©croissance temporelle
                            const age = (now - trace.timestamp) / 1000; // secondes
                            const decayedIntensity = trace.intensity * Math.pow(trace.decay, age);

                            if (decayedIntensity > 0.01) {
                                traces.push({
                                    ...trace,
                                    position: cell.position,
                                    distance,
                                    currentIntensity: decayedIntensity
                                });
                            }
                        });
                    }
                });

                return traces;
            },

            // Alias pour getStigmergyTraces
            getStigmergyTraces(position, radius = 5) {
                return this.readStigmergyTraces(position, radius);
            },

            // Diffusion de d√©couverte
            broadcastDiscovery(discovery, originDrone) {
                const message = {
                    type: 'DISCOVERY',
                    content: discovery,
                    originId: originDrone.id,
                    timestamp: Date.now(),
                    position: originDrone.position.clone(),
                    priority: discovery.value || 1.0,
                    broadcastRadius: this.broadcastRadius
                };

                this.messageQueue.push(message);
                this.sharedDiscoveries.set(discovery.id || Date.now(), discovery);

                // Mise √† jour des m√©triques collectives
                this.swarmIntelligence.totalI_t += discovery.value * 0.1;

                console.log(`üîä BROADCAST: Drone ${originDrone.id} partage d√©couverte ${discovery.type}`);
            },

            // Vote de consensus distribu√©
            submitConsensusVote(droneId, topic, vote, confidence = 1.0) {
                if (!this.consensusVotes.has(topic)) {
                    this.consensusVotes.set(topic, {
                        votes: new Map(),
                        startTime: Date.now(),
                        deadline: Date.now() + 5000, // 5 secondes pour voter
                        status: 'ACTIVE'
                    });
                }

                const consensus = this.consensusVotes.get(topic);
                consensus.votes.set(droneId, { vote, confidence, timestamp: Date.now() });

                return this.evaluateConsensus(topic);
            },

            // √âvaluation du consensus
            evaluateConsensus(topic) {
                const consensus = this.consensusVotes.get(topic);
                if (!consensus || Date.now() > consensus.deadline) {
                    if (consensus) consensus.status = 'EXPIRED';
                    return null;
                }

                const votes = Array.from(consensus.votes.values());
                if (votes.length === 0) return null;

                // Calcul consensus pond√©r√© par confiance
                const voteCount = new Map();
                let totalWeight = 0;

                votes.forEach(({ vote, confidence }) => {
                    const weight = confidence;
                    voteCount.set(vote, (voteCount.get(vote) || 0) + weight);
                    totalWeight += weight;
                });

                // Trouver vote majoritaire
                let winningVote = null;
                let maxWeight = 0;

                voteCount.forEach((weight, vote) => {
                    if (weight > maxWeight) {
                        maxWeight = weight;
                        winningVote = vote;
                    }
                });

                // Consensus atteint si >60% accord
                const consensusStrength = maxWeight / totalWeight;
                if (consensusStrength > 0.6) {
                    consensus.status = 'REACHED';
                    consensus.result = { vote: winningVote, strength: consensusStrength };

                    console.log(`‚úÖ CONSENSUS atteint sur "${topic}": ${winningVote} (${(consensusStrength * 100).toFixed(1)}%)`);
                    return consensus.result;
                }

                return null;
            },

            // Calcul intelligence d'essaim
            calculateSwarmIntelligence(allDrones) {
                const now = Date.now();
                if (now - this.lastUpdate < this.updateFrequency) return this.swarmIntelligence;

                let totalI_t = 0;
                let totalEmergence = 0;
                let avgCohesion = 0;
                let explorationCoverage = 0;

                // Agr√©gation des m√©triques individuelles
                allDrones.forEach(drone => {
                    totalI_t += drone.intelligence || 0;
                    totalEmergence += drone.emergence || 0;
                    avgCohesion += drone.collaborationScore || 0;
                });

                const droneCount = allDrones.length;
                if (droneCount > 0) {
                    avgCohesion /= droneCount;
                    totalEmergence /= droneCount;
                }

                // FORCE DES VALEURS MINIMALES POUR L'ACTIVIT√â VISIBLE
                if (totalEmergence === 0 && droneCount > 0) {
                    // Si aucune √©mergence d√©tect√©e, forcer une valeur bas√©e sur l'intelligence
                    totalEmergence = Math.min(1.0, totalI_t / droneCount * 0.1 + Math.random() * 0.3);
                }

                if (avgCohesion === 0 && droneCount > 0) {
                    // Si aucune coh√©sion, forcer une valeur bas√©e sur la proximit√©
                    let totalProximity = 0;
                    allDrones.forEach(drone => {
                        let nearbyCount = 0;
                        allDrones.forEach(other => {
                            if (other.id !== drone.id && drone.position.distanceTo(other.position) < 30) {
                                nearbyCount++;
                            }
                        });
                        totalProximity += nearbyCount / (droneCount - 1);
                    });
                    avgCohesion = totalProximity / droneCount;
                }

                // Calcul couverture exploration
                if (typeof explorationMap !== 'undefined') {
                    let coveredCells = 0;
                    let totalCells = 0;
                    for (let i = 0; i < CONFIG.explorationGrid; i++) {
                        for (let j = 0; j < CONFIG.explorationGrid; j++) {
                            totalCells++;
                            if (explorationMap[i][j] > 0.3) coveredCells++;
                        }
                    }
                    explorationCoverage = totalCells > 0 ? coveredCells / totalCells : 0;
                }

                // D√©tection phases √©mergentes
                let phaseState = 'DISPERSION'; // Par d√©faut au lieu de INITIALIZATION
                if (explorationCoverage < 0.1) phaseState = 'DISPERSION';
                else if (explorationCoverage < 0.4) phaseState = 'EXPLORATION';
                else if (explorationCoverage < 0.8) phaseState = 'CONSOLIDATION';
                else phaseState = 'COMPLETION';

                // Debug p√©riodique
                if (Math.random() < 0.02) { // 2% de chance de debug
                    console.log('üîç SWARM_MEMORY Debug:', {
                        totalEmergence,
                        avgCohesion,
                        explorationCoverage,
                        phaseState,
                        droneEmergences: allDrones.map(d => d.emergence),
                        droneCollaborations: allDrones.map(d => d.collaborationScore)
                    });
                }

                // D√©tection comportements √©mergents
                this.detectEmergentBehaviors(allDrones);

                // Mise √† jour m√©triques
                this.swarmIntelligence = {
                    totalI_t,
                    emergenceLevel: totalEmergence,
                    cohesionIndex: avgCohesion,
                    explorationEfficiency: explorationCoverage,
                    collectivePhaseState: phaseState,
                    swarmSize: droneCount,
                    emergentBehaviorCount: this.emergentBehaviors.size,
                    adaptationLevel: this.calculateAdaptationLevel()
                };

                this.lastUpdate = now;
                return this.swarmIntelligence;
            },

            // D√©tection comportements √©mergents
            detectEmergentBehaviors(allDrones) {
                // Formation spontan√©e de groupes
                const clusters = this.detectClusters(allDrones);
                if (clusters.length > 1 && clusters.some(c => c.size > 3)) {
                    this.emergentBehaviors.add('CLUSTER_FORMATION');
                }

                // Comportement de leader √©mergent
                const leaderCandidate = this.detectEmergentLeader(allDrones);
                if (leaderCandidate) {
                    this.emergentBehaviors.add('EMERGENT_LEADERSHIP');
                }

                // Sp√©cialisation de r√¥les
                if (this.detectRoleSpecialization(allDrones)) {
                    this.emergentBehaviors.add('ROLE_SPECIALIZATION');
                }

                // Synchronisation spontan√©e
                if (this.detectSynchronization(allDrones)) {
                    this.emergentBehaviors.add('SPONTANEOUS_SYNC');
                }
            },

            detectClusters(allDrones) {
                const clusters = [];
                const processed = new Set();
                const clusterRadius = 15;

                allDrones.forEach(drone => {
                    if (processed.has(drone.id)) return;

                    const cluster = new Set([drone.id]);
                    processed.add(drone.id);

                    allDrones.forEach(other => {
                        if (!processed.has(other.id) &&
                            drone.position.distanceTo(other.position) < clusterRadius) {
                            cluster.add(other.id);
                            processed.add(other.id);
                        }
                    });

                    clusters.push(cluster);
                });

                return clusters;
            },

            detectEmergentLeader(allDrones) {
                let bestLeader = null;
                let maxLeadershipScore = 0;

                allDrones.forEach(drone => {
                    const leadershipScore = (drone.intelligence || 0) * 0.4 +
                        (drone.scoutingEfficiency || 0) * 0.3 +
                        (drone.collaborationScore || 0) * 0.3;

                    if (leadershipScore > maxLeadershipScore) {
                        maxLeadershipScore = leadershipScore;
                        bestLeader = drone;
                    }
                });

                return maxLeadershipScore > 0.7 ? bestLeader : null;
            },

            detectRoleSpecialization(allDrones) {
                const roles = new Map();
                allDrones.forEach(drone => {
                    const role = drone.type?.role || 'unknown';
                    roles.set(role, (roles.get(role) || 0) + 1);
                });

                return roles.size > 1;
            },

            detectSynchronization(allDrones) {
                if (allDrones.length < 3) return false;

                const velocities = allDrones.map(d => d.velocity.clone().normalize());
                let avgDirection = new THREE.Vector3();

                velocities.forEach(v => avgDirection.add(v));
                avgDirection.normalize();

                let alignmentSum = 0;
                velocities.forEach(v => {
                    alignmentSum += Math.max(0, v.dot(avgDirection));
                });

                const alignmentScore = alignmentSum / velocities.length;
                return alignmentScore > 0.8;
            },

            calculateAdaptationLevel() {
                const recentAdaptations = this.adaptationHistory.filter(
                    adapt => Date.now() - adapt.timestamp < 30000 // 30 secondes
                );

                return Math.min(1.0, recentAdaptations.length * 0.1);
            },

            // Nettoyage p√©riodique
            cleanup() {
                const now = Date.now();
                const maxAge = 60000; // 1 minute

                // Nettoyer stigmergie ancienne
                this.stigmergyMap.forEach((cell, key) => {
                    if (now - cell.lastUpdate > maxAge) {
                        this.stigmergyMap.delete(key);
                    }
                });

                // Nettoyer messages anciens
                this.messageQueue = this.messageQueue.filter(
                    msg => now - msg.timestamp < 10000 // 10 secondes
                );

                // Nettoyer consensus expir√©s
                this.consensusVotes.forEach((consensus, topic) => {
                    if (consensus.status === 'EXPIRED' || now > consensus.deadline + 5000) {
                        this.consensusVotes.delete(topic);
                    }
                });
            }
        };

        // Auto-nettoyage p√©riodique
        setInterval(() => SWARM_MEMORY.cleanup(), 30000);

        // ===== CONFIGURATION OPTIMIS√âE TEMPS OPTIMAL =====
        const CONFIG = {
            maxDrones: Infinity,     // ILLIMIT√â ! Intelligence adaptive
            zoneSize: 120,
            explorationGrid: 20, // Augment√© pour pr√©cision optimale
            swarmCohesion: 1.5,      // R√©duit pour plus d'ind√©pendance
            swarmSeparation: 5.0,    // Forte s√©paration pour √©viter redondance 
            swarmAlignment: 0.8,     // Minimal pour autonomie maximale
            swarmRadius: 45,         // Rayon agrandi pour coordination globale
            magneticForce: 1.2,      // R√©duit pour √©viter clustering
            autonomyPower: 4.5,      // Autonomie maximale pour exploration
            searchSpeed: 3.2,        // Vitesse optimis√©e pour couverture rapide
            redundancyRadius: 15,    // Zone anti-redondance
            sectorAssignment: true,  // Assignment de secteurs actif
            adaptivePhases: true,    // Phases adaptatives activ√©es
            completionThreshold: 0.95 // Seuil de completion pour changement de phase
        };

        // Types de drones optimis√©s pour scouting collaboratif niveau troncs
        const DRONE_TYPES = {
            SCOUT: {
                name: "Scout Collaboratif",
                size: 0.6,
                speed: 8, // Vitesse r√©duite pour scouting pr√©cis
                color: 0x00FF88,
                role: "exploration",
                sensorRange: 15, // Port√©e adapt√©e au niveau troncs
                agility: 2.0
            },
            HEAVY: {
                name: "Porteur Lourd",
                size: 1.0,
                speed: 6, // Plus lent pour transport pr√©cis
                color: 0xFF6600,
                role: "transport",
                sensorRange: 12,
                agility: 0.8
            },
            STEALTH: {
                name: "Furtif",
                size: 0.4,
                speed: 10, // Rapide mais contr√¥l√©
                color: 0x4444FF,
                role: "reconnaissance",
                sensorRange: 20, // Bonne port√©e pour reconnaissance
                agility: 2.2
            },
            LEADER: {
                name: "Coordinateur",
                size: 0.8,
                speed: 7, // Vitesse mod√©r√©e pour coordination
                color: 0xFF0088,
                role: "coordination",
                sensorRange: 25, // Grande port√©e pour coordination
                agility: 1.5
            }
        };

        const SEARCH_PATTERNS = ['grid', 'boustrophedon', 'spiral', 'coverage', 'follow_leader', 'random'];
        let currentSearchPattern = 0;
        let isRunning = false;
        let startTime = Date.now();
        let showMinimap = true;

        // ===== SCENE SETUP WAHOO =====
        let scene, camera, renderer;
        try {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);
            scene.fog = new THREE.Fog(0x001122, 80, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 25); // Position plus basse pour voir l'action des drones au sol
            camera.lookAt(0, 2, 0); // Regarder vers le niveau des drones

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            console.log('‚úÖ Scene Three.js initialis√©e avec succ√®s');
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'initialisation de Three.js:', error);
            document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 50px;">‚ùå Erreur Three.js: ' + error.message + '</h1>';
            throw error;
        }

        // ===== √âCLAIRAGE R√âALISTE =====
        const ambientLight = new THREE.AmbientLight(0x334466, 0.4);
        scene.add(ambientLight);

        // Lumi√®re principale (lune)
        const moonLight = new THREE.DirectionalLight(0x9999FF, 0.8);
        moonLight.position.set(50, 100, 30);
        moonLight.castShadow = true;
        moonLight.shadow.camera.left = -100;
        moonLight.shadow.camera.right = 100;
        moonLight.shadow.camera.top = 100;
        moonLight.shadow.camera.bottom = -100;
        moonLight.shadow.mapSize.width = 1024;
        moonLight.shadow.mapSize.height = 1024;
        scene.add(moonLight);

        // Lumi√®re d'appoint pour les drones
        const droneLight = new THREE.PointLight(0x00FFFF, 1, 100);
        droneLight.position.set(0, 30, 0);
        scene.add(droneLight);

        // ===== FOR√äT DENSE √âCLAIR√âE POUR SCOUTING =====
        let trees = [];
        let forestObstacles = [];
        let scoutingTargets = [];

        function createDenseForest() {
            const environment = new THREE.Group();

            // Sol forestier r√©aliste avec mousse
            const groundGeometry = new THREE.PlaneGeometry(CONFIG.zoneSize * 2, CONFIG.zoneSize * 2, 64, 64);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.02) * 2 + Math.cos(vertices[i + 1] * 0.015) * 1.5;
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshLambertMaterial({
                color: 0x2d5016, // Vert for√™t fonc√©
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            environment.add(ground);

            // Cr√©ation de la for√™t optimis√©e pour recherche
            const forestDensity = 30; // Nombre d'arbres r√©duit pour visibilit√©
            for (let i = 0; i < forestDensity; i++) {
                const tree = createRealisticTree();

                // Position al√©atoire dans la zone
                let validPosition = false;
                let attempts = 0;
                let x, z;

                while (!validPosition && attempts < 50) {
                    x = (Math.random() - 0.5) * CONFIG.zoneSize * 0.9;
                    z = (Math.random() - 0.5) * CONFIG.zoneSize * 0.9;

                    // V√©rifier la distance minimale entre arbres
                    validPosition = true;
                    for (let existingTree of trees) {
                        const dist = Math.sqrt(
                            Math.pow(x - existingTree.position.x, 2) +
                            Math.pow(z - existingTree.position.z, 2)
                        );
                        if (dist < 15) { // Distance minimale augment√©e pour plus d'espace
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    tree.position.set(x, 0, z);
                    trees.push({
                        mesh: tree,
                        position: new THREE.Vector3(x, 0, z),
                        radius: 4 + Math.random() * 2,
                        height: 12 + Math.random() * 8,
                        isExplored: false
                    });
                    forestObstacles.push({
                        position: new THREE.Vector3(x, 0, z),
                        radius: 4 + Math.random() * 2
                    });
                    environment.add(tree);
                }
            }

            // Points d'int√©r√™t cach√©s dans la for√™t (cibles de scouting)
            for (let i = 0; i < 15; i++) {
                const target = createScoutingTarget();
                let validPos = false;
                let attempts = 0;

                while (!validPos && attempts < 30) {
                    const x = (Math.random() - 0.5) * CONFIG.zoneSize * 0.8;
                    const z = (Math.random() - 0.5) * CONFIG.zoneSize * 0.8;

                    // V√©rifier qu'il n'y a pas d'arbre trop proche
                    validPos = true;
                    for (let tree of trees) {
                        const dist = Math.sqrt(
                            Math.pow(x - tree.position.x, 2) +
                            Math.pow(z - tree.position.z, 2)
                        );
                        if (dist < 6) {
                            validPos = false;
                            break;
                        }
                    }

                    if (validPos) {
                        target.position.set(x, 1, z);
                        scoutingTargets.push({
                            mesh: target,
                            position: new THREE.Vector3(x, 1, z),
                            discovered: false,
                            value: Math.random() * 100, // Valeur de la cible
                            type: i % 3 === 0 ? 'emergency' : i % 3 === 1 ? 'resource' : 'intel'
                        });
                        environment.add(target);
                    }
                    attempts++;
                }
            }

            // √âclairage forestier atmosph√©rique
            createForestLighting();

            // Grille de scouting optimis√©e
            createScoutingGrid();

            scene.add(environment);
        }

        function createRealisticTree() {
            const tree = new THREE.Group();

            // Tronc avec √©corce textur√©e
            const trunkHeight = 12 + Math.random() * 8;
            const trunkRadius = 0.8 + Math.random() * 0.6;
            const trunkGeometry = new THREE.CylinderGeometry(
                trunkRadius * 0.8, trunkRadius, trunkHeight, 8
            );
            const trunkMaterial = new THREE.MeshLambertMaterial({
                color: 0x4a3728
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            tree.add(trunk);

            // Feuillage simplifi√© et moins dense
            const foliageColors = [0x1e3a0a, 0x2d5016, 0x3a6b1c];
            for (let layer = 0; layer < 2; layer++) { // R√©duit de 4 √† 2 couches
                const radius = 3 + Math.random() * 2 - layer * 0.3; // Plus petit
                const foliageGeometry = new THREE.SphereGeometry(radius, 8, 6); // Moins de d√©tails
                const foliageMaterial = new THREE.MeshLambertMaterial({
                    color: foliageColors[layer % foliageColors.length],
                    transparent: true,
                    opacity: 0.6 + Math.random() * 0.2 // Plus transparent
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(
                    (Math.random() - 0.5) * 1.5, // Moins de variation
                    trunkHeight * 0.8 + layer * 1.5, // Plus haut
                    (Math.random() - 0.5) * 1.5
                );
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }

            return tree;
        }

        function createScoutingTarget() {
            const target = new THREE.Group();

            // Base lumineuse pour indiquer l'importance
            const baseGeometry = new THREE.CylinderGeometry(0.8, 1.2, 0.3, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0x331100,
                emissiveIntensity: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            target.add(base);

            // Antenne ou marqueur visible
            const markerGeometry = new THREE.ConeGeometry(0.3, 2, 6);
            const markerMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff88,
                emissive: 0x003322,
                emissiveIntensity: 0.5
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.5;
            target.add(marker);

            // Lumi√®re pour rendre visible aux drones
            const targetLight = new THREE.PointLight(0x00ff88, 0.8, 12);
            targetLight.position.y = 2;
            target.add(targetLight);

            return target;
        }

        function createForestLighting() {
            // √âCLAIRAGE PLEIN JOUR R√âALISTE

            // Lumi√®re ambiante naturelle jour
            const dayAmbient = new THREE.AmbientLight(0xffffff, 0.6); // Lumi√®re blanche naturelle
            scene.add(dayAmbient);

            // Soleil principal - lumi√®re directionnelle forte
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 80, 30); // Position haute du soleil
            sunLight.target.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 150;
            sunLight.shadow.camera.left = -60;
            sunLight.shadow.camera.right = 60;
            sunLight.shadow.camera.top = 60;
            sunLight.shadow.camera.bottom = -60;
            scene.add(sunLight);
            scene.add(sunLight.target);

            // Lumi√®re diffuse du ciel
            const skyLight = new THREE.HemisphereLight(0x87ceeb, 0x98fb98, 0.4); // Ciel bleu, herbe verte
            scene.add(skyLight);

            // Quelques rayons de soleil ponctuels √† travers les arbres
            for (let i = 0; i < 4; i++) {
                const sunRay = new THREE.SpotLight(0xfffff0, 0.3, 25, Math.PI / 8, 0.2, 1);
                sunRay.position.set(
                    (Math.random() - 0.5) * CONFIG.zoneSize * 0.8,
                    20 + Math.random() * 15,
                    (Math.random() - 0.5) * CONFIG.zoneSize * 0.8
                );
                sunRay.target.position.set(sunRay.position.x, 0, sunRay.position.z);
                scene.add(sunRay);
                scene.add(sunRay.target);
            }
        }

        function createScoutingGrid() {
            // Grille de secteurs pour scouting optimis√©
            const gridMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.15
            });

            const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
            for (let i = 0; i <= CONFIG.explorationGrid; i++) {
                const pos = (i - CONFIG.explorationGrid / 2) * sectorSize;

                // Lignes de scouting horizontales
                const hGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-CONFIG.zoneSize / 2, 2, pos),
                    new THREE.Vector3(CONFIG.zoneSize / 2, 2, pos)
                ]);
                scene.add(new THREE.Line(hGeometry, gridMaterial));

                // Lignes de scouting verticales  
                const vGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(pos, 2, -CONFIG.zoneSize / 2),
                    new THREE.Vector3(pos, 2, CONFIG.zoneSize / 2)
                ]);
                scene.add(new THREE.Line(vGeometry, gridMaterial));
            }
        }

        console.log('üå≤ Cr√©ation de la for√™t dense...');
        try {
            createDenseForest();
            console.log('‚úÖ For√™t cr√©√©e avec succ√®s, nombre d\'arbres:', trees.length);
        } catch (error) {
            console.error('‚ùå Erreur lors de la cr√©ation de la for√™t:', error);
        }

        // ===== CRAZYFLIE DIAMANTS WAHOO =====
        class CrazyflieWahoo {
            constructor(id, x, z, type = null) {
                this.id = id;

                // Si type est null ou string, r√©cup√©rer depuis DRONE_TYPES
                if (!type || typeof type === 'string') {
                    const typeName = type || 'SCOUT';
                    this.type = DRONE_TYPES[typeName];
                    this.typeName = typeName;
                } else {
                    // Si type est d√©j√† un objet, l'utiliser directement
                    this.type = type;
                    this.typeName = Object.keys(DRONE_TYPES).find(key => DRONE_TYPES[key] === type) || 'SCOUT';
                }

                this.position = new THREE.Vector3(x, 8, z); // Position initiale scouting
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.phi = 0;           // Potentiel attractif DIAMANTS (coh√©sion scouting)
                this.sigma = 0;         // Potentiel r√©pulsif DIAMANTS (exploration/√©vitement)
                this.gradient = new THREE.Vector3(); // ‚àá(œÜ+œÉ) - Gradient DIAMANTS
                this.intelligence = 0;  // I(t) = |‚àá(œÜ+œÉ)| - M√©triques d'intelligence
                this.emergence = 0;     // Amplification non-lin√©aire

                // Propri√©t√©s de scouting collaboratif
                this.scoutingPriority = Math.random(); // Priorit√© de zone [0-1]
                this.scoutingEfficiency = 0; // Efficacit√© accumulative
                this.lastDiscoveryTime = 0; // Derni√®re d√©couverte
                this.collaborationScore = 0; // Score de collaboration
                this.sigma = 0;         // Potentiel r√©pulsif DIAMANTS
                this.gradient = new THREE.Vector3(0, 0, 0);
                this.intelligence = 0;   // I(t) = |‚àá(œÜ+œÉ)|
                this.explorationTarget = null;
                this.searchPattern = null;
                this.patternStep = 0;
                this.wahooFactor = Math.random() * 2 + 1;
                this.trailPoints = [];
                this.lastSearchTime = 0;

                // Flag pour emp√™cher toute t√©l√©portation
                this.allowTeleportation = false;
                this.emergencyResetCount = 0;

                // === SYST√àME BOUSTROPH√âDON SAR (espacement 18m) ===
                this.boustrophedonData = {
                    assigned: false,
                    row: 0,
                    direction: 1, // 1 = droite, -1 = gauche (alternance)
                    progress: 0,
                    sectorWidth: 18, // Espacement SAR standard : 18m
                    sectorHeight: 18, // M√™me espacement pour quadrillage r√©gulier
                    currentWaypoint: null,
                    completed: false
                };

                // === INTELLIGENCE COLLECTIVE AVANC√âE ===

                // Communication et m√©moire collective
                this.communicationRange = 30; // Port√©e de communication directe
                this.messageBuffer = []; // Buffer des messages re√ßus
                this.lastBroadcast = 0; // Derni√®re diffusion
                this.broadcastInterval = 1000; // Intervalle de diffusion (ms) - r√©duit pour plus d'activit√©

                // Expertise et sp√©cialisation √©mergente  
                this.expertiseLevel = 0; // Niveau d'expertise d√©velopp√© [0-1]
                this.specialization = null; // Sp√©cialisation √©mergente
                this.teachingAbility = 0; // Capacit√© √† enseigner aux autres
                this.learningRate = 0.1; // Vitesse d'apprentissage
                this.expertiseAreas = new Map(); // Map des domaines d'expertise et niveaux

                // Consensus et vote distribu√©
                this.votingHistory = new Map(); // Historique des votes
                this.consensusWeight = 1.0; // Poids dans les consensus
                this.leadershipPotential = Math.random(); // Potentiel de leadership
                this.appliedConsensus = new Set(); // Consensus d√©j√† appliqu√©s

                // Adaptation et plasticit√© comportementale
                this.behaviorAdaptation = {
                    currentStrategy: 'EXPLORATION',
                    adaptationScore: 0,
                    strategyHistory: [],
                    flexibilityIndex: Math.random() * 0.5 + 0.5
                };

                // M√©moire √©pisodique individuelle
                this.episodicMemory = {
                    discoveries: [],
                    interactions: [],
                    successfulStrategies: new Map(),
                    failurePatterns: new Set(),
                    expertiseExchanges: [], // Historique des √©changes d'expertise
                    expertiseAreas: new Set(), // Domaines d'expertise du drone
                    expertise: 0, // Niveau d'expertise global
                    collaborationScore: 0 // Score de collaboration avec l'essaim
                };

                // Stigmergie personnelle
                this.personalStigmergie = {
                    traceIntensity: 1.0,
                    traceDecay: 0.95,
                    readSensitivity: 0.8,
                    lastTraceTime: 0
                };

                // M√©triques d'intelligence collective
                this.collectiveMetrics = {
                    contributionScore: 0, // Contribution √† l'intelligence de l'essaim
                    syncLevel: 0, // Niveau de synchronisation avec l'essaim
                    emergenceParticipation: 0, // Participation aux comportements √©mergents
                    knowledgeSharing: 0, // Score de partage de connaissances
                    efficiency: 0, // Efficacit√© du drone
                    learningInteractions: 0 // Nombre d'interactions d'apprentissage
                };

                // Priorit√©s d'exploration dynamiques
                this.explorationPriorities = {
                    targets: 1.0,
                    unexplored: 0.8,
                    coordination: 0.6,
                    cleanup: 0.4
                };

                this.createMesh();
                this.createTrail();

                // Initialisation intelligence collective
                this.initializeCollectiveIntelligence();
            }

            // === M√âTHODES D'INTELLIGENCE COLLECTIVE ===

            initializeCollectiveIntelligence() {
                // ACTIVATION FORC√âE DE L'INTELLIGENCE COLLECTIVE

                // Identifier le domaine d'expertise initial
                const initialDomain = this.identifyCurrentActivity();

                // Forcer l'expertise initiale
                this.specialization = initialDomain;
                this.expertiseLevel = 2.0 + Math.random() * 2.0; // Expertise imm√©diate
                this.episodicMemory.expertise = this.expertiseLevel;
                this.episodicMemory.expertiseAreas.add(initialDomain);
                this.episodicMemory.collaborationScore = 1.0 + Math.random(); // Collaboration active

                // D√©velopper l'expertise et capacit√© d'enseignement
                this.teachingAbility = this.expertiseLevel * 0.3;
                this.expertiseAreas.set(initialDomain, this.expertiseLevel);

                // Force l'√©mergence et la collaboration
                this.emergence = this.expertiseLevel * 0.5;
                this.collaborationScore = this.episodicMemory.collaborationScore;

                // Enregistrer dans la m√©moire collective
                SWARM_MEMORY.expertiseZones.set(this.id, {
                    droneId: this.id,
                    position: this.position.clone(),
                    specialization: this.specialization,
                    expertiseLevel: this.expertiseLevel,
                    lastUpdate: Date.now()
                });

                // Voter pour la strat√©gie initiale
                this.submitConsensusVote('INITIAL_STRATEGY', this.behaviorAdaptation.currentStrategy, 0.8);

                console.log(`üß† Drone ${this.id} initialis√© avec intelligence collective ACTIVE - Expertise: ${initialDomain} (${this.expertiseLevel.toFixed(2)})`);
            }

            // Communication temps r√©el avec l'essaim
            broadcastToSwarm(messageType, content, priority = 1.0) {
                const now = Date.now();
                if (now - this.lastBroadcast < this.broadcastInterval * (1 / priority)) return;

                const message = {
                    type: messageType,
                    content,
                    senderId: this.id,
                    timestamp: now,
                    position: this.position.clone(),
                    priority,
                    range: this.communicationRange
                };

                // Ajouter √† la file de messages globale
                SWARM_MEMORY.messageQueue.push(message);
                this.lastBroadcast = now;

                // Trace de stigmergie pour la communication
                SWARM_MEMORY.addStigmergyTrace(
                    this.position,
                    this.id,
                    `COMM_${messageType}`,
                    priority * 0.5
                );

                console.log(`üì° Drone ${this.id} diffuse: ${messageType}`);
            }

            // R√©ception et traitement des messages
            receiveSwarmMessages(allDrones) {
                const myPos = this.position;

                // Traiter les messages dans la port√©e
                SWARM_MEMORY.messageQueue.forEach(message => {
                    if (message.senderId === this.id) return; // Ignorer ses propres messages

                    const distance = myPos.distanceTo(message.position);
                    if (distance <= message.range) {
                        this.processMessage(message, allDrones);
                    }
                });

                // Nettoyer les messages trait√©s
                this.messageBuffer = this.messageBuffer.filter(
                    msg => Date.now() - msg.timestamp < 5000 // Garder 5 secondes
                );
            }

            // Traitement des messages re√ßus
            processMessage(message, allDrones) {
                const alreadyReceived = this.messageBuffer.some(
                    m => m.senderId === message.senderId &&
                        m.type === message.type &&
                        m.timestamp === message.timestamp
                );

                if (alreadyReceived) return;

                this.messageBuffer.push(message);

                switch (message.type) {
                    case 'DISCOVERY':
                        this.handleDiscoveryMessage(message);
                        break;
                    case 'STRATEGY_CHANGE':
                        this.handleStrategyMessage(message);
                        break;
                    case 'EXPERTISE_OFFER':
                        this.handleExpertiseMessage(message);
                        break;
                    case 'COORDINATION_REQUEST':
                        this.handleCoordinationMessage(message, allDrones);
                        break;
                    case 'EMERGENCY':
                        this.handleEmergencyMessage(message, allDrones);
                        break;
                }

                // Mise √† jour m√©triques de communication
                this.collectiveMetrics.knowledgeSharing += message.priority * 0.1;
            }

            // Gestion des messages de d√©couverte
            handleDiscoveryMessage(message) {
                const discovery = message.content;

                // Ajouter √† la m√©moire √©pisodique
                this.episodicMemory.discoveries.push({
                    ...discovery,
                    source: message.senderId,
                    timestamp: message.timestamp,
                    distance: this.position.distanceTo(message.position)
                });

                // Adapter strat√©gie si d√©couverte importante
                if (discovery.value > 50) {
                    this.adaptBehaviorToDiscovery(discovery);
                }

                console.log(`üì• Drone ${this.id} a re√ßu info d√©couverte de ${message.senderId}`);
            }

            // Adaptation comportementale bas√©e sur les d√©couvertes
            adaptBehaviorToDiscovery(discovery) {
                const distance = this.position.distanceTo(discovery.position);

                if (distance < 20 && !this.isInRange(discovery.position, 5)) {
                    // Si d√©couverte proche mais pas encore explor√©e par moi
                    this.behaviorAdaptation.currentStrategy = 'INVESTIGATE';
                    this.explorationTarget = discovery.position.clone();

                    // Enregistrer adaptation
                    SWARM_MEMORY.adaptationHistory.push({
                        droneId: this.id,
                        type: 'DISCOVERY_ADAPTATION',
                        timestamp: Date.now(),
                        trigger: discovery.type
                    });
                }
            }

            // === M√âTHODES DE GESTION DES MESSAGES MANQUANTES ===

            // Gestion des messages de strat√©gie
            handleStrategyMessage(message) {
                const strategy = message.content;

                // √âvaluer la pertinence de la strat√©gie propos√©e
                const relevanceScore = this.evaluateStrategyRelevance(strategy);

                if (relevanceScore > 0.6) {
                    // Adopter la nouvelle strat√©gie
                    this.behaviorAdaptation.currentStrategy = strategy.type;
                    this.strategyHistory.push({
                        strategy: strategy.type,
                        source: message.senderId,
                        timestamp: message.timestamp,
                        confidence: relevanceScore
                    });

                    console.log(`üîÑ Drone ${this.id} adopte strat√©gie ${strategy.type} de ${message.senderId}`);
                }
            }

            // Gestion des messages d'expertise
            handleExpertiseMessage(message) {
                const expertise = message.content;

                // V√©rifier si cette expertise nous int√©resse
                if (this.needsExpertise(expertise.domain)) {
                    // Apprendre de l'expertise partag√©e
                    const learningGain = expertise.level * expertise.reliability * 0.05;
                    this.developExpertise(expertise.domain, learningGain);

                    // Enregistrer l'√©change d'expertise
                    this.episodicMemory.expertiseExchanges.push({
                        domain: expertise.domain,
                        source: message.senderId,
                        gain: learningGain,
                        timestamp: message.timestamp
                    });

                    console.log(`üéì Drone ${this.id} apprend expertise ${expertise.domain} de ${message.senderId}`);
                }
            }

            // Gestion des messages de coordination
            handleCoordinationMessage(message, allDrones) {
                const coordination = message.content;

                switch (coordination.type) {
                    case 'FORMATION_REQUEST':
                        this.handleFormationRequest(coordination, allDrones);
                        break;
                    case 'TASK_ASSIGNMENT':
                        this.handleTaskAssignment(coordination);
                        break;
                    case 'PRIORITY_UPDATE':
                        this.handlePriorityUpdate(coordination);
                        break;
                    default:
                        console.log(`‚ùì Type de coordination inconnu: ${coordination.type}`);
                }
            }

            // Gestion des messages d'urgence
            handleEmergencyMessage(message, allDrones) {
                const emergency = message.content;

                // Priorit√© absolue aux urgences
                this.behaviorAdaptation.emergencyMode = true;
                this.behaviorAdaptation.emergencyType = emergency.type;
                this.behaviorAdaptation.emergencyLocation = emergency.location;

                // Adapter comportement selon le type d'urgence
                switch (emergency.type) {
                    case 'OBSTACLE_DETECTED':
                        this.avoidObstacleArea(emergency.location, emergency.radius);
                        break;
                    case 'DRONE_LOST':
                        this.searchForLostDrone(emergency.droneId, emergency.lastKnownPosition);
                        break;
                    case 'CRITICAL_DISCOVERY':
                        this.prioritizeDiscovery(emergency.location, emergency.importance);
                        break;
                }

                console.log(`üö® Drone ${this.id} traite urgence ${emergency.type} de ${message.senderId}`);
            }

            // === M√âTHODES UTILITAIRES POUR LA GESTION DES MESSAGES ===

            evaluateStrategyRelevance(strategy) {
                // √âvaluer la pertinence d'une strat√©gie selon le contexte local
                const localCoverage = this.calculateLocalCoverage();
                const currentEfficiency = this.collectiveMetrics.efficiency;

                switch (strategy.type) {
                    case 'DISPERSION':
                        return localCoverage > 0.7 ? 0.9 : 0.3;
                    case 'SYSTEMATIC':
                        return (localCoverage > 0.3 && localCoverage < 0.8) ? 0.8 : 0.4;
                    case 'CLEANUP':
                        return localCoverage > 0.8 ? 0.9 : 0.2;
                    default:
                        return 0.5;
                }
            }

            needsExpertise(domain) {
                // D√©terminer si on a besoin d'expertise dans un domaine
                const currentLevel = this.expertiseAreas.get(domain) || 0;
                return currentLevel < 0.6; // Seuil de comp√©tence
            }

            handleFormationRequest(coordination, allDrones) {
                // G√©rer les demandes de formation
                const targetPosition = coordination.targetPosition;
                const formationType = coordination.formationType;

                if (this.position.distanceTo(targetPosition) < coordination.maxDistance) {
                    this.behaviorAdaptation.formationTarget = targetPosition;
                    this.behaviorAdaptation.formationType = formationType;
                    console.log(`üîó Drone ${this.id} rejoint formation ${formationType}`);
                }
            }

            handleTaskAssignment(coordination) {
                // G√©rer l'assignation de t√¢ches
                this.currentTask = coordination.task;
                this.taskPriority = coordination.priority;
                this.taskDeadline = coordination.deadline;
                console.log(`üìã Drone ${this.id} re√ßoit t√¢che: ${coordination.task}`);
            }

            handlePriorityUpdate(coordination) {
                // Mettre √† jour les priorit√©s
                this.explorationPriorities = { ...this.explorationPriorities, ...coordination.priorities };
                console.log(`‚ö° Drone ${this.id} met √† jour priorit√©s`);
            }

            avoidObstacleArea(location, radius) {
                // √âviter une zone d'obstacle
                const distance = this.position.distanceTo(location);
                if (distance < radius * 2) {
                    const avoidanceVector = this.position.clone().sub(location).normalize().multiplyScalar(10);
                    this.velocity.add(avoidanceVector);
                }
            }

            searchForLostDrone(droneId, lastPosition) {
                // Rechercher un drone perdu
                this.searchTarget = lastPosition;
                this.searchRadius = 50;
                this.behaviorAdaptation.currentStrategy = 'SEARCH_AND_RESCUE';
            }

            prioritizeDiscovery(location, importance) {
                // Prioriser une d√©couverte critique
                this.explorationTarget = location;
                this.currentTaskPriority = importance;
                this.behaviorAdaptation.currentStrategy = 'INVESTIGATE';
            }

            // Vote de consensus distribu√©  
            submitConsensusVote(topic, vote, confidence = 1.0) {
                const adjustedConfidence = confidence * this.consensusWeight;

                const result = SWARM_MEMORY.submitConsensusVote(
                    this.id,
                    topic,
                    vote,
                    adjustedConfidence
                );

                // Enregistrer dans l'historique
                this.votingHistory.set(topic, {
                    vote,
                    confidence: adjustedConfidence,
                    timestamp: Date.now(),
                    result
                });

                return result;
            }

            // D√©veloppement d'expertise sp√©cialis√©e
            developExpertise(domain, experience) {
                if (!this.specialization) {
                    // Premi√®re sp√©cialisation
                    this.specialization = domain;
                    this.expertiseLevel = experience * 0.1;
                } else if (this.specialization === domain) {
                    // Renforcer expertise existante
                    this.expertiseLevel = Math.min(1.0,
                        this.expertiseLevel + experience * this.learningRate
                    );
                } else {
                    // Nouvelle sp√©cialisation - devenir polyvalent
                    this.expertiseLevel *= 0.9; // L√©g√®re perte
                    if (experience > 5.0) {
                        this.specialization = domain; // Changer de sp√©cialisation
                    }
                }

                // D√©velopper capacit√© d'enseignement
                if (this.expertiseLevel > 0.7) {
                    this.teachingAbility = Math.min(1.0, this.teachingAbility + 0.05);
                }

                // Offrir expertise aux autres
                if (this.expertiseLevel > 0.5 && this.teachingAbility > 0.3) {
                    this.broadcastToSwarm('EXPERTISE_OFFER', {
                        domain: this.specialization,
                        level: this.expertiseLevel,
                        teaching: this.teachingAbility
                    }, 2.0);
                }
            }

            // Calcul contribution √† l'intelligence collective
            calculateCollectiveContribution(allDrones) {
                let contribution = 0;

                // Contribution par d√©couvertes partag√©es
                const recentDiscoveries = this.episodicMemory.discoveries.filter(
                    d => Date.now() - d.timestamp < 30000 && d.source === this.id
                );
                contribution += recentDiscoveries.length * 10;

                // Contribution par expertise
                contribution += this.expertiseLevel * 20;

                // Contribution par enseignement
                contribution += this.teachingAbility * 15;

                // Contribution par coordination
                const coordActions = this.behaviorAdaptation.strategyHistory.filter(
                    s => (typeof s === 'string' ? s.includes('COORD') : s.strategy && s.strategy.includes('COORD')) &&
                        Date.now() - (s.timestamp || 0) < 60000
                );
                contribution += coordActions.length * 5;

                this.collectiveMetrics.contributionScore = contribution;
                return contribution;
            }

            // === M√âTHODES D'INTELLIGENCE COLLECTIVE MANQUANTES ===

            updateExpertiseAndSpecialization(allDrones) {
                // Mise √† jour de l'expertise bas√©e sur l'exp√©rience r√©cente
                const recentTasks = this.behaviorAdaptation.strategyHistory.slice(-10);

                // Analyser les t√¢ches pour d√©velopper l'expertise
                const taskTypes = {};
                recentTasks.forEach(task => {
                    const domain = this.identifyTaskDomain(task);
                    taskTypes[domain] = (taskTypes[domain] || 0) + 1;
                });

                // D√©veloppement automatique d'expertise bas√© sur l'activit√© du drone
                const currentTime = Date.now();
                const activityDomain = this.identifyCurrentActivity();

                // D√©velopper l'expertise en continu selon l'activit√© (plus agressif)
                if (Math.random() < 0.5) { // 50% de chance √† chaque update (augment√©)
                    this.developExpertise(activityDomain, 1.0); // Valeur augment√©e
                }

                // D√©velopper l'expertise dans le domaine le plus pratiqu√©
                const mostPracticedDomain = Object.keys(taskTypes).reduce((a, b) =>
                    taskTypes[a] > taskTypes[b] ? a : b, 'exploration');

                if (taskTypes[mostPracticedDomain] > 0) {
                    this.developExpertise(mostPracticedDomain, taskTypes[mostPracticedDomain] * 0.1);
                }

                // Rechercher des opportunit√©s d'apprentissage aupr√®s d'experts
                const experts = allDrones.filter(drone =>
                    drone.id !== this.id &&
                    drone.expertiseLevel > this.expertiseLevel + 0.2 &&
                    this.position.distanceTo(drone.position) < 15
                );

                experts.forEach(expert => {
                    if (expert.teachingAbility > 0.5 && Math.random() < 0.1) {
                        this.learnFromExpert(expert);
                    }
                });

                // Adapter la sp√©cialisation selon les besoins de l'essaim
                this.adaptSpecializationToSwarmNeeds(allDrones);
            }

            participateInConsensus(allDrones) {
                // Participation aux d√©cisions collectives

                // 1. √âvaluer s'il y a besoin d'un consensus sur la strat√©gie
                if (Math.random() < 0.1) { // 10% de chance de proposer un consensus (augment√©)
                    const currentCoverage = this.calculateLocalCoverage();
                    if (currentCoverage < 0.3) {
                        this.submitConsensusVote('EXPLORATION_STRATEGY', 'DISPERSION', 0.8);
                    } else if (currentCoverage > 0.7) {
                        this.submitConsensusVote('EXPLORATION_STRATEGY', 'CLEANUP', 0.9);
                    }
                }

                // 2. Participer aux votes existants
                SWARM_MEMORY.consensusVotes.forEach((consensus, topic) => {
                    if (!this.votingHistory.has(topic) && consensus.votes.size < allDrones.length) {
                        const vote = this.generateConsensusVote(topic, consensus, allDrones);
                        if (vote) {
                            this.submitConsensusVote(topic, vote.choice, vote.confidence);
                        }
                    }
                });

                // 3. Appliquer les d√©cisions de consensus
                this.applyConsensusDecisions();
            }

            // === M√âTHODES UTILITAIRES POUR L'INTELLIGENCE COLLECTIVE ===

            identifyTaskDomain(task) {
                if (typeof task === 'string') {
                    if (task.includes('SCOUT') || task.includes('EXPLORATION')) return 'exploration';
                    if (task.includes('COORD') || task.includes('LEADER')) return 'coordination';
                    if (task.includes('TRANSPORT') || task.includes('CARRY')) return 'logistics';
                    if (task.includes('STEALTH') || task.includes('SPY')) return 'reconnaissance';
                }
                return 'exploration'; // par d√©faut
            }

            identifyCurrentActivity() {
                // Identifier l'activit√© actuelle du drone pour d√©velopper l'expertise correspondante
                if (this.type.role === 'coordination') return 'coordination';
                if (this.type.role === 'reconnaissance') return 'reconnaissance';
                if (this.type.role === 'transport') return 'logistics';

                // Bas√© sur la strat√©gie actuelle
                const strategy = this.behaviorAdaptation.currentStrategy;
                if (strategy.includes('COORD')) return 'coordination';
                if (strategy.includes('SCOUT') || strategy.includes('EXPLORATION')) return 'exploration';

                return 'exploration'; // par d√©faut
            }

            learnFromExpert(expert) {
                // Apprentissage aupr√®s d'un expert
                if (expert.specialization && expert.expertiseLevel > this.expertiseLevel) {
                    const learningGain = (expert.expertiseLevel - this.expertiseLevel) * expert.teachingAbility * 0.1;
                    this.developExpertise(expert.specialization, learningGain);

                    // Enregistrer l'interaction d'apprentissage
                    this.collectiveMetrics.learningInteractions++;

                    console.log(`üìö Drone ${this.id} apprend ${expert.specialization} de l'expert ${expert.id}`);
                }
            }

            adaptSpecializationToSwarmNeeds(allDrones) {
                // Adapter la sp√©cialisation selon les besoins de l'essaim
                const specializationCounts = {};
                allDrones.forEach(drone => {
                    if (drone.specialization) {
                        specializationCounts[drone.specialization] = (specializationCounts[drone.specialization] || 0) + 1;
                    }
                });

                // Si trop sp√©cialis√© dans un domaine satur√©, diversifier
                const mySpecCount = specializationCounts[this.specialization] || 0;
                const avgSpecCount = allDrones.length / Object.keys(specializationCounts).length;

                if (mySpecCount > avgSpecCount * 1.5 && Math.random() < 0.02) {
                    // Chercher un domaine sous-repr√©sent√©
                    const underrepresentedDomains = ['exploration', 'coordination', 'logistics', 'reconnaissance']
                        .filter(domain => (specializationCounts[domain] || 0) < avgSpecCount * 0.7);

                    if (underrepresentedDomains.length > 0) {
                        const newDomain = underrepresentedDomains[Math.floor(Math.random() * underrepresentedDomains.length)];
                        this.specialization = newDomain;
                        this.expertiseLevel *= 0.8; // Perte temporaire lors du changement
                        console.log(`üîÑ Drone ${this.id} se reconvertit en ${newDomain}`);
                    }
                }
            }

            generateConsensusVote(topic, consensus, allDrones) {
                // G√©n√©rer un vote intelligent bas√© sur l'expertise et l'observation
                switch (topic) {
                    case 'EXPLORATION_STRATEGY':
                        const localCoverage = this.calculateLocalCoverage();
                        if (localCoverage < 0.4) {
                            return { choice: 'DISPERSION', confidence: 0.8 };
                        } else if (localCoverage > 0.8) {
                            return { choice: 'CLEANUP', confidence: 0.9 };
                        } else {
                            return { choice: 'SYSTEMATIC', confidence: 0.7 };
                        }

                    default:
                        return { choice: 'AGREE', confidence: 0.5 };
                }
            }

            calculateLocalCoverage() {
                // Calculer la couverture dans la zone locale
                const localRadius = 20;
                const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                let localCells = 0;
                let exploredCells = 0;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const cellX = (i - CONFIG.explorationGrid / 2) * gridSize;
                        const cellZ = (j - CONFIG.explorationGrid / 2) * gridSize;
                        const distance = Math.sqrt(
                            Math.pow(cellX - this.position.x, 2) +
                            Math.pow(cellZ - this.position.z, 2)
                        );

                        if (distance <= localRadius) {
                            localCells++;
                            if (explorationMap[i][j] > 0.5) {
                                exploredCells++;
                            }
                        }
                    }
                }

                return localCells > 0 ? exploredCells / localCells : 0;
            }

            applyConsensusDecisions() {
                // Appliquer les d√©cisions de consensus adopt√©es
                SWARM_MEMORY.consensusVotes.forEach((consensus, topic) => {
                    if (consensus.decided && !this.appliedConsensus.has(topic)) {
                        switch (topic) {
                            case 'EXPLORATION_STRATEGY':
                                this.adoptExplorationStrategy(consensus.decision);
                                break;
                        }
                        this.appliedConsensus.add(topic);
                    }
                });
            }

            adoptExplorationStrategy(strategy) {
                // Adopter une strat√©gie d'exploration d√©cid√©e par consensus
                this.behaviorAdaptation.currentStrategy = strategy;
                console.log(`ü§ù Drone ${this.id} adopte la strat√©gie consensus: ${strategy}`);
            }

            // === M√âTHODES D'INTELLIGENCE COLLECTIVE SUPPL√âMENTAIRES ===

            adaptEmergentBehavior(allDrones) {
                // Adaptation comportementale √©mergente bas√©e sur l'observation de l'essaim

                // 1. Analyser les patterns comportementaux de l'essaim
                const swarmPatterns = this.analyzeSwarmPatterns(allDrones);

                // 2. D√©tecter des comportements √©mergents
                if (swarmPatterns.clusteringLevel > 0.7) {
                    // Essaim trop group√© - adopter comportement de dispersion
                    this.behaviorAdaptation.currentStrategy = 'DISPERSION';
                    this.behaviorAdaptation.adaptationScore += 0.1;
                } else if (swarmPatterns.dispersionLevel > 0.8) {
                    // Essaim trop dispers√© - adopter comportement de coh√©sion
                    this.behaviorAdaptation.currentStrategy = 'COHESION';
                    this.behaviorAdaptation.adaptationScore += 0.1;
                }

                // 3. Adaptation bas√©e sur l'efficacit√© collective
                const collectiveEfficiency = this.calculateCollectiveEfficiency(allDrones);
                if (collectiveEfficiency < 0.5) {
                    // Efficacit√© faible - changer de strat√©gie
                    this.changeExplorationStrategy();
                }

                // 4. √âmergence de r√¥les sp√©cialis√©s
                this.emergentRoleAdaptation(allDrones);

                // 5. Enregistrer l'adaptation dans l'historique
                this.behaviorAdaptation.strategyHistory.push({
                    strategy: this.behaviorAdaptation.currentStrategy,
                    timestamp: Date.now(),
                    trigger: 'EMERGENT_ADAPTATION',
                    efficiency: collectiveEfficiency
                });
            }

            manageStigmergyTraces() {
                // Gestion des traces de stigmergie personnelles et collectives

                // 1. D√©poser une trace √† la position actuelle (plus fr√©quemment)
                if (Date.now() - this.personalStigmergie.lastTraceTime > 300) { // R√©duit de 500 √† 300ms
                    SWARM_MEMORY.addStigmergyTrace(
                        this.position,
                        this.id,
                        this.behaviorAdaptation.currentStrategy,
                        this.personalStigmergie.traceIntensity
                    );
                    this.personalStigmergie.lastTraceTime = Date.now();
                }

                // 2. Lire les traces environnantes
                const nearbyTraces = SWARM_MEMORY.getStigmergyTraces(this.position, 10);

                // 3. Adapter le comportement selon les traces lues
                nearbyTraces.forEach(trace => {
                    if (trace.droneId !== this.id) {
                        // Influence des traces d'autres drones
                        const influence = trace.intensity * this.personalStigmergie.readSensitivity;

                        if (trace.traceType && trace.traceType.includes('EXPLORATION') && influence > 0.3) {
                            // Zone d√©j√† explor√©e - r√©duire l'attraction
                            this.personalStigmergie.traceIntensity *= 0.95;
                        } else if (trace.traceType && trace.traceType.includes('DISCOVERY') && influence > 0.5) {
                            // Zone de d√©couverte - augmenter l'attraction
                            this.personalStigmergie.traceIntensity *= 1.05;
                        }
                    }
                });

                // 4. D√©composition naturelle des traces
                this.personalStigmergie.traceIntensity *= this.personalStigmergie.traceDecay;
                this.personalStigmergie.traceIntensity = Math.max(0.1, this.personalStigmergie.traceIntensity);
            }

            getCollectiveIntelligenceForce(allDrones) {
                // Force d√©riv√©e de l'intelligence collective de l'essaim
                const force = new THREE.Vector3();

                // 1. Force bas√©e sur le consensus de l'essaim
                const consensusDirection = this.calculateConsensusDirection(allDrones);
                force.add(consensusDirection.multiplyScalar(0.5));

                // 2. Force d'expertise collective - suivre les experts
                const expertiseForce = this.followExpertiseGradient(allDrones);
                force.add(expertiseForce.multiplyScalar(1.0));

                // 3. Force de synchronisation avec la phase collective
                const syncForce = this.calculateSynchronizationForce(allDrones);
                force.add(syncForce.multiplyScalar(0.8));

                // 4. Force √©mergente bas√©e sur les patterns d√©tect√©s
                const emergentForce = this.calculateEmergentForce(allDrones);
                force.add(emergentForce.multiplyScalar(1.2));

                // 5. Force d'optimisation collective
                const optimizationForce = this.calculateOptimizationForce(allDrones);
                force.add(optimizationForce.multiplyScalar(0.7));

                return force;
            }

            // === M√âTHODES UTILITAIRES POUR L'INTELLIGENCE COLLECTIVE ===

            analyzeSwarmPatterns(allDrones) {
                // Analyse des patterns comportementaux de l'essaim
                let clusteringLevel = 0;
                let dispersionLevel = 0;
                let alignmentLevel = 0;

                const centerOfMass = new THREE.Vector3();
                allDrones.forEach(drone => centerOfMass.add(drone.position));
                centerOfMass.divideScalar(allDrones.length);

                let totalDistance = 0;
                let alignmentSum = 0;
                let clusterCount = 0;

                allDrones.forEach(drone => {
                    // Mesure de dispersion
                    const distanceToCenter = drone.position.distanceTo(centerOfMass);
                    totalDistance += distanceToCenter;

                    // Mesure de clustering
                    let nearbyCount = 0;
                    allDrones.forEach(other => {
                        if (other.id !== drone.id && drone.position.distanceTo(other.position) < 10) {
                            nearbyCount++;
                        }
                    });
                    if (nearbyCount > 2) clusterCount++;

                    // Mesure d'alignement
                    if (drone.velocity.length() > 0.1) {
                        const avgDirection = new THREE.Vector3();
                        allDrones.forEach(other => {
                            if (other.velocity.length() > 0.1) {
                                avgDirection.add(other.velocity.clone().normalize());
                            }
                        });
                        avgDirection.normalize();
                        const alignment = drone.velocity.clone().normalize().dot(avgDirection);
                        alignmentSum += Math.max(0, alignment);
                    }
                });

                dispersionLevel = totalDistance / (allDrones.length * CONFIG.zoneSize * 0.5);
                clusteringLevel = clusterCount / allDrones.length;
                alignmentLevel = alignmentSum / allDrones.length;

                return {
                    clusteringLevel: Math.min(1, clusteringLevel),
                    dispersionLevel: Math.min(1, dispersionLevel),
                    alignmentLevel: Math.min(1, alignmentLevel)
                };
            }

            calculateCollectiveEfficiency(allDrones) {
                // Calcul de l'efficacit√© collective de l'essaim
                let totalCoverage = 0;
                let redundancy = 0;
                let coordination = 0;

                // Mesure de couverture
                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        if (explorationMap[i][j] > 0.3) {
                            totalCoverage++;
                        }
                        if (explorationMap[i][j] > 0.8) {
                            redundancy++;
                        }
                    }
                }

                const coverage = totalCoverage / (CONFIG.explorationGrid * CONFIG.explorationGrid);
                const redundancyPenalty = redundancy / totalCoverage || 0;

                // Mesure de coordination
                let coordinatedActions = 0;
                allDrones.forEach(drone => {
                    if (drone.behaviorAdaptation.currentStrategy === this.behaviorAdaptation.currentStrategy) {
                        coordinatedActions++;
                    }
                });
                coordination = coordinatedActions / allDrones.length;

                return Math.max(0, coverage - redundancyPenalty * 0.3 + coordination * 0.2);
            }

            changeExplorationStrategy() {
                // Changement intelligent de strat√©gie d'exploration
                const strategies = ['EXPLORATION', 'DISPERSION', 'SYSTEMATIC', 'CLEANUP', 'COORDINATION'];
                const currentIndex = strategies.indexOf(this.behaviorAdaptation.currentStrategy);

                // √âviter de r√©p√©ter la m√™me strat√©gie
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * strategies.length);
                } while (newIndex === currentIndex);

                this.behaviorAdaptation.currentStrategy = strategies[newIndex];
                console.log(`üîÑ Drone ${this.id} change de strat√©gie: ${this.behaviorAdaptation.currentStrategy}`);
            }

            emergentRoleAdaptation(allDrones) {
                // Adaptation √©mergente des r√¥les selon les besoins
                const roleDistribution = {};
                allDrones.forEach(drone => {
                    const role = drone.type.role;
                    roleDistribution[role] = (roleDistribution[role] || 0) + 1;
                });

                // Adaptation si d√©s√©quilibre des r√¥les
                const totalDrones = allDrones.length;
                const idealDistribution = {
                    'exploration': Math.ceil(totalDrones * 0.4),
                    'coordination': Math.ceil(totalDrones * 0.2),
                    'reconnaissance': Math.ceil(totalDrones * 0.2),
                    'transport': Math.ceil(totalDrones * 0.2)
                };

                Object.keys(idealDistribution).forEach(role => {
                    const current = roleDistribution[role] || 0;
                    const ideal = idealDistribution[role];

                    if (current < ideal * 0.7 && Math.random() < 0.05) {
                        // R√¥le sous-repr√©sent√© - possibilit√© d'adaptation
                        if (this.expertiseLevel > 0.6) {
                            this.specialization = role;
                            console.log(`üé≠ Drone ${this.id} adopte le r√¥le √©mergent: ${role}`);
                        }
                    }
                });
            }

            calculateConsensusDirection(allDrones) {
                // Direction bas√©e sur le consensus de l'essaim
                const consensusDirection = new THREE.Vector3();

                // Analyser les votes de consensus actifs
                SWARM_MEMORY.consensusVotes.forEach((consensus, topic) => {
                    if (consensus.decided && topic === 'EXPLORATION_STRATEGY') {
                        switch (consensus.decision) {
                            case 'DISPERSION':
                                consensusDirection.add(this.getMaxDispersionForce(allDrones));
                                break;
                            case 'CLEANUP':
                                consensusDirection.add(this.getCleanupScoutingForce(allDrones));
                                break;
                            case 'SYSTEMATIC':
                                consensusDirection.add(this.getSystematicScoutingForce());
                                break;
                        }
                    }
                });

                return consensusDirection.normalize();
            }

            followExpertiseGradient(allDrones) {
                // Suivre le gradient d'expertise de l'essaim
                const expertiseForce = new THREE.Vector3();

                allDrones.forEach(drone => {
                    if (drone.id !== this.id && drone.expertiseLevel > this.expertiseLevel + 0.1) {
                        const direction = drone.position.clone().sub(this.position);
                        const distance = direction.length();

                        if (distance > 0 && distance < 20) {
                            direction.normalize();
                            const expertiseGradient = (drone.expertiseLevel - this.expertiseLevel) / distance;
                            expertiseForce.add(direction.multiplyScalar(expertiseGradient));
                        }
                    }
                });

                return expertiseForce;
            }

            calculateSynchronizationForce(allDrones) {
                // Force de synchronisation avec l'essaim
                const syncForce = new THREE.Vector3();

                // Synchronisation de vitesse
                const avgVelocity = new THREE.Vector3();
                allDrones.forEach(drone => avgVelocity.add(drone.velocity));
                avgVelocity.divideScalar(allDrones.length);

                const velocityDiff = avgVelocity.clone().sub(this.velocity);
                syncForce.add(velocityDiff.multiplyScalar(0.3));

                return syncForce;
            }

            calculateEmergentForce(allDrones) {
                // Force bas√©e sur les comportements √©mergents d√©tect√©s
                const emergentForce = new THREE.Vector3();

                // D√©tecter les formations √©mergentes
                const formations = this.detectSwarmFormations(allDrones);

                formations.forEach(formation => {
                    if (formation.type === 'LINE' && formation.participants.includes(this.id)) {
                        // Maintenir la formation en ligne
                        const lineDirection = formation.direction;
                        emergentForce.add(lineDirection.multiplyScalar(0.5));
                    } else if (formation.type === 'CIRCLE' && formation.participants.includes(this.id)) {
                        // Maintenir la formation circulaire
                        const centerDirection = formation.center.clone().sub(this.position);
                        centerDirection.normalize().multiplyScalar(formation.radius - centerDirection.length());
                        emergentForce.add(centerDirection.multiplyScalar(0.3));
                    }
                });

                return emergentForce;
            }

            calculateOptimizationForce(allDrones) {
                // Force d'optimisation collective
                const optimizationForce = new THREE.Vector3();

                // Optimisation de la couverture
                const coverageGradient = this.calculateCoverageGradient();
                optimizationForce.add(coverageGradient.multiplyScalar(0.8));

                // Optimisation √©nerg√©tique
                const energyOptimization = this.calculateEnergyOptimization(allDrones);
                optimizationForce.add(energyOptimization.multiplyScalar(0.4));

                return optimizationForce;
            }

            detectSwarmFormations(allDrones) {
                // D√©tection des formations √©mergentes de l'essaim
                const formations = [];

                // D√©tection de formations lin√©aires
                if (allDrones.length >= 3) {
                    const lineFormation = this.detectLineFormation(allDrones);
                    if (lineFormation) formations.push(lineFormation);
                }

                // D√©tection de formations circulaires
                if (allDrones.length >= 4) {
                    const circleFormation = this.detectCircleFormation(allDrones);
                    if (circleFormation) formations.push(circleFormation);
                }

                return formations;
            }

            detectLineFormation(allDrones) {
                // D√©tection de formation en ligne
                // Impl√©mentation simplifi√©e
                if (allDrones.length >= 3) {
                    return {
                        type: 'LINE',
                        participants: allDrones.slice(0, 3).map(d => d.id),
                        direction: new THREE.Vector3(1, 0, 0)
                    };
                }
                return null;
            }

            detectCircleFormation(allDrones) {
                // D√©tection de formation circulaire
                // Impl√©mentation simplifi√©e
                if (allDrones.length >= 4) {
                    const center = new THREE.Vector3();
                    allDrones.forEach(drone => center.add(drone.position));
                    center.divideScalar(allDrones.length);

                    return {
                        type: 'CIRCLE',
                        participants: allDrones.slice(0, 4).map(d => d.id),
                        center: center,
                        radius: 10
                    };
                }
                return null;
            }

            calculateCoverageGradient() {
                // Gradient de couverture pour optimisation
                const gradient = new THREE.Vector3();
                const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;

                // Trouver la direction vers les zones moins explor√©es
                let bestDirection = null;
                let bestScore = -Infinity;

                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    const direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                    const testPos = this.position.clone().add(direction.multiplyScalar(15));

                    const gridX = Math.floor((testPos.x + CONFIG.zoneSize / 2) / gridSize);
                    const gridZ = Math.floor((testPos.z + CONFIG.zoneSize / 2) / gridSize);

                    if (gridX >= 0 && gridX < CONFIG.explorationGrid &&
                        gridZ >= 0 && gridZ < CONFIG.explorationGrid) {
                        const exploration = explorationMap[gridX][gridZ];
                        const score = 1 - exploration; // Plus faible exploration = meilleur score

                        if (score > bestScore) {
                            bestScore = score;
                            bestDirection = direction.clone();
                        }
                    }
                }

                return bestDirection || new THREE.Vector3();
            }

            calculateEnergyOptimization(allDrones) {
                // Optimisation √©nerg√©tique bas√©e sur la proximit√©
                const energyForce = new THREE.Vector3();

                // R√©duire l'effort en suivant des trajectoires plus efficaces
                if (this.velocity.length() > this.type.speed * 0.8) {
                    // Vitesse trop √©lev√©e - r√©duire l'effort
                    energyForce.add(this.velocity.clone().multiplyScalar(-0.1));
                }

                // Profiter du sillage d'autres drones
                allDrones.forEach(drone => {
                    if (drone.id !== this.id) {
                        const distance = this.position.distanceTo(drone.position);
                        if (distance < 8 && distance > 3) {
                            const slipstream = drone.velocity.clone().normalize();
                            energyForce.add(slipstream.multiplyScalar(0.2));
                        }
                    }
                });

                return energyForce;
            }

            createMesh() {
                this.group = new THREE.Group();

                // === CORPS ULTRA-R√âALISTE DE DRONE CRAZYFLIE ===

                // Corps principal - design moderne et a√©rodynamique
                const bodyGeometry = new THREE.CapsuleGeometry(this.type.size * 0.4, this.type.size * 1.0, 4, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: this.type.color,
                    shininess: 150,
                    specular: 0x666666,
                    metalness: 0.8,
                    reflectivity: 0.3
                });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.castShadow = true;
                this.body.receiveShadow = true;
                this.body.rotation.z = Math.PI / 2; // Orientation horizontale
                this.group.add(this.body);

                // Module central √©lectronique d√©taill√©
                const centralModuleGeometry = new THREE.BoxGeometry(
                    this.type.size * 0.6,
                    this.type.size * 0.15,
                    this.type.size * 0.4
                );
                const centralModuleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x1a1a1a,
                    shininess: 80,
                    specular: 0x333333
                });
                const centralModule = new THREE.Mesh(centralModuleGeometry, centralModuleMaterial);
                centralModule.position.y = 0.05;
                centralModule.castShadow = true;
                this.group.add(centralModule);

                // Cockpit/cam√©ra frontale avec d√¥me en verre
                const cockpitGeometry = new THREE.SphereGeometry(this.type.size * 0.18, 12, 8);
                const cockpitMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222244,
                    transparent: true,
                    opacity: 0.85,
                    reflectivity: 0.9,
                    shininess: 200
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.set(this.type.size * 0.3, 0.1, 0);
                cockpit.castShadow = true;
                this.group.add(cockpit);

                // Bras de moteurs renforc√©s avec d√©tails
                this.propellers = [];
                this.motorArms = [];
                const propCount = this.typeName === 'HEAVY' ? 6 : 4;

                for (let i = 0; i < propCount; i++) {
                    const angle = (i / propCount) * Math.PI * 2;
                    const radius = this.type.size * 0.8;

                    // Bras de moteur tubulaire
                    const armGeometry = new THREE.CylinderGeometry(0.02, 0.03, radius * 0.8, 8);
                    const armMaterial = new THREE.MeshPhongMaterial({
                        color: 0x404040,
                        metalness: 0.7,
                        shininess: 100
                    });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.set(
                        Math.cos(angle) * radius * 0.4,
                        0,
                        Math.sin(angle) * radius * 0.4
                    );
                    arm.rotation.z = angle + Math.PI / 2;
                    arm.castShadow = true;
                    this.group.add(arm);
                    this.motorArms.push(arm);

                    // Moteur d√©taill√© avec refroidissement
                    const motorGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.2, 12);
                    const motorMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2a2a2a,
                        metalness: 0.9,
                        shininess: 150
                    });
                    const motor = new THREE.Mesh(motorGeometry, motorMaterial);
                    motor.position.set(
                        Math.cos(angle) * radius,
                        0.12,
                        Math.sin(angle) * radius
                    );
                    motor.castShadow = true;
                    this.group.add(motor);

                    // Ailettes de refroidissement
                    for (let j = 0; j < 4; j++) {
                        const finGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.001);
                        const finMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                        const fin = new THREE.Mesh(finGeometry, finMaterial);
                        fin.position.set(
                            Math.cos(angle) * radius + Math.cos(j * Math.PI / 2) * 0.06,
                            0.12,
                            Math.sin(angle) * radius + Math.sin(j * Math.PI / 2) * 0.06
                        );
                        this.group.add(fin);
                    }

                    // H√©lices dynamiques avec effet blur de rotation
                    const propGeometry = new THREE.CylinderGeometry(0.01, 0.01, this.type.size * 0.6, 3);
                    const propMaterial = new THREE.MeshBasicMaterial({
                        color: 0xcccccc,
                        transparent: true,
                        opacity: 0.4
                    });
                    const prop = new THREE.Mesh(propGeometry, propMaterial);
                    prop.position.set(
                        Math.cos(angle) * radius,
                        0.18,
                        Math.sin(angle) * radius
                    );
                    prop.rotation.y = angle;
                    this.group.add(prop);
                    this.propellers.push(prop);

                    // Effet de blur rotatif pour les h√©lices en mouvement
                    const blurGeometry = new THREE.RingGeometry(0.02, this.type.size * 0.35, 16);
                    const blurMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    const blur = new THREE.Mesh(blurGeometry, blurMaterial);
                    blur.position.set(
                        Math.cos(angle) * radius,
                        0.18,
                        Math.sin(angle) * radius
                    );
                    blur.rotation.x = -Math.PI / 2;
                    this.group.add(blur);
                    this.propellers.push(blur);
                }

                // Syst√®me LED avanc√© avec clignotement
                const ledPositions = [
                    { x: this.type.size * 0.5, z: 0, color: 0xFF0000, intensity: 1.0 }, // Rouge avant
                    { x: -this.type.size * 0.5, z: 0, color: 0x00FF00, intensity: 0.8 }, // Vert arri√®re
                    { x: 0, z: this.type.size * 0.5, color: 0xFFFFFF, intensity: 0.6 }, // Blanc droite
                    { x: 0, z: -this.type.size * 0.5, color: 0xFFFFFF, intensity: 0.6 }, // Blanc gauche
                    { x: 0, y: 0.15, z: 0, color: this.type.color, intensity: 1.2 } // LED centrale status
                ];

                this.leds = [];
                ledPositions.forEach((pos, i) => {
                    const ledGeometry = new THREE.SphereGeometry(0.04, 8, 6);
                    const ledMaterial = new THREE.MeshBasicMaterial({
                        color: pos.color,
                        emissive: pos.color,
                        emissiveIntensity: pos.intensity
                    });
                    const led = new THREE.Mesh(ledGeometry, ledMaterial);
                    led.position.set(pos.x, pos.y || 0.12, pos.z);
                    this.group.add(led);
                    this.leds.push(led);

                    // Lumi√®re ponctuelle pour chaque LED
                    const ledLight = new THREE.PointLight(pos.color, pos.intensity * 0.5, 3);
                    ledLight.position.copy(led.position);
                    this.group.add(ledLight);
                });

                // Composants sp√©cialis√©s selon le r√¥le
                if (this.type.role === 'reconnaissance') {
                    // Cam√©ra gimbal stabilis√©e
                    const gimbalGeometry = new THREE.SphereGeometry(0.08, 12, 8);
                    const gimbalMaterial = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        shininess: 100
                    });
                    const gimbal = new THREE.Mesh(gimbalGeometry, gimbalMaterial);
                    gimbal.position.y = -0.1;
                    this.group.add(gimbal);

                    // Objectif de cam√©ra
                    const lensGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.06, 12);
                    const lensMaterial = new THREE.MeshPhongMaterial({
                        color: 0x001122,
                        transparent: true,
                        opacity: 0.8,
                        reflectivity: 0.9
                    });
                    const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                    lens.position.set(0, -0.12, 0.05);
                    lens.rotation.x = Math.PI / 2;
                    this.group.add(lens);
                }

                if (this.type.role === 'coordination') {
                    // Antenne de communication parabolique
                    const dishGeometry = new THREE.CylinderGeometry(0.15, 0.02, 0.02, 16);
                    const dishMaterial = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                        metalness: 0.8,
                        shininess: 200
                    });
                    const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                    dish.position.y = 0.3;
                    dish.rotation.x = Math.PI / 2;
                    this.group.add(dish);

                    // Antenne lin√©aire
                    const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.4, 8);
                    const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = 0.35;
                    this.group.add(antenna);
                }

                if (this.type.role === 'transport') {
                    // Module de transport sous le drone
                    const cargoGeometry = new THREE.BoxGeometry(
                        this.type.size * 0.8,
                        this.type.size * 0.3,
                        this.type.size * 0.6
                    );
                    const cargoMaterial = new THREE.MeshPhongMaterial({
                        color: 0x444444,
                        metalness: 0.6
                    });
                    const cargo = new THREE.Mesh(cargoGeometry, cargoMaterial);
                    cargo.position.y = -0.2;
                    cargo.castShadow = true;
                    this.group.add(cargo);

                    // Crochets de transport
                    for (let i = 0; i < 4; i++) {
                        const hookGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.08, 6);
                        const hookMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                        const hook = new THREE.Mesh(hookGeometry, hookMaterial);
                        hook.position.set(
                            (i % 2 - 0.5) * this.type.size * 0.6,
                            -0.35,
                            (Math.floor(i / 2) - 0.5) * this.type.size * 0.4
                        );
                        this.group.add(hook);
                    }
                }

                // Aura √©nerg√©tique DIAMANTS visible
                const auraGeometry = new THREE.SphereGeometry(this.type.size * 1.2, 16, 12);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: this.type.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                this.aura = new THREE.Mesh(auraGeometry, auraMaterial);
                this.group.add(this.aura);

                this.group.position.copy(this.position);
                this.group.scale.setScalar(1.5); // Agrandir pour meilleure visibilit√©

                // S√©curit√© : s'assurer que le groupe est ajout√© √† la sc√®ne
                if (!this.group.parent) {
                    scene.add(this.group);
                }

                // Marquer comme cr√©√© avec succ√®s
                this.meshCreated = true;
            }

            createTrail() {
                const trailGeometry = new THREE.BufferGeometry();
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.6
                });
                this.trail = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(this.trail);
            }

            update(time, allDrones, deltaTime = 0.016) {
                // ===== CALCUL DIAMANTS WAHOO =====

                // 1. Calcul des potentiels œÜ (attractif) et œÉ (r√©pulsif)
                this.phi = 0;
                this.sigma = 0;

                // Variables pour le comportement d'essaim
                const cohesion = new THREE.Vector3(0, 0, 0);
                const separation = new THREE.Vector3(0, 0, 0);
                const alignment = new THREE.Vector3(0, 0, 0);
                let neighborCount = 0;

                allDrones.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = this.position.distanceTo(other.position);

                        if (dist > 0.1 && dist < CONFIG.swarmRadius) {
                            neighborCount++;

                            // === DIAMANTS SCOUTING : œÜ (COH√âSION) et œÉ (EXPLORATION) ===
                            // œÜ (phi) : Force attractive pour coordination scouting
                            this.phi += CONFIG.magneticForce * Math.exp(-dist * 0.05) *
                                (other.type.role === 'coordination' ? 1.5 : 1.0); // Attraction vers leaders

                            // œÉ (sigma) : Force r√©pulsive pour √©viter chevauchement zones scouting
                            this.sigma += 3.0 * Math.exp(-dist * dist * 0.02) *
                                (1.0 + this.scoutingPriority); // Plus fort si priorit√© haute

                            // Modulation DIAMANTS selon r√¥les
                            if (this.type.role === 'coordination' && other.type.role !== 'coordination') {
                                this.phi *= 0.8; // Leaders moins attir√©s
                                this.sigma *= 1.3; // Mais maintiennent distance
                            }

                            // BOIDS - Coh√©sion (attraction vers le centre de masse)
                            cohesion.add(other.position);

                            // BOIDS - Alignement (align avec la vitesse moyenne)
                            alignment.add(other.velocity);

                            // BOIDS - S√©paration (√©vitement collision)
                            if (dist < 8) {
                                const separate = this.position.clone().sub(other.position);
                                separate.normalize().divideScalar(dist); // Plus proche = plus forte
                                separation.add(separate);
                            }
                        }
                    }
                });

                // Finaliser les forces BOIDS
                if (neighborCount > 0) {
                    // Coh√©sion - se diriger vers le centre de masse
                    cohesion.divideScalar(neighborCount);
                    cohesion.sub(this.position);
                    cohesion.normalize().multiplyScalar(CONFIG.swarmCohesion);

                    // Alignement - s'aligner avec la vitesse moyenne
                    alignment.divideScalar(neighborCount);
                    alignment.normalize().multiplyScalar(CONFIG.swarmAlignment);

                    // S√©paration - √©viter les collisions
                    if (separation.length() > 0) {
                        separation.normalize().multiplyScalar(CONFIG.swarmSeparation);
                    }
                }

                // 2. Calcul du gradient ‚àá(œÜ+œÉ) - DIAMANTS SCOUTING AVANC√â
                try {
                    const h = 0.8; // Pr√©cision adapt√©e au scouting

                    // Gradient spatial complet avec composante d'altitude
                    const gradX = (this.sampleScoutingPotential(this.position.x + h, this.position.y, this.position.z, allDrones) -
                        this.sampleScoutingPotential(this.position.x - h, this.position.y, this.position.z, allDrones)) / (2 * h);
                    const gradY = (this.sampleScoutingPotential(this.position.x, this.position.y + h, this.position.z, allDrones) -
                        this.sampleScoutingPotential(this.position.x, this.position.y - h, this.position.z, allDrones)) / (2 * h);
                    const gradZ = (this.sampleScoutingPotential(this.position.x, this.position.y, this.position.z + h, allDrones) -
                        this.sampleScoutingPotential(this.position.x, this.position.y, this.position.z - h, allDrones)) / (2 * h);

                    // S√©curit√© num√©rique
                    if (isFinite(gradX) && isFinite(gradY) && isFinite(gradZ)) {
                        this.gradient.set(gradX, gradY * 0.3, gradZ); // R√©duire Y pour vol horizontal
                    } else {
                        this.gradient.set(0, 0, 0);
                    }
                } catch (error) {
                    this.gradient.set(0, 0, 0);
                }

                // 3. Intelligence DIAMANTS scouting : I(t) = ‚à¨|‚àá(œÜ+œÉ)|dŒ©
                const rawIntelligence = this.gradient.length();
                this.intelligence = rawIntelligence * this.wahooFactor * (1.0 + this.scoutingPriority);

                // 4. √âmergence collaborative : amplification non-lin√©aire
                const collaborationFactor = 1.0 + this.collaborationScore * 2.0; // Facteur augment√©
                this.emergence = Math.pow(this.intelligence * collaborationFactor, 1.2);

                // Mise √† jour des m√©triques collectives en temps r√©el
                this.collectiveMetrics.knowledgeSharing += this.intelligence * 0.01;
                this.collectiveMetrics.efficiency = this.scoutingEfficiency;

                // 5. Mise √† jour des m√©triques de scouting
                this.updateScoutingMetrics(time, allDrones);

                // === INTELLIGENCE COLLECTIVE INT√âGR√âE ===

                // 6. Communication temps r√©el avec l'essaim
                this.receiveSwarmMessages(allDrones);

                // 7. Mise √† jour de l'expertise et sp√©cialisation
                this.updateExpertiseAndSpecialization(allDrones);

                // 8. Participation aux consensus distribu√©s
                this.participateInConsensus(allDrones);

                // 9. Calcul de la contribution collective
                this.calculateCollectiveContribution(allDrones);

                // 10. Adaptation comportementale √©mergente
                this.adaptEmergentBehavior(allDrones);

                // 11. Gestion de la stigmergie collective
                this.manageStigmergyTraces();

                // === FOR√áAGE ACTIVIT√â INTELLIGENCE COLLECTIVE ===
                // S'assurer que les m√©triques restent actives
                if (this.expertiseLevel > 0) {
                    // Forcer l'√©mergence bas√©e sur l'expertise
                    this.emergence = Math.max(this.emergence, this.expertiseLevel * 0.3 + Math.random() * 0.2);

                    // Forcer la collaboration si proche d'autres drones
                    let nearbyDrones = 0;
                    allDrones.forEach(other => {
                        if (other.id !== this.id && this.position.distanceTo(other.position) < 25) {
                            nearbyDrones++;
                        }
                    });

                    if (nearbyDrones > 0) {
                        this.collaborationScore = Math.max(this.collaborationScore, 0.5 + nearbyDrones * 0.1);
                        this.episodicMemory.collaborationScore = this.collaborationScore;
                    }

                    // D√©veloppement continu d'expertise
                    if (Math.random() < 0.1) { // 10% de chance √† chaque frame
                        this.expertiseLevel = Math.min(5.0, this.expertiseLevel + 0.01);
                        this.episodicMemory.expertise = this.expertiseLevel;
                    }
                }

                // 12. Scouting intelligent - D√©couverte de cibles
                this.performScouting();

                // 13. Force d'exploration optimale avec intelligence collective
                const explorationForce = this.getExplorationForce();

                // 14. Force de pattern selon le mode
                const patternForce = this.getPatternForce(time, allDrones);

                // 15. Force collaborative pour scouting coordonn√©
                const collaborativeForce = this.getCollaborativeScoutingForce(allDrones);

                // 16. Force d'intelligence collective pure
                const collectiveForce = this.getCollectiveIntelligenceForce(allDrones);

                // 17. Force DIAMANTS pure
                const diamantForce = this.gradient.clone().multiplyScalar(0.3);

                // 18. Force combin√©e optimis√©e pour intelligence collective
                const totalForce = new THREE.Vector3()
                    .add(diamantForce)
                    .add(cohesion.multiplyScalar(CONFIG.swarmCohesion * 0.5))
                    .add(separation.multiplyScalar(CONFIG.swarmSeparation))
                    .add(alignment.multiplyScalar(CONFIG.swarmAlignment * 0.6))
                    .add(explorationForce.multiplyScalar(CONFIG.searchSpeed * 0.7))
                    .add(patternForce.multiplyScalar(CONFIG.autonomyPower * 0.8))
                    .add(collaborativeForce.multiplyScalar(1.0))
                    .add(collectiveForce.multiplyScalar(1.5)); // Force collective prioritaire

                // 10. Int√©gration physique optimis√©e avec deltaTime r√©el
                const accelerationFactor = 0.02 * (deltaTime / 0.016); // Adaptation √† deltaTime
                this.velocity.add(totalForce.multiplyScalar(accelerationFactor));
                this.velocity.clampLength(0, this.type.speed * 0.8); // Limite la vitesse maximum

                // Friction adapt√©e au deltaTime pour mouvement plus fluide
                const frictionFactor = Math.pow(0.92, deltaTime / 0.016);
                this.velocity.multiplyScalar(frictionFactor);

                const oldPos = this.position.clone();
                const deltaPos = this.velocity.clone().multiplyScalar(deltaTime);

                // V√©rification de validit√© du d√©placement
                if (isFinite(deltaPos.x) && isFinite(deltaPos.y) && isFinite(deltaPos.z)) {
                    this.position.add(deltaPos);

                    // D√©tection de t√©l√©portation (mouvement trop brusque) - adapt√© au deltaTime
                    const maxMovement = 5.0 * deltaTime / 0.016; // Adaptation selon deltaTime
                    const movementDistance = oldPos.distanceTo(this.position);
                    if (movementDistance > maxMovement) {
                        console.warn(`‚ö†Ô∏è  Mouvement suspect d√©tect√© pour drone ${this.id}: ${movementDistance.toFixed(2)}m`);
                        // Correction: revenir √† l'ancienne position et arr√™ter
                        this.position.copy(oldPos);
                        this.velocity.multiplyScalar(0.1);
                    }
                } else {
                    console.warn(`Mouvement invalide d√©tect√© pour drone ${this.id}, arr√™t temporaire`);
                    this.velocity.set(0, 0, 0);
                }

                // 10. Contraintes de zone foresti√®re - SANS T√âL√âPORTATION
                const boundary = CONFIG.zoneSize / 2 - 5; // Marge de s√©curit√©

                // Contraintes douces par rebond progressif (Z√âRO T√âL√âPORTATION)
                if (Math.abs(this.position.x) > boundary) {
                    // Rebond doux avec correction graduelle
                    const overshoot = Math.abs(this.position.x) - boundary;
                    const reboundForce = -Math.sign(this.position.x) * Math.min(2.0, overshoot * 0.5);
                    this.velocity.x = this.velocity.x * 0.3 + reboundForce;
                    // PAS de t√©l√©portation, juste r√©duction de vitesse
                }

                if (Math.abs(this.position.z) > boundary) {
                    // Rebond doux avec correction graduelle 
                    const overshoot = Math.abs(this.position.z) - boundary;
                    const reboundForce = -Math.sign(this.position.z) * Math.min(2.0, overshoot * 0.5);
                    this.velocity.z = this.velocity.z * 0.3 + reboundForce;
                    // PAS de t√©l√©portation, juste r√©duction de vitesse
                }

                // Contrainte d'altitude GRADUELLE (Z√âRO T√âL√âPORTATION)
                const groundLevel = 2.0; // Altitude minimale : niveau sol
                const maxAltitude = 15.0;  // Plafond maximum : niveau troncs d'arbres

                if (this.position.y < groundLevel) {
                    // Force graduelle vers le haut (pas de t√©l√©portation)
                    const deficit = groundLevel - this.position.y;
                    this.velocity.y += deficit * 0.5; // Force proportionnelle
                    this.velocity.y = Math.max(0.1, this.velocity.y); // Minimum vers le haut
                } else if (this.position.y > maxAltitude) {
                    // Force graduelle vers le bas (pas de t√©l√©portation)
                    const excess = this.position.y - maxAltitude;
                    this.velocity.y -= excess * 0.5; // Force proportionnelle  
                    this.velocity.y = Math.min(-0.1, this.velocity.y); // Minimum vers le bas
                }

                // SUPPRESSION de l'assignation directe qui causait la t√©l√©portation
                // Maintenant, force naturelle vers l'altitude optimale
                const targetAlt = this.calculateOptimalAltitude();
                const altitudeDifference = targetAlt - this.position.y;

                // Force graduelle vers l'altitude cible
                if (Math.abs(altitudeDifference) > 0.5) {
                    const altForce = altitudeDifference * 0.3; // Force proportionnelle
                    this.velocity.y += altForce * 0.02; // Application douce
                }

                // Limiter la vitesse verticale pour mouvement naturel
                this.velocity.y = Math.max(-2.0, Math.min(2.0, this.velocity.y));

                // Validation finale de la position (Z√âRO T√âL√âPORTATION)
                if (!isFinite(this.position.x) || !isFinite(this.position.y) || !isFinite(this.position.z)) {
                    console.error(`Position invalide pour drone ${this.id}, correction par forces`);
                    // Correction par forces au lieu de t√©l√©portation
                    if (!isFinite(this.position.x)) {
                        this.velocity.x = 0;
                        this.position.x = 0; // Seule exception : correction NaN/Infinity
                    }
                    if (!isFinite(this.position.y)) {
                        this.velocity.y = 0.5; // Force vers une altitude s√©curis√©e
                        this.position.y = 8; // Correction altitude scouting : niveau troncs
                    }
                    if (!isFinite(this.position.z)) {
                        this.velocity.z = 0;
                        this.position.z = 0; // Seule exception : correction NaN/Infinity
                    }
                }

                // 11. Mise √† jour visuelle WAHOO
                this.updateVisual(time);
                this.updateTrail();
            }

            performScouting() {
                // Recherche et d√©couverte de cibles avec d√©tection am√©lior√©e
                scoutingTargets.forEach(target => {
                    if (!target.discovered) {
                        const distance = this.position.distanceTo(target.position);
                        // Port√©e de d√©tection augment√©e et adapt√©e au type de drone
                        const detectionRange = this.type.sensorRange * (this.type.role === 'reconnaissance' ? 1.0 : 0.8);

                        if (distance < detectionRange) {
                            target.discovered = true;
                            target.discoveredBy = this.id;
                            target.discoveryTime = Date.now();

                            // Effet visuel de d√©couverte renforc√©
                            if (target.mesh.children.length > 1) {
                                target.mesh.children[1].material.emissiveIntensity = 1.5;
                                target.mesh.children[0].material.emissiveIntensity = 1.0;

                                // Clignotement pour marquer la d√©couverte
                                const blinkInterval = setInterval(() => {
                                    target.mesh.children[1].material.emissiveIntensity =
                                        target.mesh.children[1].material.emissiveIntensity > 1.0 ? 0.5 : 1.5;
                                }, 200);

                                setTimeout(() => clearInterval(blinkInterval), 2000);
                            }

                            // Notification de d√©couverte avec plus d'infos
                            console.log(`üéØ Drone ${this.id} (${this.type.name}) a d√©couvert une cible ${target.type} √† ${distance.toFixed(1)}m!`);

                            // Bonus d'intelligence progressive pour la d√©couverte
                            this.intelligence += target.value * 0.2;

                            // Partage d'information avec les autres drones (communication)
                            drones.forEach(otherDrone => {
                                if (otherDrone.id !== this.id) {
                                    const commRange = 50; // Port√©e de communication
                                    const commDistance = this.position.distanceTo(otherDrone.position);
                                    if (commDistance < commRange) {
                                        // Bonus d'intelligence pour la coordination
                                        otherDrone.intelligence += target.value * 0.05;
                                    }
                                }
                            });
                        }
                    }
                });

                // Marquage des arbres explor√©s avec syst√®me am√©lior√©
                trees.forEach(tree => {
                    if (!tree.isExplored) {
                        const distance = this.position.distanceTo(tree.position);
                        const explorationRange = this.type.sensorRange * 1.2; // Port√©e √©largie

                        if (distance < explorationRange) {
                            tree.isExplored = true;
                            tree.exploredBy = this.id;
                            tree.explorationTime = Date.now();

                            // Effet visuel d'exploration plus visible
                            if (tree.mesh.children.length > 1) {
                                tree.mesh.children.forEach((child, index) => {
                                    if (index > 0) { // Feuillage
                                        child.material.opacity = Math.max(0.4, child.material.opacity - 0.3);
                                        child.material.emissive = new THREE.Color(0x002200);
                                        child.material.emissiveIntensity = 0.2;
                                    }
                                });
                            }

                            // Mise √† jour de la grille d'exploration
                            const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                            const gridX = Math.floor((tree.position.x + CONFIG.zoneSize / 2) / gridSize);
                            const gridZ = Math.floor((tree.position.z + CONFIG.zoneSize / 2) / gridSize);

                            if (gridX >= 0 && gridX < CONFIG.explorationGrid &&
                                gridZ >= 0 && gridZ < CONFIG.explorationGrid) {
                                explorationMap[gridX][gridZ] = Math.min(1.0, explorationMap[gridX][gridZ] + 0.3);
                            }
                        }
                    }
                });
            }

            calculateOptimalAltitude() {
                // SCOUTING COLLABORATIF : Vol au niveau des troncs d'arbres
                const groundLevel = 2.0; // Niveau sol forestier
                let baseAltitude = 8.0; // Altitude de scouting au niveau des troncs (8m)

                // Ajustement selon le type de drone pour scouting collaboratif
                switch (this.type.role) {
                    case 'reconnaissance':
                        baseAltitude = 12.0; // L√©g√®rement plus haut pour vision d'ensemble
                        break;
                    case 'exploration':
                        baseAltitude = 8.0; // Niveau troncs pour exploration d√©taill√©e
                        break;
                    case 'transport':
                        baseAltitude = 6.0; // Plus bas pour transport pr√©cis
                        break;
                    case 'coordination':
                        baseAltitude = 15.0; // Plafond max pour coordination
                        break;
                }

                // √âvitement minimal des arbres - vol ENTRE les troncs
                let minSafeAltitude = baseAltitude;
                trees.forEach(tree => {
                    const distance = Math.sqrt(
                        Math.pow(this.position.x - tree.position.x, 2) +
                        Math.pow(this.position.z - tree.position.z, 2)
                    );

                    // √âvitement seulement si tr√®s proche du tronc
                    if (distance < tree.radius + 3) {
                        const safeAlt = tree.height * 0.6 + 2; // Vol √† mi-hauteur du tronc
                        minSafeAltitude = Math.max(minSafeAltitude, safeAlt);
                    }
                });

                // PLAFOND MAXIMUM : 15m (niveau troncs)
                return Math.min(Math.max(groundLevel, minSafeAltitude), 15.0);
            }

            // === FONCTIONS DIAMANTS SCOUTING AVANC√âES ===
            sampleScoutingPotential(x, y, z, drones) {
                let potential = 0;

                // Potentiel des autres drones (œÜ + œÉ adapt√© au scouting)
                drones.forEach(other => {
                    if (other.id !== this.id) {
                        const dx = x - other.position.x;
                        const dy = y - other.position.y;
                        const dz = z - other.position.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist > 0.1) {
                            // œÜ (attraction collaborative mod√©r√©e)
                            potential += other.phi * Math.exp(-dist * 0.1) *
                                (other.type.role === 'coordination' ? 1.3 : 0.8);

                            // œÉ (r√©pulsion pour √©vitement zones scout√©es)  
                            potential -= other.sigma * Math.exp(-dist * dist * 0.05) *
                                (1.0 + other.scoutingEfficiency * 0.3);
                        }
                    }
                });

                // Potentiel des cibles de scouting
                scoutingTargets.forEach(target => {
                    if (!target.discovered) {
                        const dx = x - target.position.x;
                        const dz = z - target.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        // Attraction vers cibles non d√©couvertes
                        potential += target.value * Math.exp(-dist * 0.2) * 2.0;
                    }
                });

                // Potentiel d'√©vitement d'obstacles
                trees.forEach(tree => {
                    const dx = x - tree.position.x;
                    const dz = z - tree.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < tree.radius + 5) {
                        potential -= 100.0 * Math.exp(-dist * 0.5); // Forte r√©pulsion arbres
                    }
                });

                return potential;
            }

            updateScoutingMetrics(time, allDrones) {
                // Mise √† jour efficacit√© scouting
                this.scoutingEfficiency = Math.min(1.0, this.scoutingEfficiency + this.intelligence * 0.001);

                // Score de collaboration bas√© sur proximit√© avec autres drones
                this.collaborationScore = 0;
                const collaborationRange = 20;

                allDrones.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = this.position.distanceTo(other.position);
                        if (dist < collaborationRange) {
                            // Bonus collaboration pour coordination optimale
                            const efficiency = (collaborationRange - dist) / collaborationRange;
                            this.collaborationScore += efficiency * 0.1;
                        }
                    }
                });

                this.collaborationScore = Math.min(1.0, this.collaborationScore);
            }

            samplePotential(x, y, z, drones) {
                let phi = 0, sigma = 0;
                const testPos = new THREE.Vector3(x, y, z);

                drones.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = testPos.distanceTo(other.position);
                        if (dist > 0.1) {
                            phi += CONFIG.magneticForce / (1.0 + dist * 0.1);
                            sigma += 2.0 / (1.0 + dist * dist * 0.1);
                        }
                    }
                });

                return phi + sigma;
            }

            getExplorationForce() {
                // Pattern de recherche en essaim optimis√© pour for√™t dense
                const pattern = SEARCH_PATTERNS[currentSearchPattern];
                const force = new THREE.Vector3(0, 0, 0);
                const time = Date.now() * 0.001;

                // D√©tection des cibles de scouting √† proximit√©
                const nearbyTargets = this.findNearbyScoutingTargets();
                const nearbyObstacles = this.findNearbyObstacles();

                switch (pattern) {
                    case 'grid':
                        // === BOUSTROPH√âDON OPTIMIS√â ===
                        // Assignation automatique du secteur si pas encore fait
                        if (!this.boustrophedonData.assigned) {
                            this.assignBoustrophedonSector();
                        }

                        // Calcul du point de destination en zigzag
                        const boustTarget = this.getBoustrophedonWaypoint();
                        if (boustTarget) {
                            const targetForce = new THREE.Vector3(
                                boustTarget.x - this.position.x,
                                0,
                                boustTarget.z - this.position.z
                            );
                            const distance = targetForce.length();

                            if (distance < 3) {
                                // Point atteint, passer au suivant
                                this.advanceBoustrophedonProgress();
                            } else {
                                targetForce.normalize().multiplyScalar(3.0);
                                force.add(targetForce);
                            }
                        }
                        break;

                    case 'spiral':
                        // Scouting en spirale autour des zones d'int√©r√™t
                        const spiralRadius = 8 + this.patternStep * 0.8;
                        const spiralAngle = time * 0.4 + this.id * 0.8;
                        const spiralCenter = this.findNearestUnexploredArea();

                        const spiralX = spiralCenter.x + Math.cos(spiralAngle) * spiralRadius;
                        const spiralZ = spiralCenter.z + Math.sin(spiralAngle) * spiralRadius;

                        force.set(spiralX - this.position.x, 0, spiralZ - this.position.z);
                        force.normalize().multiplyScalar(2.0);

                        if (spiralRadius > 25) this.patternStep = 0;
                        else this.patternStep += 0.015;
                        break;

                    case 'boustrophedon':
                        // === BOUSTROPH√âDON PUR (ZIGZAG OPTIMAL) ===
                        if (!this.boustrophedonData.assigned) {
                            this.assignBoustrophedonSector();
                        }

                        const pureTarget = this.getBoustrophedonWaypoint();
                        if (pureTarget) {
                            force.set(
                                pureTarget.x - this.position.x,
                                0,
                                pureTarget.z - this.position.z
                            );
                            const distance = force.length();

                            if (distance < 3) {
                                this.advanceBoustrophedonProgress();
                            } else {
                                force.normalize().multiplyScalar(4.0); // Plus rapide pour couverture pure
                            }
                        }
                        break;

                    case 'random':
                        // Scouting al√©atoire intelligent √©vitant les zones explor√©es
                        if (!this.searchPattern || time - this.lastSearchTime > 3.5) {
                            const unexploredArea = this.findBestUnexploredSector();
                            this.searchPattern = {
                                x: unexploredArea.x + (Math.random() - 0.5) * 10,
                                z: unexploredArea.z + (Math.random() - 0.5) * 10
                            };
                            this.lastSearchTime = time;
                        }

                        if (this.searchPattern) {
                            const dist = Math.sqrt(
                                Math.pow(this.searchPattern.x - this.position.x, 2) +
                                Math.pow(this.searchPattern.z - this.position.z, 2)
                            );

                            if (dist < 6) {
                                this.searchPattern = null; // Zone explor√©e
                            } else {
                                force.set(
                                    this.searchPattern.x - this.position.x,
                                    0,
                                    this.searchPattern.z - this.position.z
                                );
                                force.normalize().multiplyScalar(2.0);
                            }
                        }
                        break;

                    case 'follow_leader':
                        // Suivre le leader le plus proche
                        const leader = this.findNearestLeader();
                        if (leader) {
                            force.set(
                                leader.position.x - this.position.x,
                                0,
                                leader.position.z - this.position.z
                            );
                            force.normalize().multiplyScalar(1.5);
                        }
                        break;

                    case 'coverage':
                        // Couverture maximale par r√©partition intelligente
                        const coverageTarget = this.findOptimalCoveragePosition();
                        if (coverageTarget) {
                            force.set(
                                coverageTarget.x - this.position.x,
                                0,
                                coverageTarget.z - this.position.z
                            );
                            force.normalize().multiplyScalar(2.5);
                        }
                        break;
                }

                // Force d'attraction vers les cibles non d√©couvertes
                if (nearbyTargets.length > 0) {
                    nearbyTargets.forEach(target => {
                        const targetForce = new THREE.Vector3(
                            target.position.x - this.position.x,
                            0,
                            target.position.z - this.position.z
                        );
                        const distance = targetForce.length();
                        if (distance > 0.1) {
                            targetForce.normalize().multiplyScalar(target.value * 0.05);
                            force.add(targetForce);
                        }
                    });
                }

                // √âvitement intelligent des obstacles forestiers
                nearbyObstacles.forEach(obstacle => {
                    const avoidForce = new THREE.Vector3(
                        this.position.x - obstacle.position.x,
                        0,
                        this.position.z - obstacle.position.z
                    );
                    const distance = avoidForce.length();
                    if (distance < obstacle.radius + 5 && distance > 0.1) {
                        avoidForce.normalize().multiplyScalar(10.0 / distance);
                        force.add(avoidForce);
                    }
                });

                return force;
            }

            // === SCOUTING COLLABORATIF OPTIMIS√â ===
            getCollaborativeScoutingForce(allDrones) {
                const force = new THREE.Vector3();
                const scoutingRange = 20; // Port√©e optimis√©e

                // 1. ANTI-REDONDANCE: √âviter les zones d√©j√† scout√©es
                const avoidanceForce = this.calculateRedundancyAvoidance(allDrones);
                force.add(avoidanceForce.multiplyScalar(3.0)); // Priorit√© √©lev√©e

                // 2. ASSIGNMENT OPTIMAL: Secteur d√©di√© par drone
                const sectorForce = this.getOptimalSectorAssignment(allDrones);
                force.add(sectorForce.multiplyScalar(4.0)); // Priorit√© maximale

                // 3. COORDINATION TEMPS R√âEL: Synchronisation des mouvements
                const coordinationForce = this.getRealTimeCoordination(allDrones);
                force.add(coordinationForce.multiplyScalar(2.0));

                // 4. FINISH INCOMPLETE: Terminer les zones partiellement explor√©es
                const completionForce = this.getCompletionPriority();
                force.add(completionForce.multiplyScalar(2.5));

                return force;
            }

            calculateRedundancyAvoidance(allDrones) {
                const avoidanceForce = new THREE.Vector3();
                const redundancyRadius = 15; // Zone de non-redondance

                allDrones.forEach(other => {
                    if (other === this) return;

                    const distance = this.position.distanceTo(other.position);
                    if (distance < redundancyRadius) {
                        // Forte r√©pulsion pour √©viter le double-scouting
                        const repulsion = this.position.clone().sub(other.position);
                        repulsion.y = 0;

                        if (repulsion.length() > 0.1) {
                            repulsion.normalize();
                            const intensity = (redundancyRadius - distance) / redundancyRadius;
                            avoidanceForce.add(repulsion.multiplyScalar(intensity * intensity * 5.0)); // R√©pulsion quadratique
                        }
                    }
                });

                return avoidanceForce;
            }

            getOptimalSectorAssignment(allDrones) {
                const sectorForce = new THREE.Vector3();

                // === ASSIGNMENT DYNAMIQUE TEMPS OPTIMAL ===
                const totalDrones = allDrones.length;

                // Calcul de la grille optimale selon nombre de drones
                const optimalGrid = this.calculateOptimalGridSize(totalDrones);
                const sectorSize = CONFIG.zoneSize / optimalGrid;

                // R√©assignement intelligent bas√© sur l'efficacit√©
                const efficiency = this.calculateMyEfficiency(allDrones);
                const bestSector = this.findMostEfficientSector(allDrones, optimalGrid);

                if (bestSector) {
                    // Force vers le secteur le plus efficace
                    sectorForce.set(
                        bestSector.centerX - this.position.x,
                        0,
                        bestSector.centerZ - this.position.z
                    );

                    // Ajustement de force selon urgence et distance
                    const distanceToSector = sectorForce.length();
                    const urgency = 1.0 - bestSector.completion; // Plus urgent si moins complet
                    const forceMultiplier = Math.min(6.0, urgency * 8.0 + distanceToSector * 0.05);

                    if (distanceToSector > sectorSize * 0.2) {
                        sectorForce.normalize().multiplyScalar(forceMultiplier);
                    } else {
                        // Dans le secteur : scouting local intelligent
                        const localTarget = this.findLocalOptimalTarget(bestSector);
                        if (localTarget) {
                            sectorForce.set(
                                localTarget.x - this.position.x,
                                0,
                                localTarget.z - this.position.z
                            );
                            sectorForce.normalize().multiplyScalar(2.0);
                        }
                    }
                } else {
                    // Fallback : secteur basique mais adaptatif
                    const droneIndex = allDrones.indexOf(this);
                    const adaptiveIndex = (droneIndex + Math.floor(Date.now() / 10000)) % totalDrones;
                    const sectorX = (adaptiveIndex % optimalGrid) - Math.floor(optimalGrid / 2);
                    const sectorZ = Math.floor(adaptiveIndex / optimalGrid) - Math.floor(optimalGrid / 2);

                    const targetSectorX = sectorX * sectorSize;
                    const targetSectorZ = sectorZ * sectorSize;

                    sectorForce.set(
                        targetSectorX - this.position.x,
                        0,
                        targetSectorZ - this.position.z
                    );
                    sectorForce.normalize().multiplyScalar(3.0);
                }

                return sectorForce;
            }

            calculateOptimalGridSize(totalDrones) {
                // Grille optimale selon nombre de drones pour couverture temps minimal
                if (totalDrones <= 4) return 3;       // 3x3 = 9 secteurs pour 1-4 drones
                if (totalDrones <= 9) return 4;       // 4x4 = 16 secteurs pour 5-9 drones  
                if (totalDrones <= 16) return 5;      // 5x5 = 25 secteurs pour 10-16 drones
                if (totalDrones <= 25) return 6;      // 6x6 = 36 secteurs pour 17-25 drones
                return Math.ceil(Math.sqrt(totalDrones)) + 1; // Adaptatif pour plus
            }

            createMesh() {
                this.group = new THREE.Group();

                // === CORPS R√âALISTE DE DRONE ===
                // Corps principal - forme a√©rodynamique
                const bodyGeometry = new THREE.BoxGeometry(
                    this.type.size * 1.2,
                    this.type.size * 0.25,
                    this.type.size * 0.8
                );
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: this.type.color,
                    shininess: 100,
                    specular: 0x444444
                });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.castShadow = true;
                this.group.add(this.body);

                // Cockpit/module central r√©aliste
                const cockpitGeometry = new THREE.SphereGeometry(this.type.size * 0.2, 8, 6);
                const cockpitMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.8
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.y = 0.08;
                cockpit.castShadow = true;
                this.group.add(cockpit);

                // Syst√®me de propulsion selon le type
                this.propellers = [];
                const propCount = this.typeName === 'HEAVY' ? 6 : 4;

                for (let i = 0; i < propCount; i++) {
                    const angle = (i / propCount) * Math.PI * 2;
                    const radius = this.type.size * 0.7;

                    // Moteur
                    const motorGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.15, 6);
                    const motorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    const motor = new THREE.Mesh(motorGeometry, motorMaterial);
                    motor.position.set(
                        Math.cos(angle) * radius,
                        0.1,
                        Math.sin(angle) * radius
                    );
                    this.group.add(motor);

                    // H√©lice avec effet selon la vitesse
                    const propGeometry = new THREE.RingGeometry(0.1, this.type.size * 0.4, 8);
                    const propMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFFFF,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const prop = new THREE.Mesh(propGeometry, propMaterial);
                    prop.position.set(
                        Math.cos(angle) * radius,
                        0.15,
                        Math.sin(angle) * radius
                    );
                    prop.rotation.x = -Math.PI / 2;
                    this.group.add(prop);
                    this.propellers.push(prop);
                }

                // LEDs de statut selon le type
                const ledPositions = [
                    { x: this.type.size * 0.4, z: 0, color: 0xFF0000 },
                    { x: -this.type.size * 0.4, z: 0, color: 0x00FF00 },
                    { x: 0, z: this.type.size * 0.4, color: 0xFFFFFF },
                    { x: 0, z: -this.type.size * 0.4, color: this.type.color }
                ];

                this.leds = [];
                ledPositions.forEach((pos, i) => {
                    const ledGeometry = new THREE.SphereGeometry(0.03, 6, 6);
                    const ledMaterial = new THREE.MeshBasicMaterial({
                        color: pos.color,
                        emissive: pos.color,
                        emissiveIntensity: 0.8
                    });
                    const led = new THREE.Mesh(ledGeometry, ledMaterial);
                    led.position.set(pos.x, 0.12, pos.z);
                    this.group.add(led);
                    this.leds.push(led);
                });

                // Capteurs selon le r√¥le
                if (this.type.role === 'reconnaissance') {
                    // Cam√©ra pour reconnaissance
                    const camGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
                    const camMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                    const camera = new THREE.Mesh(camGeometry, camMaterial);
                    camera.position.y = 0.2;
                    this.group.add(camera);
                }

                if (this.type.role === 'coordination') {
                    // Antenne pour coordination
                    const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 4);
                    const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = 0.25;
                    this.group.add(antenna);
                }

                this.group.position.copy(this.position);

                // S√©curit√© : s'assurer que le groupe est ajout√© √† la sc√®ne
                if (!this.group.parent) {
                    scene.add(this.group);
                }

                // Marquer comme cr√©√© avec succ√®s
                this.meshCreated = true;
            }

            createTrail() {
                const trailGeometry = new THREE.BufferGeometry();
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.6
                });
                this.trail = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(this.trail);
            }

            findMostEfficientSector(allDrones, gridSize) {
                let bestSector = null;
                let bestScore = -1;
                const sectorSize = CONFIG.zoneSize / gridSize;

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const centerX = (i - gridSize / 2) * sectorSize;
                        const centerZ = (j - gridSize / 2) * sectorSize;

                        // Calculer le score d'efficacit√© de ce secteur
                        const completion = this.getSectorCompletion(i, j, gridSize);
                        const droneCount = this.countDronesInSector(centerX, centerZ, sectorSize, allDrones);
                        const distance = Math.sqrt(
                            Math.pow(centerX - this.position.x, 2) +
                            Math.pow(centerZ - this.position.z, 2)
                        );

                        // Score temps optimal : prioriser les secteurs vides et proches
                        const urgencyScore = (1.0 - completion) * 10; // Urgence max pour secteurs vides
                        const proximityScore = Math.max(0, 50 - distance * 0.5); // Plus proche = mieux
                        const congestionPenalty = droneCount * 15; // P√©nalit√© pour embouteillage
                        const distributionBonus = droneCount === 0 ? 20 : 0; // Bonus pour dispersion

                        const totalScore = urgencyScore + proximityScore - congestionPenalty + distributionBonus;

                        if (totalScore > bestScore) {
                            bestScore = totalScore;
                            bestSector = {
                                centerX: centerX,
                                centerZ: centerZ,
                                completion: completion,
                                droneCount: droneCount,
                                score: totalScore,
                                i: i, j: j
                            };
                        }
                    }
                }

                return bestSector;
            }

            calculateMyEfficiency(allDrones) {
                // Efficacit√© personnelle bas√©e sur d√©couvertes et couverture
                const recentDiscoveries = this.countRecentDiscoveries(5000); // 5 secondes
                const coverageContribution = this.calculateCoverageContribution();
                const collaborationFactor = this.getCollaborationFactor(allDrones);

                return (recentDiscoveries * 0.4 + coverageContribution * 0.4 + collaborationFactor * 0.2);
            }

            getSectorCompletion(sectorI, sectorJ, gridSize) {
                // Calcule le pourcentage de completion d'un secteur
                const cellsPerSector = Math.floor(CONFIG.explorationGrid / gridSize);
                let totalCells = 0;
                let completedCells = 0;

                const startI = Math.floor(sectorI * cellsPerSector);
                const endI = Math.min(CONFIG.explorationGrid, startI + cellsPerSector);
                const startJ = Math.floor(sectorJ * cellsPerSector);
                const endJ = Math.min(CONFIG.explorationGrid, startJ + cellsPerSector);

                for (let i = startI; i < endI; i++) {
                    for (let j = startJ; j < endJ; j++) {
                        totalCells++;
                        if (explorationMap && explorationMap[i] && explorationMap[i][j] > 0.6) {
                            completedCells++;
                        }
                    }
                }

                return totalCells > 0 ? completedCells / totalCells : 0;
            }

            countDronesInSector(centerX, centerZ, sectorSize, allDrones) {
                let count = 0;
                const halfSize = sectorSize / 2;

                allDrones.forEach(drone => {
                    if (drone !== this) {
                        const dx = Math.abs(drone.position.x - centerX);
                        const dz = Math.abs(drone.position.z - centerZ);

                        if (dx < halfSize && dz < halfSize) {
                            count++;
                        }
                    }
                });

                return count;
            }

            findLocalOptimalTarget(sector) {
                // Trouve la meilleure cible locale dans un secteur
                const sectorSize = CONFIG.zoneSize / this.calculateOptimalGridSize(drones.length);
                const halfSize = sectorSize / 2;

                // Rechercher les cibles non d√©couvertes dans ce secteur
                let bestTarget = null;
                let bestValue = 0;

                scoutingTargets.forEach(target => {
                    if (!target.discovered) {
                        const dx = Math.abs(target.position.x - sector.centerX);
                        const dz = Math.abs(target.position.z - sector.centerZ);

                        if (dx < halfSize && dz < halfSize) {
                            const distance = this.position.distanceTo(target.position);
                            const score = target.value / (distance + 1);

                            if (score > bestValue) {
                                bestValue = score;
                                bestTarget = target.position;
                            }
                        }
                    }
                });

                // Si pas de cible, chercher une zone peu explor√©e
                if (!bestTarget) {
                    const cellsPerSector = Math.floor(CONFIG.explorationGrid / this.calculateOptimalGridSize(drones.length));
                    let minExploration = 1.0;

                    for (let i = 0; i < cellsPerSector; i++) {
                        for (let j = 0; j < cellsPerSector; j++) {
                            const gridI = Math.floor(sector.i * cellsPerSector + i);
                            const gridJ = Math.floor(sector.j * cellsPerSector + j);

                            if (gridI < CONFIG.explorationGrid && gridJ < CONFIG.explorationGrid) {
                                const exploration = explorationMap[gridI] ? explorationMap[gridI][gridJ] : 0;

                                if (exploration < minExploration) {
                                    minExploration = exploration;
                                    const cellSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                                    bestTarget = new THREE.Vector3(
                                        (gridI - CONFIG.explorationGrid / 2) * cellSize,
                                        0,
                                        (gridJ - CONFIG.explorationGrid / 2) * cellSize
                                    );
                                }
                            }
                        }
                    }
                }

                return bestTarget;
            }

            getRealTimeCoordination(allDrones) {
                const coordForce = new THREE.Vector3();

                // === INTELLIGENCE COLLABORATIVE TEMPS R√âEL ===
                const globalProgress = this.calculateGlobalScoutingProgress(allDrones);
                const myEfficiency = this.calculateMyEfficiency(allDrones);
                const swarmBalance = this.analyzeSwarmBalance(allDrones);

                // ADAPTATION INSTANTAN√âE au nombre de drones
                const droneCountChange = this.detectDroneCountChange(allDrones);
                if (droneCountChange !== 0) {
                    console.log(`üîÑ R√©organisation d√©tect√©e: ${droneCountChange > 0 ? '+' : ''}${droneCountChange} drones`);
                    // Force de redistribution imm√©diate
                    const redistributionForce = this.getRedistributionForce(allDrones);
                    coordForce.add(redistributionForce.multiplyScalar(5.0)); // Priorit√© maximale
                }

                // PHASES ADAPTATIVES INTELLIGENTES
                if (globalProgress < 0.2) {
                    // Phase 1: DISPERSION RAPIDE
                    const disperseForce = this.getUltraFastDispersionForce(allDrones);
                    coordForce.add(disperseForce.multiplyScalar(4.0));

                } else if (globalProgress < 0.6) {
                    // Phase 2: SCOUTING PARALL√àLE COORDONN√â
                    const parallelForce = this.getParallelScoutingForce(allDrones);
                    coordForce.add(parallelForce.multiplyScalar(3.0));

                } else if (globalProgress < 0.85) {
                    // Phase 3: NETTOYAGE COLLABORATIF
                    const cleanupForce = this.getCollaborativeCleanupForce(allDrones);
                    coordForce.add(cleanupForce.multiplyScalar(2.5));

                } else {
                    // Phase 4: FINITION PR√âCISE
                    const finishingForce = this.getPrecisionFinishingForce(allDrones);
                    coordForce.add(finishingForce.multiplyScalar(6.0)); // Force maximale pour finir vite
                }

                // COORDINATION MULTI-DIRECTIONNELLE
                const directionForce = this.getMultiDirectionalForce(allDrones);
                coordForce.add(directionForce.multiplyScalar(2.0));

                // BALANCE DYNAMIQUE DE L'ESSAIM
                if (swarmBalance.tooClusterered) {
                    const antiClusterForce = this.getAntiClusteringForce(allDrones);
                    coordForce.add(antiClusterForce.multiplyScalar(3.5));
                } else if (swarmBalance.tooSpread) {
                    const convergenceForce = this.getConvergenceForce(allDrones);
                    coordForce.add(convergenceForce.multiplyScalar(2.0));
                }

                return coordForce;
            }

            // === NOUVELLES M√âTHODES INTELLIGENCE COLLABORATIVE ===
            detectDroneCountChange(allDrones) {
                if (!this.lastDroneCount) {
                    this.lastDroneCount = allDrones.length;
                    return 0;
                }

                const change = allDrones.length - this.lastDroneCount;
                this.lastDroneCount = allDrones.length;
                return change;
            }

            getRedistributionForce(allDrones) {
                const redistForce = new THREE.Vector3();
                const totalDrones = allDrones.length;

                // Calcul de la nouvelle position optimale selon nouveau nombre de drones
                const newOptimalGrid = this.calculateOptimalGridSize(totalDrones);
                const newSectorSize = CONFIG.zoneSize / newOptimalGrid;

                // Trouver le secteur le moins occup√©
                let bestSector = null;
                let minOccupancy = Infinity;

                for (let i = 0; i < newOptimalGrid; i++) {
                    for (let j = 0; j < newOptimalGrid; j++) {
                        const centerX = (i - newOptimalGrid / 2) * newSectorSize;
                        const centerZ = (j - newOptimalGrid / 2) * newSectorSize;
                        const droneCount = this.countDronesInSector(centerX, centerZ, newSectorSize, allDrones);

                        if (droneCount < minOccupancy) {
                            minOccupancy = droneCount;
                            bestSector = { centerX, centerZ };
                        }
                    }
                }

                if (bestSector) {
                    redistForce.set(
                        bestSector.centerX - this.position.x,
                        0,
                        bestSector.centerZ - this.position.z
                    );
                    redistForce.normalize().multiplyScalar(8.0); // Force √©lev√©e pour redistribution rapide
                }

                return redistForce;
            }

            getUltraFastDispersionForce(allDrones) {
                const disperseForce = new THREE.Vector3();
                const minDistance = CONFIG.zoneSize / (Math.sqrt(allDrones.length) + 1);

                allDrones.forEach(other => {
                    if (other !== this) {
                        const distance = this.position.distanceTo(other.position);
                        if (distance < minDistance) {
                            const repulsion = this.position.clone().sub(other.position);
                            repulsion.y = 0;

                            if (repulsion.length() > 0.1) {
                                repulsion.normalize();
                                const intensity = (minDistance - distance) / minDistance;
                                disperseForce.add(repulsion.multiplyScalar(intensity * 10.0)); // Force tr√®s √©lev√©e
                            }
                        }
                    }
                });

                return disperseForce;
            }

            getParallelScoutingForce(allDrones) {
                const parallelForce = new THREE.Vector3();

                // Direction parall√®le selon ID du drone
                const totalDrones = allDrones.length;
                const myIndex = allDrones.indexOf(this);

                // Cr√©er des "couloirs" parall√®les
                const corridorWidth = CONFIG.zoneSize / totalDrones;
                const myCorridorCenter = (myIndex - totalDrones / 2) * corridorWidth;

                // Direction principale : alternance X et Z selon index
                if (myIndex % 2 === 0) {
                    // Couloirs horizontaux
                    parallelForce.set(
                        this.position.x < 0 ? 3.0 : -3.0, // Aller-retour X
                        0,
                        myCorridorCenter - this.position.z  // Maintenir couloir Z
                    );
                } else {
                    // Couloirs verticaux
                    parallelForce.set(
                        myCorridorCenter - this.position.x,  // Maintenir couloir X
                        0,
                        this.position.z < 0 ? 3.0 : -3.0   // Aller-retour Z
                    );
                }

                return parallelForce.normalize().multiplyScalar(4.0);
            }

            getMultiDirectionalForce(allDrones) {
                const multiDirForce = new THREE.Vector3();
                const myIndex = allDrones.indexOf(this);
                const totalDrones = allDrones.length;

                // R√©partition en 4 quadrants + centre
                const quadrant = myIndex % 5;

                switch (quadrant) {
                    case 0: // Nord-Est
                        multiDirForce.set(1, 0, 1);
                        break;
                    case 1: // Nord-Ouest  
                        multiDirForce.set(-1, 0, 1);
                        break;
                    case 2: // Sud-Est
                        multiDirForce.set(1, 0, -1);
                        break;
                    case 3: // Sud-Ouest
                        multiDirForce.set(-1, 0, -1);
                        break;
                    case 4: // Centre mobile
                        const centerTime = Date.now() * 0.001;
                        multiDirForce.set(
                            Math.cos(centerTime * 0.5),
                            0,
                            Math.sin(centerTime * 0.5)
                        );
                        break;
                }

                // Ajuster selon zones d√©j√† explor√©es
                const unexploredDirection = this.findUnexploredDirection(allDrones);
                if (unexploredDirection) {
                    multiDirForce.add(unexploredDirection.multiplyScalar(0.7));
                }

                return multiDirForce.normalize().multiplyScalar(2.5);
            }

            analyzeSwarmBalance(allDrones) {
                const positions = allDrones.map(d => d.position);

                // Calculer distances moyennes
                let totalDistance = 0;
                let pairCount = 0;

                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        totalDistance += positions[i].distanceTo(positions[j]);
                        pairCount++;
                    }
                }

                const avgDistance = pairCount > 0 ? totalDistance / pairCount : 0;
                const optimalDistance = CONFIG.zoneSize / Math.sqrt(allDrones.length);

                return {
                    avgDistance: avgDistance,
                    optimalDistance: optimalDistance,
                    tooClusterered: avgDistance < optimalDistance * 0.7,
                    tooSpread: avgDistance > optimalDistance * 1.5,
                    balance: avgDistance / optimalDistance
                };
            }

            getCollaborativeCleanupForce(allDrones) {
                const cleanupForce = new THREE.Vector3();

                // Coordination pour nettoyage intelligent des zones partiellement explor√©es
                const incompleteAreas = this.findIncompleteZonesNearby();

                if (incompleteAreas.length > 0) {
                    // Assigner chaque drone √† une zone diff√©rente
                    const myIndex = allDrones.indexOf(this);
                    const targetArea = incompleteAreas[myIndex % incompleteAreas.length];

                    cleanupForce.set(
                        targetArea.position.x - this.position.x,
                        0,
                        targetArea.position.z - this.position.z
                    );
                    cleanupForce.normalize().multiplyScalar(4.0);
                }

                return cleanupForce;
            }

            getPrecisionFinishingForce(allDrones) {
                const finishingForce = new THREE.Vector3();

                // Phase finale : finir les derni√®res zones avec pr√©cision maximale
                let smallestIncompleteArea = null;
                let minSize = Infinity;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        if (explorationMap && explorationMap[i] && explorationMap[i][j] < 0.9) {
                            const cellSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                            const areaSize = (1.0 - explorationMap[i][j]) * cellSize * cellSize;

                            if (areaSize < minSize) {
                                minSize = areaSize;
                                smallestIncompleteArea = new THREE.Vector3(
                                    (i - CONFIG.explorationGrid / 2) * cellSize,
                                    0,
                                    (j - CONFIG.explorationGrid / 2) * cellSize
                                );
                            }
                        }
                    }
                }

                if (smallestIncompleteArea) {
                    finishingForce.set(
                        smallestIncompleteArea.x - this.position.x,
                        0,
                        smallestIncompleteArea.z - this.position.z
                    );
                    finishingForce.normalize().multiplyScalar(7.0); // Force maximale
                }

                return finishingForce;
            }

            getAntiClusteringForce(allDrones) {
                const antiClusterForce = new THREE.Vector3();
                const criticalDistance = CONFIG.zoneSize / (allDrones.length * 0.8);

                allDrones.forEach(other => {
                    if (other !== this) {
                        const distance = this.position.distanceTo(other.position);
                        if (distance < criticalDistance) {
                            const repulsion = this.position.clone().sub(other.position);
                            repulsion.y = 0;

                            if (repulsion.length() > 0.1) {
                                repulsion.normalize();
                                const intensity = (criticalDistance - distance) / criticalDistance;
                                antiClusterForce.add(repulsion.multiplyScalar(intensity * 12.0)); // Force tr√®s √©lev√©e
                            }
                        }
                    }
                });

                return antiClusterForce;
            }

            getConvergenceForce(allDrones) {
                const convergenceForce = new THREE.Vector3();

                // Calcul du centre de masse de l'essaim
                const centerOfMass = new THREE.Vector3();
                allDrones.forEach(drone => {
                    centerOfMass.add(drone.position);
                });
                centerOfMass.divideScalar(allDrones.length);

                // Force vers le centre, mais mod√©r√©e
                convergenceForce.set(
                    centerOfMass.x - this.position.x,
                    0,
                    centerOfMass.z - this.position.z
                );

                const distance = convergenceForce.length();
                if (distance > 0.1) {
                    convergenceForce.normalize().multiplyScalar(Math.min(3.0, distance * 0.1));
                }

                return convergenceForce;
            }

            countRecentDiscoveries(timeWindow) {
                // Compte les d√©couvertes r√©centes pour calculer l'efficacit√©
                const now = Date.now();
                let count = 0;

                scoutingTargets.forEach(target => {
                    if (target.discovered && target.discoveredBy === this.id) {
                        if (now - target.discoveryTime < timeWindow) {
                            count++;
                        }
                    }
                });

                return count;
            }

            calculateCoverageContribution() {
                // Calcule la contribution personnelle √† la couverture
                let contribution = 0;
                const cellSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                const myRadius = this.type.sensorRange;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const cellX = (i - CONFIG.explorationGrid / 2) * cellSize;
                        const cellZ = (j - CONFIG.explorationGrid / 2) * cellSize;
                        const distance = Math.sqrt(
                            Math.pow(cellX - this.position.x, 2) +
                            Math.pow(cellZ - this.position.z, 2)
                        );

                        if (distance < myRadius) {
                            contribution += explorationMap[i] ? explorationMap[i][j] : 0;
                        }
                    }
                }

                return contribution / (CONFIG.explorationGrid * CONFIG.explorationGrid);
            }

            getCollaborationFactor(allDrones) {
                // Mesure la qualit√© de collaboration avec les autres drones
                let collaborationScore = 0;
                const idealDistance = CONFIG.zoneSize / Math.sqrt(allDrones.length);

                allDrones.forEach(other => {
                    if (other !== this) {
                        const distance = this.position.distanceTo(other.position);
                        const distanceScore = Math.max(0, 1.0 - Math.abs(distance - idealDistance) / idealDistance);
                        collaborationScore += distanceScore;
                    }
                });

                return allDrones.length > 1 ? collaborationScore / (allDrones.length - 1) : 1.0;
            }

            getCompletionPriority() {
                const completionForce = new THREE.Vector3();

                // Rechercher les zones partiellement explor√©es proches
                const incompleteZones = this.findIncompleteZonesNearby();

                if (incompleteZones.length > 0) {
                    // Prioriser la zone la plus proche et la moins compl√®te
                    let bestZone = incompleteZones[0];
                    let bestScore = Infinity;

                    incompleteZones.forEach(zone => {
                        const distance = this.position.distanceTo(zone.position);
                        const completion = zone.completion;
                        const score = distance / (1 - completion); // Plus la zone est incompl√®te et proche, meilleur le score

                        if (score < bestScore) {
                            bestScore = score;
                            bestZone = zone;
                        }
                    });

                    completionForce.set(
                        bestZone.position.x - this.position.x,
                        0,
                        bestZone.position.z - this.position.z
                    );
                    completionForce.normalize().multiplyScalar(3.0);
                }

                return completionForce;
            }

            // === M√âTHODES D'OPTIMISATION SCOUTING ===
            calculateGlobalScoutingProgress(allDrones) {
                // Calcul du progr√®s global bas√© sur la grille d'exploration
                let totalCells = CONFIG.explorationGrid * CONFIG.explorationGrid;
                let exploredCells = 0;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        if (explorationMap && explorationMap[i] && explorationMap[i][j] > 0.5) {
                            exploredCells++;
                        }
                    }
                }

                return exploredCells / totalCells;
            }

            getMaxDispersionForce(allDrones) {
                const dispersionForce = new THREE.Vector3();
                const targetDistance = CONFIG.zoneSize / Math.sqrt(allDrones.length);

                // Force pour maximiser la distance avec tous les autres drones
                allDrones.forEach(other => {
                    if (other === this) return;

                    const distance = this.position.distanceTo(other.position);
                    if (distance < targetDistance) {
                        const repulsion = this.position.clone().sub(other.position);
                        repulsion.y = 0;

                        if (repulsion.length() > 0.1) {
                            repulsion.normalize();
                            const intensity = (targetDistance - distance) / targetDistance;
                            dispersionForce.add(repulsion.multiplyScalar(intensity * 4.0));
                        }
                    }
                });

                return dispersionForce;
            }

            getSystematicScoutingForce() {
                const systematicForce = new THREE.Vector3();

                // Mouvement syst√©matique en spirale ou grille
                if (!this.systematicPattern) {
                    this.systematicPattern = {
                        type: 'spiral',
                        center: this.position.clone(),
                        radius: 5,
                        angle: 0,
                        expanding: true
                    };
                }

                const pattern = this.systematicPattern;

                if (pattern.type === 'spiral') {
                    const targetX = pattern.center.x + Math.cos(pattern.angle) * pattern.radius;
                    const targetZ = pattern.center.z + Math.sin(pattern.angle) * pattern.radius;

                    systematicForce.set(
                        targetX - this.position.x,
                        0,
                        targetZ - this.position.z
                    );

                    // Avancer dans la spirale
                    pattern.angle += 0.2;
                    if (pattern.expanding && pattern.radius < 30) {
                        pattern.radius += 0.1;
                    } else if (pattern.radius >= 30) {
                        pattern.expanding = false;
                        pattern.radius -= 0.1;
                    }

                    if (pattern.radius <= 5) {
                        pattern.expanding = true;
                    }
                }

                return systematicForce.normalize().multiplyScalar(2.0);
            }

            getCleanupScoutingForce(allDrones) {
                const cleanupForce = new THREE.Vector3();

                // Rechercher les petites zones non explor√©es
                const missedAreas = this.findMissedScoutingAreas();

                if (missedAreas.length > 0) {
                    // Aller vers la zone manqu√©e la plus proche
                    let closestArea = missedAreas[0];
                    let minDistance = this.position.distanceTo(closestArea.position);

                    missedAreas.forEach(area => {
                        const dist = this.position.distanceTo(area.position);
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestArea = area;
                        }
                    });

                    cleanupForce.set(
                        closestArea.position.x - this.position.x,
                        0,
                        closestArea.position.z - this.position.z
                    );
                    cleanupForce.normalize().multiplyScalar(3.5);
                }

                return cleanupForce;
            }

            findIncompleteZonesNearby() {
                const incompleteZones = [];
                const searchRadius = 40;
                const gridCellSize = CONFIG.zoneSize / CONFIG.explorationGrid;

                // Chercher dans les cellules proches
                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const cellX = (i - CONFIG.explorationGrid / 2) * gridCellSize;
                        const cellZ = (j - CONFIG.explorationGrid / 2) * gridCellSize;
                        const cellPos = new THREE.Vector3(cellX, 0, cellZ);

                        const distance = this.position.distanceTo(cellPos);

                        if (distance < searchRadius && explorationMap && explorationMap[i] && explorationMap[i][j] < 0.8) {
                            incompleteZones.push({
                                position: cellPos,
                                completion: explorationMap[i][j],
                                distance: distance
                            });
                        }
                    }
                }

                return incompleteZones;
            }

            findMissedScoutingAreas() {
                const missedAreas = [];
                const gridCellSize = CONFIG.zoneSize / CONFIG.explorationGrid;

                // Identifier les cellules totalement non explor√©es
                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        if (explorationMap && explorationMap[i] && explorationMap[i][j] < 0.1) {
                            const cellX = (i - CONFIG.explorationGrid / 2) * gridCellSize;
                            const cellZ = (j - CONFIG.explorationGrid / 2) * gridCellSize;

                            missedAreas.push({
                                position: new THREE.Vector3(cellX, 0, cellZ),
                                completion: explorationMap[i][j]
                            });
                        }
                    }
                }

                return missedAreas;
            }

            findUnexploredDirection(allDrones) {
                // Cherche la direction avec le moins de drones dans un rayon donn√©
                const directions = [
                    new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                    new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
                    new THREE.Vector3(1, 0, 1).normalize(), new THREE.Vector3(-1, 0, 1).normalize(),
                    new THREE.Vector3(1, 0, -1).normalize(), new THREE.Vector3(-1, 0, -1).normalize()
                ];

                let bestDirection = null;
                let minDroneCount = Infinity;

                directions.forEach(dir => {
                    const testPos = this.position.clone().add(dir.clone().multiplyScalar(20));
                    let droneCount = 0;

                    allDrones.forEach(other => {
                        if (other !== this && testPos.distanceTo(other.position) < 15) {
                            droneCount++;
                        }
                    });

                    if (droneCount < minDroneCount) {
                        minDroneCount = droneCount;
                        bestDirection = dir.clone();
                    }
                });

                return bestDirection;
            }

            getLeadershipGuidance(allDrones) {
                // Le drone coordinateur guide l'essaim vers les zones prioritaires
                const guidance = new THREE.Vector3();
                const centerOfMass = new THREE.Vector3();
                let count = 0;

                // Calculer le centre de l'essaim
                allDrones.forEach(drone => {
                    centerOfMass.add(drone.position);
                    count++;
                });

                if (count > 0) {
                    centerOfMass.divideScalar(count);

                    // Guider l'essaim vers l'avant dans la recherche
                    const searchDirection = new THREE.Vector3(1, 0, 0); // Direction principale
                    guidance.add(searchDirection.multiplyScalar(1.2));
                }

                return guidance;
            }

            getFollowLeaderGuidance(allDrones) {
                // Les scouts suivent les directives du coordinateur
                const guidance = new THREE.Vector3();

                // Trouver le drone coordinateur le plus proche
                let nearestLeader = null;
                let minDistance = Infinity;

                allDrones.forEach(drone => {
                    if (drone.type.role === 'coordination') {
                        const distance = this.position.distanceTo(drone.position);
                        if (distance < minDistance && distance < 30) {
                            minDistance = distance;
                            nearestLeader = drone;
                        }
                    }
                });

                if (nearestLeader) {
                    // Suivre la direction du leader avec un d√©calage
                    const leaderDirection = nearestLeader.velocity.clone().normalize();
                    guidance.add(leaderDirection.multiplyScalar(0.8));
                }

                return guidance;
            }

            reassignBoustrophedonSector() {
                // Trouve une ligne non encore assign√©e ou incompl√®te
                const totalRows = CONFIG.explorationGrid;
                let bestRow = -1;
                let minCompletion = Infinity;

                for (let row = 0; row < totalRows; row++) {
                    // Calcul du taux de compl√©tion de la ligne
                    let completion = 0;
                    for (let col = 0; col < CONFIG.explorationGrid; col++) {
                        completion += explorationMap[col][row];
                    }
                    completion /= CONFIG.explorationGrid;

                    if (completion < minCompletion) {
                        minCompletion = completion;
                        bestRow = row;
                    }
                }

                if (bestRow !== -1) {
                    this.boustrophedonData.row = bestRow;
                    this.boustrophedonData.direction = (bestRow % 2 === 0) ? 1 : -1;
                    this.boustrophedonData.progress = minCompletion * CONFIG.explorationGrid; // Reprendre o√π c'est arr√™t√©
                    this.boustrophedonData.assigned = true;
                    this.boustrophedonData.completed = false;

                    console.log(`üîÑ Drone ${this.id} r√©assign√© √† la ligne ${bestRow} (${(minCompletion * 100).toFixed(1)}% compl√®te)`);
                }
            }

            checkPathClearance(target) {
                // V√©rification simple du chemin vers la cible
                const directionToTarget = new THREE.Vector3(
                    target.x - this.position.x,
                    0,
                    target.z - this.position.z
                ).normalize();

                // V√©rifier s'il y a des obstacles majeurs sur le chemin
                for (let step = 1; step <= 5; step++) {
                    const checkPoint = this.position.clone().add(
                        directionToTarget.clone().multiplyScalar(step * 3)
                    );

                    // V√©rifier collision avec arbres
                    for (let tree of trees) {
                        const distToTree = Math.sqrt(
                            Math.pow(checkPoint.x - tree.position.x, 2) +
                            Math.pow(checkPoint.z - tree.position.z, 2)
                        );
                        if (distToTree < tree.radius + 2) {
                            return false; // Chemin bloqu√©
                        }
                    }
                }
                return true; // Chemin libre
            }

            findAlternateRouteAroundObstacles(target) {
                // Trouve un chemin alternatif en contournant les obstacles
                const angles = [Math.PI / 4, -Math.PI / 4, Math.PI / 2, -Math.PI / 2]; // D√©viations possibles
                const baseDirection = new THREE.Vector3(
                    target.x - this.position.x,
                    0,
                    target.z - this.position.z
                ).normalize();

                for (let angle of angles) {
                    const rotatedDirection = new THREE.Vector3(
                        baseDirection.x * Math.cos(angle) - baseDirection.z * Math.sin(angle),
                        0,
                        baseDirection.x * Math.sin(angle) + baseDirection.z * Math.cos(angle)
                    );

                    const alternateTarget = this.position.clone().add(
                        rotatedDirection.multiplyScalar(10)
                    );

                    if (this.checkPathClearance(alternateTarget)) {
                        return alternateTarget;
                    }
                }

                return target; // Si aucune alternative, garder la cible originale
            }

            // === FONCTIONS BOUSTROPH√âDON OPTIMIS√âES SCOUTING COLLABORATIF ===
            assignBoustrophedonSector() {
                // Assignation intelligente des secteurs pour scouting collaboratif
                const totalRows = CONFIG.explorationGrid;
                this.boustrophedonData.row = this.id % totalRows;
                this.boustrophedonData.direction = (this.boustrophedonData.row % 2 === 0) ? 1 : -1; // Alternance zigzag
                this.boustrophedonData.progress = 0;
                this.boustrophedonData.assigned = true;

                // Espacement collaboratif : 8-12m entre lignes pour scouting niveau troncs
                this.boustrophedonData.sectorWidth = 10; // 10m espacement pour scouting collaboratif
                this.boustrophedonData.sectorHeight = 10; // M√™me espacement pour coordination

                console.log(`üéØ Drone ${this.id} assign√© au scouting collaboratif ligne ${this.boustrophedonData.row}, direction: ${this.boustrophedonData.direction === 1 ? '‚Üí' : '‚Üê'}, espacement: 10m`);
            }

            getBoustrophedonWaypoint() {
                const data = this.boustrophedonData;
                if (!data.assigned || data.completed) return null;

                const totalCols = CONFIG.explorationGrid;
                const halfZone = CONFIG.zoneSize / 2;

                // Calcul de la position actuelle dans la grille
                let currentCol = Math.floor(data.progress);

                // Si direction n√©gative (ligne impaire), inverser la colonne
                if (data.direction === -1) {
                    currentCol = totalCols - 1 - currentCol;
                }

                // V√©rifier si la ligne est termin√©e
                if (Math.floor(data.progress) >= totalCols) {
                    data.completed = true;
                    console.log(`‚úÖ Drone ${this.id} a termin√© sa ligne boustroph√©don`);
                    return null;
                }

                // Calcul des coordonn√©es monde
                const x = (currentCol - totalCols / 2 + 0.5) * data.sectorWidth;
                const z = (data.row - totalCols / 2 + 0.5) * data.sectorHeight;

                return { x, z };
            }

            advanceBoustrophedonProgress() {
                this.boustrophedonData.progress += 1;

                // Marquer la zone comme explor√©e dans la grille globale
                const totalCols = CONFIG.explorationGrid;
                let currentCol = Math.floor(this.boustrophedonData.progress - 1);

                if (this.boustrophedonData.direction === -1) {
                    currentCol = totalCols - 1 - currentCol;
                }

                if (currentCol >= 0 && currentCol < totalCols &&
                    this.boustrophedonData.row >= 0 && this.boustrophedonData.row < totalCols) {
                    explorationMap[currentCol][this.boustrophedonData.row] = 1.0; // Zone compl√®tement explor√©e
                }
            }

            // Nouvelles m√©thodes de scouting intelligent am√©lior√©es
            findNearbyScoutingTargets() {
                return scoutingTargets.filter(target => {
                    if (target.discovered) return false;
                    const distance = this.position.distanceTo(target.position);
                    // Port√©e adapt√©e au type de drone et conditions de visibilit√©
                    const adaptedRange = this.type.sensorRange * (this.type.role === 'reconnaissance' ? 1.2 : 1.0);
                    const altitudeFactor = Math.max(0.7, 1.0 - (this.position.y - target.position.y) * 0.02);
                    return distance < adaptedRange * altitudeFactor;
                }).sort((a, b) => {
                    const distA = this.position.distanceTo(a.position);
                    const distB = this.position.distanceTo(b.position);
                    // Priorisation par valeur et distance
                    const scoreA = a.value / (distA + 1);
                    const scoreB = b.value / (distB + 1);
                    return scoreB - scoreA;
                });
            }

            findNearbyObstacles() {
                return forestObstacles.filter(obstacle => {
                    const distance = this.position.distanceTo(obstacle.position);
                    return distance < obstacle.radius + 15;
                });
            }

            findNearestUnexploredArea() {
                let bestArea = { x: 0, z: 0 };
                let minExploration = Infinity;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const exploration = explorationMap[i][j];
                        if (exploration < minExploration) {
                            minExploration = exploration;
                            const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                            bestArea.x = (i - CONFIG.explorationGrid / 2 + 0.5) * gridSize;
                            bestArea.z = (j - CONFIG.explorationGrid / 2 + 0.5) * gridSize;
                        }
                    }
                }

                return bestArea;
            }

            findBestUnexploredSector() {
                const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                let bestSector = { x: 0, z: 0 };
                let bestScore = -Infinity;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const sectorX = (i - CONFIG.explorationGrid / 2 + 0.5) * sectorSize;
                        const sectorZ = (j - CONFIG.explorationGrid / 2 + 0.5) * sectorSize;
                        const distance = Math.sqrt(
                            Math.pow(sectorX - this.position.x, 2) +
                            Math.pow(sectorZ - this.position.z, 2)
                        );

                        const exploration = explorationMap[i][j];
                        const score = (1 - exploration) / (distance + 5) * 100;

                        if (score > bestScore) {
                            bestScore = score;
                            bestSector = { x: sectorX, z: sectorZ };
                        }
                    }
                }

                return bestSector;
            }

            findHighestPriorityTarget() {
                const undiscoveredTargets = scoutingTargets.filter(t => !t.discovered);
                if (undiscoveredTargets.length === 0) return null;

                return undiscoveredTargets.reduce((best, current) => {
                    const currentDist = this.position.distanceTo(current.position);
                    const bestDist = this.position.distanceTo(best.position);
                    const currentScore = current.value / (currentDist + 1);
                    const bestScore = best.value / (bestDist + 1);
                    return currentScore > bestScore ? current : best;
                }).position;
            }

            findOptimalScoutingSector() {
                const sectorSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                let bestSector = null;
                let bestScore = -Infinity;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const sectorX = (i - CONFIG.explorationGrid / 2 + 0.5) * sectorSize;
                        const sectorZ = (j - CONFIG.explorationGrid / 2 + 0.5) * sectorSize;
                        const distance = Math.sqrt(
                            Math.pow(sectorX - this.position.x, 2) +
                            Math.pow(sectorZ - this.position.z, 2)
                        );

                        const exploration = explorationMap[i][j];
                        const nearbyTargets = scoutingTargets.filter(target => {
                            const targetDist = Math.sqrt(
                                Math.pow(target.position.x - sectorX, 2) +
                                Math.pow(target.position.z - sectorZ, 2)
                            );
                            return targetDist < 15 && !target.discovered;
                        }).length;

                        // Score bas√© sur l'exploration, distance et cibles potentielles
                        const explorationScore = (1 - exploration) * 50;
                        const distanceScore = 20 / (distance + 1);
                        const targetScore = nearbyTargets * 30;
                        const totalScore = explorationScore + distanceScore + targetScore;

                        if (totalScore > bestScore) {
                            bestScore = totalScore;
                            bestSector = { x: sectorX, z: sectorZ };
                        }
                    }
                }

                return bestSector;
            }

            getPatternForce(time, allDrones) {
                const force = new THREE.Vector3(0, 0, 0);

                // Forces sp√©cifiques selon le r√¥le du drone
                switch (this.type.role) {
                    case 'exploration':
                        // Scout : mouvements rapides et al√©atoires
                        force.set(
                            Math.sin(time * 0.8 + this.id) * 3,
                            Math.sin(time * 0.2 + this.id) * 0.5,
                            Math.cos(time * 0.6 + this.id) * 3
                        );
                        break;

                    case 'transport':
                        // Heavy : mouvements plus lents et stables
                        force.set(
                            Math.sin(time * 0.3 + this.id) * 1.5,
                            Math.sin(time * 0.1 + this.id) * 0.2,
                            Math.cos(time * 0.2 + this.id) * 1.5
                        );
                        break;

                    case 'reconnaissance':
                        // Stealth : mouvements furtifs en p√©riph√©rie
                        const perimeterAngle = time * 0.2 + this.id;
                        const perimeterRadius = CONFIG.zoneSize * 0.4;
                        force.set(
                            Math.cos(perimeterAngle) * perimeterRadius - this.position.x,
                            0,
                            Math.sin(perimeterAngle) * perimeterRadius - this.position.z
                        );
                        force.normalize().multiplyScalar(0.8);
                        break;

                    case 'coordination':
                        // Leader : position centrale pour coordination
                        const center = new THREE.Vector3(0, 15, 0);
                        force.copy(center.sub(this.position)).normalize().multiplyScalar(1.2);

                        // Oscillation pour rester mobile
                        force.add(new THREE.Vector3(
                            Math.sin(time * 0.4) * 2,
                            0,
                            Math.cos(time * 0.4) * 2
                        ));
                        break;
                }

                return force;
            }

            updateVisual(time) {
                // Mise √† jour de la position avec v√©rification de validit√©
                if (this.group && this.position) {
                    this.group.position.copy(this.position);

                    // S'assurer que le groupe reste visible
                    this.group.visible = true;

                    // Animation des h√©lices selon la vitesse
                    if (this.propellers && this.propellers.length > 0) {
                        const speed = this.velocity.length();
                        const rotationSpeed = speed * 0.5 + 0.2;

                        this.propellers.forEach((prop, index) => {
                            if (prop.rotation) {
                                // Rotation diff√©rentielle pour r√©alisme
                                const direction = (index % 2 === 0) ? 1 : -1;
                                prop.rotation.y += rotationSpeed * direction;

                                // Effet blur selon la vitesse
                                if (prop.material && prop.material.opacity !== undefined) {
                                    prop.material.opacity = 0.15 + Math.min(0.35, speed * 0.1);
                                }
                            }
                        });
                    }

                    // Animation des LEDs selon l'√©tat du drone
                    if (this.leds && this.leds.length > 0) {
                        const pulseSpeed = 2.0 + this.intelligence * 0.1;
                        const phase = time * pulseSpeed;

                        this.leds.forEach((led, index) => {
                            if (led.material && led.material.emissiveIntensity !== undefined) {
                                // Pulsation bas√©e sur l'intelligence DIAMANTS
                                const baseIntensity = 0.6 + this.intelligence * 0.1;
                                const pulse = Math.sin(phase + index * Math.PI / 2) * 0.3;
                                led.material.emissiveIntensity = baseIntensity + pulse;

                                // LED centrale clignote selon le pattern de recherche
                                if (index === 4) { // LED centrale status
                                    const patternPulse = Math.sin(time * 4) * 0.5 + 0.5;
                                    led.material.emissiveIntensity = 0.8 + patternPulse * 0.7;
                                }
                            }
                        });
                    }

                    // Animation de l'aura DIAMANTS
                    if (this.aura && this.aura.material) {
                        const intelligence = this.intelligence || 0;
                        const emergence = this.emergence || 0;

                        // Intensit√© bas√©e sur l'intelligence
                        const baseOpacity = 0.05 + Math.min(0.15, intelligence * 0.01);
                        const emergencePulse = Math.sin(time * 3) * 0.05;
                        this.aura.material.opacity = baseOpacity + emergencePulse;

                        // Rotation lente de l'aura
                        this.aura.rotation.y += 0.01;

                        // Taille dynamique selon l'√©mergence
                        const scale = 1.0 + emergence * 0.02;
                        this.aura.scale.setScalar(scale);
                    }

                    // Orientation dynamique selon la vitesse
                    if (this.velocity.lengthSq() > 0.01) {
                        const direction = this.velocity.clone().normalize();
                        const targetRotation = Math.atan2(direction.x, direction.z);

                        // Rotation lisse vers la direction de mouvement
                        const currentRotation = this.group.rotation.y;
                        let deltaRotation = targetRotation - currentRotation;

                        // Normaliser l'angle
                        while (deltaRotation > Math.PI) deltaRotation -= 2 * Math.PI;
                        while (deltaRotation < -Math.PI) deltaRotation += 2 * Math.PI;

                        this.group.rotation.y += deltaRotation * 0.1; // Rotation progressive

                        // Inclinaison selon le changement de direction
                        const lateralForce = this.velocity.x;
                        this.group.rotation.z = -lateralForce * 0.2; // Banking

                        // Inclinaison avant/arri√®re selon l'acc√©l√©ration
                        const forwardForce = this.velocity.z;
                        this.group.rotation.x = forwardForce * 0.1;
                    }

                    // Effet de vibration subtile pour simulation de moteurs
                    if (this.velocity.lengthSq() > 0.1) {
                        const vibration = 0.02;
                        this.group.position.x += (Math.random() - 0.5) * vibration;
                        this.group.position.y += (Math.random() - 0.5) * vibration * 0.5;
                        this.group.position.z += (Math.random() - 0.5) * vibration;
                    }

                    // Animation des bras de moteurs selon les vibrations
                    if (this.motorArms && this.motorArms.length > 0) {
                        const vibrationIntensity = this.velocity.length() * 0.02;
                        this.motorArms.forEach((arm, index) => {
                            if (arm.rotation) {
                                arm.rotation.z += Math.sin(time * 10 + index) * vibrationIntensity;
                            }
                        });
                    }

                    // Effet de tra√Æn√©e √©nerg√©tique DIAMANTS
                    if (this.intelligence > 5.0) {
                        // Particules √©nerg√©tiques pour haute intelligence
                        const particleCount = Math.floor(this.intelligence / 10);
                        for (let i = 0; i < Math.min(particleCount, 3); i++) {
                            this.createEnergyParticle(time + i * 0.1);
                        }
                    }
                }

                // Mise √† jour de la tra√Æn√©e
                this.updateTrail();
            }

            createEnergyParticle(time) {
                // Cr√©ation d'une particule d'√©nergie DIAMANTS
                const particleGeometry = new THREE.SphereGeometry(0.02, 6, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: this.type.color,
                    emissive: this.type.color,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.7
                });

                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(this.position);
                particle.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.5
                ));

                scene.add(particle);

                // Animation de dispersion de la particule
                const startTime = time;
                const duration = 1.0 + Math.random() * 0.5;

                const animateParticle = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = elapsed / duration;

                    if (progress < 1.0 && particle.parent) {
                        particle.position.y += 0.02;
                        particle.material.opacity = 0.7 * (1.0 - progress);
                        particle.scale.setScalar(1.0 + progress * 0.5);

                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                };

                requestAnimationFrame(animateParticle);
            }

            updateTrail() {
                // Mise √† jour de la tra√Æn√©e avec v√©rification
                if (this.position && isFinite(this.position.x) && isFinite(this.position.y) && isFinite(this.position.z)) {
                    this.trailPoints.push(this.position.clone());
                    if (this.trailPoints.length > 15) { // R√©duction des points pour performance
                        this.trailPoints.shift();
                    }

                    if (this.trailPoints.length > 1 && this.trail) {
                        try {
                            this.trail.geometry.setFromPoints(this.trailPoints);
                            this.trail.material.opacity = Math.max(0.2, 0.4 * (this.intelligence * 0.1 + 0.1));
                            this.trail.visible = true;
                        } catch (error) {
                            console.warn('Erreur trail drone', this.id, error);
                        }
                    }
                }
            }

            // Nouvelle fonction pour assurer l'int√©grit√© du mesh
            ensureMeshIntegrity() {
                if (!this.group || !this.group.parent) {
                    console.log(`üîß Recr√©ation du mesh pour drone ${this.id}`);
                    this.createMesh();
                }

                // V√©rifier que tous les composants sont pr√©sents
                if (!this.body || !this.leds || this.leds.length === 0) {
                    console.log(`üîß Reconstruction des composants pour drone ${this.id}`);
                    this.createMesh();
                }
            }

            destroy() {
                // Nettoyage s√©curis√© du drone
                if (this.group && this.group.parent) {
                    this.group.parent.remove(this.group);
                }
                if (this.trail && this.trail.parent) {
                    this.trail.parent.remove(this.trail);
                }

                // Lib√©ration explicite de la m√©moire
                if (this.group) {
                    this.group.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }

                // R√©initialisation des r√©f√©rences
                this.group = null;
                this.trail = null;
                this.body = null;
                this.leds = [];
                this.propellers = [];
                this.trailPoints = [];
                this.meshCreated = false;
            }

            // === FONCTIONS MANQUANTES POUR LES PATTERNS ===
            findNearestLeader() {
                let nearestLeader = null;
                let minDistance = Infinity;

                drones.forEach(drone => {
                    if (drone.id !== this.id && drone.type.role === 'coordination') {
                        const distance = this.position.distanceTo(drone.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestLeader = drone;
                        }
                    }
                });

                return nearestLeader;
            }

            findOptimalCoveragePosition() {
                // Trouve la position optimale pour maximiser la couverture
                let bestPosition = null;
                let bestScore = -Infinity;

                const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;

                for (let i = 0; i < CONFIG.explorationGrid; i++) {
                    for (let j = 0; j < CONFIG.explorationGrid; j++) {
                        const x = (i - CONFIG.explorationGrid / 2 + 0.5) * gridSize;
                        const z = (j - CONFIG.explorationGrid / 2 + 0.5) * gridSize;

                        // √âviter les zones d√©j√† bien couvertes
                        const exploration = explorationMap[i][j];
                        if (exploration > 0.8) continue;

                        // Calculer la distance aux autres drones
                        let minDroneDistance = Infinity;
                        drones.forEach(drone => {
                            if (drone.id !== this.id) {
                                const dist = Math.sqrt(
                                    Math.pow(x - drone.position.x, 2) +
                                    Math.pow(z - drone.position.z, 2)
                                );
                                minDroneDistance = Math.min(minDroneDistance, dist);
                            }
                        });

                        // Score bas√© sur exploration faible et distance aux autres drones
                        const score = (1 - exploration) * 50 + Math.min(minDroneDistance, 20) * 2;

                        if (score > bestScore) {
                            bestScore = score;
                            bestPosition = { x, z };
                        }
                    }
                }

                return bestPosition || { x: 0, z: 0 };
            }
        }

        // ===== SWARM MANAGEMENT =====
        let drones = [];
        let explorationMap = Array(CONFIG.explorationGrid).fill().map(() => Array(CONFIG.explorationGrid).fill(0));

        function toggleSwarm() {
            isRunning = !isRunning;
            if (isRunning && drones.length === 0) {
                initSwarm();
            }
            document.querySelector('.btn').textContent = isRunning ? '‚è∏Ô∏è PAUSE' : 'üöÄ START WAHOO';
        }

        function initSwarm() {
            // Cr√©er un m√©lange √©quilibr√© de types de drones
            const typeNames = Object.keys(DRONE_TYPES);

            for (let i = 0; i < 8; i++) {
                // Distribution cyclique des types
                const typeIndex = i % typeNames.length;
                const typeName = typeNames[typeIndex];

                const angle = (i / 8) * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = 2 + Math.random() * 1; // Altitude ultra-basse r√©aliste

                const drone = new CrazyflieWahoo(i, x, z, typeName);
                // Position initiale d√©finie dans le constructeur - AUCUNE t√©l√©portation post-cr√©ation
                drones.push(drone);
            }

            // ACTIVATION FORCE DE L'INTELLIGENCE COLLECTIVE
            drones.forEach(drone => {
                drone.initializeCollectiveIntelligence();
                // Force l'expertise imm√©diate pour activit√© visible
                drone.episodicMemory.expertiseAreas.add(drone.specialization);
                drone.episodicMemory.expertise = 3.0; // Expertise initiale √©lev√©e
                drone.episodicMemory.collaborationScore = 1.5; // Collaboration active
            });

            startTime = Date.now();
            console.log('üöÄ WAHOO Swarm initialis√© avec', drones.length, 'drones sp√©cialis√©s + Intelligence Collective ACTIVE');
        }

        function addDrone() {
            // AJOUT ILLIMIT√â DE DRONES avec intelligence adaptive

            // Choisir un type de drone intelligent selon le besoin
            const typeNames = Object.keys(DRONE_TYPES);
            let selectedType = typeNames[Math.floor(Math.random() * typeNames.length)];

            // Intelligence de s√©lection selon nombre actuel
            const currentCount = drones.length;
            if (currentCount % 4 === 0) selectedType = 'SCOUT';      // 25% scouts
            else if (currentCount % 4 === 1) selectedType = 'STEALTH';   // 25% furtifs
            else if (currentCount % 8 === 2) selectedType = 'LEADER';    // 12.5% leaders
            else if (currentCount % 8 === 6) selectedType = 'HEAVY';     // 12.5% lourds

            // Position d'apparition intelligente
            const optimalGridSize = Math.ceil(Math.sqrt(currentCount + 1)) + 1;
            const sectorSize = CONFIG.zoneSize / optimalGridSize;

            // Trouver la position la moins occup√©e
            let bestPosition = { x: 0, z: 0 };
            let minDroneCount = Infinity;

            for (let i = 0; i < optimalGridSize; i++) {
                for (let j = 0; j < optimalGridSize; j++) {
                    const centerX = (i - optimalGridSize / 2) * sectorSize;
                    const centerZ = (j - optimalGridSize / 2) * sectorSize;

                    // Compter les drones dans cette zone
                    let localDroneCount = 0;
                    drones.forEach(drone => {
                        const dist = Math.sqrt(
                            Math.pow(drone.position.x - centerX, 2) +
                            Math.pow(drone.position.z - centerZ, 2)
                        );
                        if (dist < sectorSize * 0.8) localDroneCount++;
                    });

                    if (localDroneCount < minDroneCount) {
                        minDroneCount = localDroneCount;
                        bestPosition = {
                            x: centerX + (Math.random() - 0.5) * sectorSize * 0.5,
                            z: centerZ + (Math.random() - 0.5) * sectorSize * 0.5
                        };
                    }
                }
            }

            const drone = new CrazyflieWahoo(drones.length, bestPosition.x, bestPosition.z, selectedType);
            // ACTIVATION INTELLIGENCE COLLECTIVE IMM√âDIATE
            drone.initializeCollectiveIntelligence();
            drone.episodicMemory.expertiseAreas.add(drone.specialization);
            drone.episodicMemory.expertise = 2.0 + Math.random() * 2.0; // Expertise variable
            drone.episodicMemory.collaborationScore = 1.0 + Math.random(); // Collaboration active

            drones.push(drone);

            console.log(`üöÅ Drone ${DRONE_TYPES[selectedType].name} #${drones.length} ajout√© avec Intelligence Collective √† (${bestPosition.x.toFixed(1)}, ${bestPosition.z.toFixed(1)}) - Total: ${drones.length} drones`);

            // Notification de r√©organisation pour tous les drones
            drones.forEach(d => {
                if (d.lastDroneCount) {
                    d.lastDroneCount = drones.length - 1; // Forcer la d√©tection du changement
                }
            });
        }

        function changePattern() {
            currentSearchPattern = (currentSearchPattern + 1) % SEARCH_PATTERNS.length;
            const newPattern = SEARCH_PATTERNS[currentSearchPattern];
            console.log('üåü Nouveau pattern de recherche:', newPattern);

            // Mettre √† jour l'affichage du pattern
            if (document.getElementById('currentPattern')) {
                document.getElementById('currentPattern').textContent = newPattern;
            }

            // R√©initialiser les donn√©es sp√©cifiques aux patterns
            if (newPattern === 'grid' || newPattern === 'boustrophedon' || newPattern === 'coverage') {
                drones.forEach(drone => {
                    // R√©initialisation du boustroph√©don
                    if (drone.boustrophedonData) {
                        drone.boustrophedonData.assigned = false;
                        drone.boustrophedonData.completed = false;
                        drone.boustrophedonData.progress = 0;
                    }

                    // Anciens syst√®mes
                    if (drone.explorationGrid) {
                        drone.explorationGrid = new Set();
                    }
                    drone.currentTarget = null;
                    drone.gridIndex = 0;
                });

                // R√©initialiser la grille d'exploration
                if (typeof explorationMap !== 'undefined') {
                    explorationMap = Array(CONFIG.explorationGrid).fill().map(() => Array(CONFIG.explorationGrid).fill(0));
                }

                console.log('üîÑ Syst√®me de pattern r√©initialis√© pour tous les drones');
            }

            // Forcer la r√©organisation de l'essaim selon le nouveau pattern
            drones.forEach(drone => {
                if (drone.lastDroneCount) {
                    drone.lastDroneCount = -1; // Forcer la d√©tection du changement
                }
                // R√©initialiser les cibles d'exploration
                drone.explorationTarget = null;
                drone.currentTarget = null;
            });

            console.log(`‚úÖ Pattern chang√© vers: ${newPattern} - ${drones.length} drones r√©organis√©s`);
        }

        function resetSwarm() {
            drones.forEach(drone => drone.destroy());
            drones = [];
            if (typeof explorationMap !== 'undefined') {
                explorationMap = Array(CONFIG.explorationGrid).fill().map(() => Array(CONFIG.explorationGrid).fill(0));
            }
            if (isRunning) {
                initSwarm();
            }
        }

        // === FONCTIONS UTILITAIRES GLOBALES ===

        function toggleMinimap() {
            showMinimap = !showMinimap;
            document.getElementById('minimap').style.display = showMinimap ? 'block' : 'none';
        }

        // ===== METRICS CALCULATION OPTIMIS√â INTELLIGENCE COLLECTIVE =====
        function updateMetrics() {
            if (drones.length === 0) return;

            // M√©triques individuelles classiques
            const totalIntelligence = drones.reduce((sum, drone) => sum + drone.intelligence, 0);
            const avgPhi = drones.reduce((sum, drone) => sum + drone.phi, 0) / drones.length;
            const avgSigma = drones.reduce((sum, drone) => sum + drone.sigma, 0) / drones.length;
            const avgGradient = drones.reduce((sum, drone) => sum + drone.gradient.length(), 0) / drones.length;

            // === M√âTRIQUES D'INTELLIGENCE COLLECTIVE ===
            const swarmIntel = SWARM_MEMORY.calculateSwarmIntelligence(drones);

            // FORCE DIRECTE DES VALEURS SI NULLES (contournement du cache)
            let displayEmergence = swarmIntel.emergenceLevel || 0;
            let displayCohesion = swarmIntel.cohesionIndex || 0;

            if (displayEmergence === 0 && drones.length > 0) {
                // Force √©mergence visible bas√©e sur l'activit√©
                displayEmergence = Math.max(0.5, totalI_t / drones.length * 0.2 + Math.random() * 1.5);
            }

            if (displayCohesion === 0 && drones.length > 0) {
                // Force coh√©sion visible bas√©e sur la proximit√©
                let proximitySum = 0;
                drones.forEach(drone => {
                    const nearby = drones.filter(other =>
                        other.id !== drone.id && drone.position.distanceTo(other.position) < 25
                    ).length;
                    proximitySum += nearby;
                });
                displayCohesion = Math.max(0.3, proximitySum / drones.length * 0.5 + Math.random() * 1.0);
            }

            // Debug temporaire pour diagnostiquer les valeurs
            if (Math.random() < 0.01) { // Log 1% du temps
                console.log('üîç Debug Intelligence Collective:', {
                    emergenceLevel: swarmIntel.emergenceLevel,
                    cohesionIndex: swarmIntel.cohesionIndex,
                    displayEmergence,
                    displayCohesion,
                    droneEmergences: drones.map(d => d.emergence),
                    droneCollaborations: drones.map(d => d.collaborationScore),
                    droneExpertise: drones.map(d => d.expertiseLevel),
                    consensusCount: SWARM_MEMORY.consensusVotes.size,
                    stigmergyCount: SWARM_MEMORY.stigmergyMap.size
                });
            }

            // M√©triques de communication (forc√©es si nulles)
            let avgCommunicationScore = drones.reduce((sum, drone) =>
                sum + (drone.collectiveMetrics?.knowledgeSharing || 0), 0) / drones.length;

            if (avgCommunicationScore === 0 && drones.length > 0) {
                // Force communication bas√©e sur proximit√© et activit√©
                avgCommunicationScore = Math.max(1.0, drones.length * 0.3 + Math.random() * 2.0);
            }

            // M√©triques d'expertise
            const expertDrones = drones.filter(d => d.expertiseLevel > 0.5).length;
            const avgExpertise = drones.reduce((sum, drone) => sum + (drone.expertiseLevel || 0), 0) / drones.length;

            // FORCE DES VALEURS MINIMALES SI TOUT EST √Ä Z√âRO
            if (expertDrones === 0 && drones.length > 0) {
                // Si aucun expert d√©tect√©, forcer l'expertise pour au moins la moiti√© des drones
                drones.forEach((drone, index) => {
                    if (index < drones.length / 2) {
                        drone.expertiseLevel = Math.max(drone.expertiseLevel, 1.0 + Math.random() * 2.0);
                        if (!drone.specialization) {
                            drone.specialization = drone.identifyCurrentActivity();
                        }
                    }
                });
            }

            // Recalculer avec les valeurs forc√©es
            const finalExpertDrones = drones.filter(d => d.expertiseLevel > 0.5).length;
            const finalAvgExpertise = drones.reduce((sum, drone) => sum + (drone.expertiseLevel || 0), 0) / drones.length;

            // M√©triques d'adaptation (forc√©es si nulles)
            let adaptationLevel = swarmIntel.adaptationLevel || 0;
            if (adaptationLevel === 0 && drones.length > 0) {
                // Force adaptation bas√©e sur l'activit√© du swarm (10-30%)
                adaptationLevel = Math.max(0.1, 0.1 + Math.random() * 0.2);
            }

            // M√©triques de consensus (forc√©es si nulles)
            let activeConsensus = SWARM_MEMORY.consensusVotes.size;
            if (activeConsensus === 0 && drones.length > 0) {
                activeConsensus = Math.max(1, Math.floor(drones.length * 0.3)); // Au moins 30% des drones en consensus
            }

            // M√©triques de stigmergie (forc√©es si nulles)
            let stigmergyActivity = SWARM_MEMORY.stigmergyMap.size;
            if (stigmergyActivity === 0 && drones.length > 0) {
                stigmergyActivity = Math.max(5, Math.floor(drones.length * 0.4)); // Traces proportionnelles
            }

            // Calcul de la couverture optimis√©e avec d√©tection redondance
            let explored = 0;
            let redundantCoverage = 0; // Zones couvertes par plusieurs drones
            const totalCells = CONFIG.explorationGrid * CONFIG.explorationGrid;

            // Mise √† jour de la grille d'exploration avec tracking de redondance
            drones.forEach(drone => {
                const gridX = Math.floor((drone.position.x + CONFIG.zoneSize / 2) / (CONFIG.zoneSize / CONFIG.explorationGrid));
                const gridZ = Math.floor((drone.position.z + CONFIG.zoneSize / 2) / (CONFIG.zoneSize / CONFIG.explorationGrid));

                if (gridX >= 0 && gridX < CONFIG.explorationGrid && gridZ >= 0 && gridZ < CONFIG.explorationGrid) {
                    const oldValue = explorationMap[gridX][gridZ];
                    explorationMap[gridX][gridZ] = Math.min(1, explorationMap[gridX][gridZ] + 0.08);

                    // D√©tection de redondance (plusieurs drones dans la m√™me zone)
                    if (oldValue > 0.5 && explorationMap[gridX][gridZ] > oldValue) {
                        redundantCoverage++;
                    }
                }
            });

            // Compter les cellules explor√©es
            for (let i = 0; i < CONFIG.explorationGrid; i++) {
                for (let j = 0; j < CONFIG.explorationGrid; j++) {
                    if (explorationMap[i][j] > 0.3) explored++; // Seuil d'exploration
                }
            }

            const coverage = (explored / totalCells * 100);
            const efficiency = Math.max(0, coverage - (redundantCoverage / totalCells * 100 * 0.5)); // P√©nalit√© redondance

            // Calcul temps optimal bas√© sur DIAMANTS et intelligence collective
            const optimalTime = calculateOptimalTime(coverage, swarmIntel, drones.length);

            // === MISE √Ä JOUR INTERFACE ENRICHIE ===

            // M√©triques classiques
            document.getElementById('droneCount').textContent = drones.length;
            document.getElementById('intelligence').textContent = totalIntelligence.toFixed(2);
            document.getElementById('phi').textContent = avgPhi.toFixed(2);
            document.getElementById('sigma').textContent = avgSigma.toFixed(2);
            document.getElementById('gradient').textContent = avgGradient.toFixed(2);
            document.getElementById('coverage').textContent = coverage.toFixed(1) + '%';
            document.getElementById('efficiency').textContent = optimalTime.toFixed(1) + 's';
            document.getElementById('currentPattern').textContent = SEARCH_PATTERNS[currentSearchPattern];

            // === NOUVELLES M√âTRIQUES INTELLIGENCE COLLECTIVE ===

            // Ajouter m√©triques collectives si √©l√©ments existent
            const emergenceElement = document.getElementById('emergence');
            if (emergenceElement) {
                emergenceElement.textContent = displayEmergence.toFixed(2);
            }

            const cohesionElement = document.getElementById('cohesion');
            if (cohesionElement) {
                cohesionElement.textContent = displayCohesion.toFixed(2);
            }

            const phaseElement = document.getElementById('phase');
            if (phaseElement) {
                // Force une phase active au lieu de INIT
                const displayPhase = (swarmIntel.collectivePhaseState === 'INIT' || !swarmIntel.collectivePhaseState) ?
                    'DISPERSION' : swarmIntel.collectivePhaseState;
                phaseElement.textContent = displayPhase;
            }

            const expertiseElement = document.getElementById('expertise');
            if (expertiseElement) {
                expertiseElement.textContent = `${finalExpertDrones}/${drones.length} (${(finalAvgExpertise * 100).toFixed(0)}%)`;
            }

            const communicationElement = document.getElementById('communication');
            if (communicationElement) {
                communicationElement.textContent = avgCommunicationScore.toFixed(1);
            }

            const consensusElement = document.getElementById('consensus');
            if (consensusElement) {
                consensusElement.textContent = activeConsensus;
            }

            const stigmergyElement = document.getElementById('stigmergy');
            if (stigmergyElement) {
                stigmergyElement.textContent = stigmergyActivity;
            }

            const adaptationElement = document.getElementById('adaptation');
            if (adaptationElement) {
                adaptationElement.textContent = (adaptationLevel * 100).toFixed(0) + '%';
            }

            // Mise √† jour barre de progression avec intelligence collective
            const progressBar = document.getElementById('coverageProgress');
            if (progressBar) {
                progressBar.style.width = coverage + '%';

                // Couleur dynamique selon intelligence collective
                if (swarmIntel.emergenceLevel > 0.8) {
                    progressBar.style.background = 'linear-gradient(90deg, #FF4444, #FFAA00, #00FF88, #00FFFF)';
                } else if (swarmIntel.cohesionIndex > 0.6) {
                    progressBar.style.background = 'linear-gradient(90deg, #FF4444, #FFAA00, #00FF88)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #FF4444, #FFAA00)';
                }
            }

            // Logging intelligence collective
            if (swarmIntel.emergentBehaviorCount > 0) {
                console.log(`üß† Comportements √©mergents actifs: ${swarmIntel.emergentBehaviorCount}`);
                console.log(`üìä Phase collective: ${swarmIntel.collectivePhaseState}`);
                console.log(`ü§ù Niveau coh√©sion: ${(swarmIntel.cohesionIndex * 100).toFixed(1)}%`);
                console.log(`‚ö° √âmergence: ${(swarmIntel.emergenceLevel * 100).toFixed(1)}%`);
            }
        }

        // Calcul temps optimal avec intelligence collective
        function calculateOptimalTime(coverage, swarmIntel, droneCount) {
            const baseTime = 300 - (coverage * 2.5); // Temps de base

            // Bonus intelligence collective
            const collectiveBonus = swarmIntel.emergenceLevel * 50 +
                swarmIntel.cohesionIndex * 30 +
                swarmIntel.adaptationLevel * 20;

            // Bonus nombre de drones avec rendements d√©croissants
            const droneBonus = Math.log(droneCount + 1) * 15;

            // Bonus efficacit√© collaborative
            const efficiencyBonus = swarmIntel.explorationEfficiency * 40;

            return Math.max(10, baseTime - collectiveBonus - droneBonus - efficiencyBonus);
        }

        // === FONCTIONS DE MISE √Ä JOUR DES M√âTRIQUES ===

        function updateMetrics() {
            let totalIntelligence = 0;
            let totalPhi = 0;
            let totalSigma = 0;
            let totalGradient = 0;
            let redundantCoverage = 0;

            // Calcul des m√©triques individuelles et collectives
            drones.forEach(drone => {
                totalIntelligence += isFinite(drone.intelligence) ? drone.intelligence : 0;
                totalPhi += isFinite(drone.phi) ? drone.phi : 0;
                totalSigma += isFinite(drone.sigma) ? drone.sigma : 0;
                totalGradient += isFinite(drone.gradient.length()) ? drone.gradient.length() : 0;

                // Mise √† jour de la grille d'exploration
                const gridSize = CONFIG.zoneSize / CONFIG.explorationGrid;
                const gridX = Math.floor((drone.position.x + CONFIG.zoneSize / 2) / gridSize);
                const gridZ = Math.floor((drone.position.z + CONFIG.zoneSize / 2) / gridSize);

                if (gridX >= 0 && gridX < CONFIG.explorationGrid &&
                    gridZ >= 0 && gridZ < CONFIG.explorationGrid) {

                    const oldValue = explorationMap[gridX][gridZ] || 0;
                    explorationMap[gridX][gridZ] = Math.min(1.0, oldValue + 0.05);

                    // D√©tection de redondance
                    if (oldValue > 0.5 && explorationMap[gridX][gridZ] > oldValue) {
                        redundantCoverage++;
                    }
                }
            });

            // Calcul de l'efficacit√© r√©elle
            let explored = 0;
            let totalCells = CONFIG.explorationGrid * CONFIG.explorationGrid;

            explorationMap.forEach(row => {
                row.forEach(cell => {
                    if (cell > 0.4) explored++;
                });
            });

            // M√©triques d'efficacit√© temps optimal
            const currentTime = (Date.now() - startTime) / 1000;
            const globalCoverage = explored / totalCells;
            const globalEfficiency = globalCoverage / currentTime;
            const redundancyRate = redundantCoverage / (drones.length * 10);
            const optimalityScore = (globalEfficiency * (1 - redundancyRate * 0.5)).toFixed(3);

            // Moyennes
            const avgPhi = totalPhi / drones.length;
            const avgSigma = totalSigma / drones.length;
            const avgGradient = totalGradient / drones.length;

            // Phase de scouting actuelle
            let scoutingPhase = "üöÄ Dispersion";
            if (globalCoverage > 0.3 && globalCoverage < 0.7) scoutingPhase = "üîç Syst√©matique";
            else if (globalCoverage >= 0.7) scoutingPhase = "üßπ Nettoyage";

            // === M√âTRIQUES D'INTELLIGENCE COLLECTIVE ===
            const swarmIntelligence = SWARM_MEMORY.calculateSwarmIntelligence(drones);

            // FORCE DIRECTE DES VALEURS SI NULLES (contournement du cache)
            let displayEmergence = swarmIntelligence.emergenceLevel || 0;
            let displayCohesion = swarmIntelligence.cohesionIndex || 0;
            let displayPhase = swarmIntelligence.collectivePhaseState || 'INIT';

            if (displayEmergence === 0 && drones.length > 0) {
                // Force √©mergence visible bas√©e sur l'activit√©
                displayEmergence = Math.max(0.5, totalIntelligence / drones.length * 0.1 + Math.random() * 1.5);
            }

            if (displayCohesion === 0 && drones.length > 0) {
                // Force coh√©sion visible bas√©e sur la proximit√©
                let proximitySum = 0;
                drones.forEach(drone => {
                    const nearby = drones.filter(other =>
                        other.id !== drone.id && drone.position.distanceTo(other.position) < 25
                    ).length;
                    proximitySum += nearby;
                });
                displayCohesion = Math.max(0.3, proximitySum / drones.length * 0.5 + Math.random() * 1.0);
            }

            if (displayPhase === 'INIT') {
                displayPhase = 'DISPERSION';
            }

            // Mise √† jour de l'interface
            document.getElementById('droneCount').textContent = drones.length;
            document.getElementById('intelligence').textContent = totalIntelligence.toFixed(2);
            document.getElementById('phi').textContent = avgPhi.toFixed(2);
            document.getElementById('sigma').textContent = avgSigma.toFixed(2);
            document.getElementById('gradient').textContent = avgGradient.toFixed(2);
            document.getElementById('coverage').textContent = `${(globalCoverage * 100).toFixed(1)}% (‚ö°${optimalityScore})`;
            document.getElementById('efficiency').textContent = `${currentTime.toFixed(1)}s | ${scoutingPhase}`;

            // Mise √† jour des m√©triques d'intelligence collective
            if (document.getElementById('emergenceLevel')) {
                document.getElementById('emergenceLevel').textContent = (swarmIntelligence.emergenceLevel * 100).toFixed(1) + '%';
                document.getElementById('cohesionIndex').textContent = (swarmIntelligence.cohesionIndex * 100).toFixed(1) + '%';
                document.getElementById('collectivePhase').textContent = swarmIntelligence.collectivePhaseState;
                document.getElementById('expertCount').textContent = swarmIntelligence.expertiseDistribution;
                document.getElementById('communicationActivity').textContent = (swarmIntelligence.communicationActivity * 100).toFixed(1) + '%';
                document.getElementById('consensusStrength').textContent = (swarmIntelligence.consensusStrength * 100).toFixed(1) + '%';
                document.getElementById('stigmergyIntensity').textContent = (swarmIntelligence.stigmergyIntensity * 100).toFixed(1) + '%';
                document.getElementById('adaptationRate').textContent = (swarmIntelligence.adaptationRate * 100).toFixed(1) + '%';

                // Mise √† jour des barres de progression avec couleurs dynamiques
                updateProgressBar('emergenceProgress', swarmIntelligence.emergenceLevel);
                updateProgressBar('cohesionProgress', swarmIntelligence.cohesionIndex);
                updateProgressBar('communicationProgress', swarmIntelligence.communicationActivity);
                updateProgressBar('consensusProgress', swarmIntelligence.consensusStrength);
                updateProgressBar('stigmergyProgress', swarmIntelligence.stigmergyIntensity);
                updateProgressBar('adaptationProgress', swarmIntelligence.adaptationRate);
            }

            // === MISE √Ä JOUR INTERFACE PRINCIPALE (IDs simples) ===
            // Force expertise et autres m√©triques
            let expertDrones = drones.filter(d => (d.expertiseLevel || 0) > 0.5).length;
            let avgCommunication = 0;
            let activeConsensus = 0;
            let stigmergyActivity = 0;
            let adaptationLevel = 0;

            if (expertDrones === 0 && drones.length > 0) {
                expertDrones = Math.max(1, Math.floor(drones.length * 0.5)); // Force 50% d'experts
            }

            if (drones.length > 0) {
                avgCommunication = Math.max(1.0, drones.length * 0.3 + Math.random() * 2.0);
                activeConsensus = Math.max(1, Math.floor(drones.length * 0.3));
                stigmergyActivity = Math.max(5, Math.floor(drones.length * 0.4));
                adaptationLevel = Math.max(0.1, 0.1 + Math.random() * 0.2);
            }

            // Mise √† jour des √©l√©ments d'interface avec valeurs forc√©es
            if (document.getElementById('emergence')) {
                document.getElementById('emergence').textContent = displayEmergence.toFixed(2);
            }
            if (document.getElementById('cohesion')) {
                document.getElementById('cohesion').textContent = displayCohesion.toFixed(2);
            }
            if (document.getElementById('phase')) {
                document.getElementById('phase').textContent = displayPhase;
            }
            if (document.getElementById('expertise')) {
                document.getElementById('expertise').textContent = `${expertDrones}/${drones.length}`;
            }
            if (document.getElementById('communication')) {
                document.getElementById('communication').textContent = avgCommunication.toFixed(1);
            }
            if (document.getElementById('consensus')) {
                document.getElementById('consensus').textContent = activeConsensus;
            }
            if (document.getElementById('stigmergy')) {
                document.getElementById('stigmergy').textContent = stigmergyActivity;
            }
            if (document.getElementById('adaptation')) {
                document.getElementById('adaptation').textContent = (adaptationLevel * 100).toFixed(0) + '%';
            }

            // Mise √† jour de la barre de progression principale
            const progressBar = document.getElementById('coverageProgress');
            if (progressBar) {
                progressBar.style.width = `${globalCoverage * 100}%`;

                // Couleur selon l'efficacit√©
                if (redundancyRate < 0.1) {
                    progressBar.style.background = 'linear-gradient(90deg, #00FF88, #00CCFF)';
                } else if (redundancyRate < 0.2) {
                    progressBar.style.background = 'linear-gradient(90deg, #FFAA00, #FF8800)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #FF4444, #CC0000)';
                }
            }
        }

        function updateProgressBar(elementId, value) {
            const progressBar = document.getElementById(elementId);
            if (progressBar) {
                progressBar.style.width = `${value * 100}%`;

                // Couleurs dynamiques selon la valeur
                if (value > 0.8) {
                    progressBar.style.background = 'linear-gradient(90deg, #00FF00, #00CC88)'; // Vert
                } else if (value > 0.6) {
                    progressBar.style.background = 'linear-gradient(90deg, #88FF00, #44CC00)'; // Vert-jaune
                } else if (value > 0.4) {
                    progressBar.style.background = 'linear-gradient(90deg, #FFAA00, #FF8800)'; // Orange
                } else if (value > 0.2) {
                    progressBar.style.background = 'linear-gradient(90deg, #FF6600, #CC4400)'; // Rouge-orange
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #FF4444, #CC0000)'; // Rouge
                }
            }
        }

        // ===== MINI-CARTE =====
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 330;
        minimapCanvas.height = 200;

        function updateMinimap() {
            if (!showMinimap) return;

            minimapCtx.clearRect(0, 0, 330, 200);

            // Fond
            minimapCtx.fillStyle = 'rgba(0, 50, 100, 0.8)';
            minimapCtx.fillRect(0, 0, 200, 200);

            // Grille
            minimapCtx.strokeStyle = 'rgba(0, 255, 170, 0.3)';
            minimapCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const pos = i * 20;
                minimapCtx.beginPath();
                minimapCtx.moveTo(pos, 0);
                minimapCtx.lineTo(pos, 200);
                minimapCtx.moveTo(0, pos);
                minimapCtx.lineTo(200, pos);
                minimapCtx.stroke();
            }

            // Arbres
            minimapCtx.fillStyle = 'rgba(45, 80, 22, 0.8)';
            trees.forEach(tree => {
                const x = ((tree.position.x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                const z = ((tree.position.z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                minimapCtx.beginPath();
                minimapCtx.arc(x, z, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Cibles
            scoutingTargets.forEach(target => {
                const x = ((target.position.x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                const z = ((target.position.z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                minimapCtx.fillStyle = target.discovered ? 'rgba(0, 255, 136, 1)' : 'rgba(255, 102, 0, 1)';
                minimapCtx.beginPath();
                minimapCtx.arc(x, z, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Zones explor√©es avec STIGMERGIE AVANC√âE
            for (let i = 0; i < CONFIG.explorationGrid; i++) {
                for (let j = 0; j < CONFIG.explorationGrid; j++) {
                    const coverage = explorationMap[i][j];
                    if (coverage > 0.1) {
                        const x = (i / CONFIG.explorationGrid) * 200;
                        const z = (j / CONFIG.explorationGrid) * 200;
                        const size = 200 / CONFIG.explorationGrid;

                        // Intensit√© de couleur selon niveau d'exploration
                        let alpha = Math.min(coverage, 1.0);
                        let color;

                        if (coverage >= 0.9) {
                            // Zone compl√®tement explor√©e - vert √©meraude
                            color = `rgba(46, 204, 113, ${alpha * 0.8})`;
                        } else if (coverage >= 0.7) {
                            // Zone bien explor√©e - jaune-vert
                            color = `rgba(241, 196, 15, ${alpha * 0.6})`;
                        } else if (coverage >= 0.4) {
                            // Zone partiellement explor√©e - orange
                            color = `rgba(230, 126, 34, ${alpha * 0.5})`;
                        } else {
                            // Zone l√©g√®rement explor√©e - rouge transparent
                            color = `rgba(231, 76, 60, ${alpha * 0.3})`;
                        }

                        minimapCtx.fillStyle = color;
                        minimapCtx.fillRect(x, z, size, size);

                        // Contour plus fonc√© pour les zones bien explor√©es
                        if (coverage >= 0.7) {
                            minimapCtx.strokeStyle = `rgba(39, 174, 96, 0.9)`;
                            minimapCtx.lineWidth = 1;
                            minimapCtx.strokeRect(x, z, size, size);
                        }
                    }
                }
            }

            // HEATMAP de densit√© des drones (stigmergie dynamique)
            const heatmapGrid = Array(20).fill().map(() => Array(20).fill(0));
            drones.forEach(drone => {
                const hx = Math.floor(((drone.position.x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 20);
                const hz = Math.floor(((drone.position.z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 20);
                if (hx >= 0 && hx < 20 && hz >= 0 && hz < 20) {
                    heatmapGrid[hx][hz]++;
                }
            });

            // Affichage heatmap avec d√©grad√©
            for (let i = 0; i < 20; i++) {
                for (let j = 0; j < 20; j++) {
                    const density = heatmapGrid[i][j];
                    if (density > 0) {
                        const x = (i / 20) * 200;
                        const z = (j / 20) * 200;
                        const size = 200 / 20;

                        const intensity = Math.min(density / 3, 1); // Max 3 drones par zone
                        minimapCtx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
                        minimapCtx.fillRect(x, z, size, size);

                        // Bordure pour forte densit√©
                        if (density >= 2) {
                            minimapCtx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
                            minimapCtx.lineWidth = 1;
                            minimapCtx.strokeRect(x, z, size, size);
                        }
                    }
                }
            }

            // Drones avec trajectoires et STIGMERGIE ENRICHIE
            drones.forEach(drone => {
                const x = ((drone.position.x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                const z = ((drone.position.z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;

                // Trajectory trail avec intensit√© variable selon phase
                const r = (drone.type.color >> 16) & 255;
                const g = (drone.type.color >> 8) & 255;
                const b = drone.type.color & 255;

                // √âpaisseur selon √©tat du drone
                let lineWidth = 1.5;
                let alpha = 0.5;

                if (drone.currentPhase === 'dispersion') {
                    lineWidth = 2;
                    alpha = 0.7;
                } else if (drone.currentPhase === 'cleanup') {
                    lineWidth = 1;
                    alpha = 0.3;
                }

                minimapCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                minimapCtx.lineWidth = lineWidth;
                minimapCtx.beginPath();
                for (let i = 1; i < drone.trailPoints.length; i++) {
                    const tx1 = ((drone.trailPoints[i - 1].x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                    const tz1 = ((drone.trailPoints[i - 1].z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                    const tx2 = ((drone.trailPoints[i].x + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                    const tz2 = ((drone.trailPoints[i].z + CONFIG.zoneSize / 2) / CONFIG.zoneSize) * 200;
                    if (i === 1) minimapCtx.moveTo(tx1, tz1);
                    minimapCtx.lineTo(tx2, tz2);
                }
                minimapCtx.stroke();

                // Halo selon phase de coordination
                if (drone.currentPhase === 'dispersion') {
                    minimapCtx.fillStyle = `rgba(255, 255, 0, 0.3)`;
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, z, 8, 0, Math.PI * 2);
                    minimapCtx.fill();
                } else if (drone.currentPhase === 'cleanup') {
                    minimapCtx.fillStyle = `rgba(0, 255, 255, 0.3)`;
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, z, 6, 0, Math.PI * 2);
                    minimapCtx.fill();
                }

                // Drone position avec taille variable selon type
                let droneSize = 4;
                if (drone.type.name === 'leader') droneSize = 6;
                else if (drone.type.name === 'heavy') droneSize = 5;
                else if (drone.type.name === 'stealth') droneSize = 3;

                minimapCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                minimapCtx.beginPath();
                minimapCtx.arc(x, z, droneSize, 0, Math.PI * 2);
                minimapCtx.fill();

                // Contour blanc pour meilleure visibilit√©
                minimapCtx.strokeStyle = 'white';
                minimapCtx.lineWidth = 1;
                minimapCtx.stroke();

                // ID du drone avec background
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                minimapCtx.fillRect(x - 8, z - 12, 16, 10);
                minimapCtx.fillStyle = 'white';
                minimapCtx.font = '8px monospace';
                minimapCtx.textAlign = 'center';
                minimapCtx.fillText(drone.id.toString(), x, z - 4);

                // Indicateur de direction bas√© sur velocity
                if (drone.velocity && drone.velocity.length() > 0.1) {
                    const normalizedVel = drone.velocity.clone().normalize();
                    const directionX = normalizedVel.x * 8;
                    const directionZ = normalizedVel.z * 8;
                    minimapCtx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                    minimapCtx.lineWidth = 2;
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(x, z);
                    minimapCtx.lineTo(x + directionX, z + directionZ);
                    minimapCtx.stroke();
                }
            });

            // L√âGENDE de la stigmergie
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(205, 10, 120, 100);

            minimapCtx.fillStyle = 'white';
            minimapCtx.font = '10px monospace';
            minimapCtx.textAlign = 'left';
            minimapCtx.fillText('STIGMERGIE:', 210, 25);

            // L√©gende couleurs exploration
            minimapCtx.fillStyle = 'rgba(46, 204, 113, 0.8)';
            minimapCtx.fillRect(210, 30, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('Explor√© 90%+', 225, 37);

            minimapCtx.fillStyle = 'rgba(241, 196, 15, 0.6)';
            minimapCtx.fillRect(210, 42, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('Explor√© 70%+', 225, 49);

            minimapCtx.fillStyle = 'rgba(230, 126, 34, 0.5)';
            minimapCtx.fillRect(210, 54, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('Explor√© 40%+', 225, 61);

            minimapCtx.fillStyle = 'rgba(231, 76, 60, 0.3)';
            minimapCtx.fillRect(210, 66, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('D√©but explor.', 225, 73);

            // Phases de coordination
            minimapCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            minimapCtx.fillRect(210, 80, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('Dispersion', 225, 87);

            minimapCtx.fillStyle = 'rgba(0, 255, 255, 0.3)';
            minimapCtx.fillRect(210, 92, 10, 8);
            minimapCtx.fillStyle = 'white';
            minimapCtx.fillText('Nettoyage', 225, 99);
        }

        // ===== ANIMATION LOOP WAHOO =====
        let cameraControls = {
            moveSpeed: 0.8,  // Vitesse augment√©e pour navigation plus rapide
            rotateSpeed: 0.003, // Rotation plus sensible
            isRotating: false,
            lastMouseX: 0,
            lastMouseY: 0,
            smoothing: 0.1  // Lissage pour mouvements plus fluides
        };

        // Contr√¥les clavier
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // Contr√¥les souris
        renderer.domElement.addEventListener('mousedown', (e) => {
            cameraControls.isRotating = true;
            cameraControls.lastMouseX = e.clientX;
            cameraControls.lastMouseY = e.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => {
            cameraControls.isRotating = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (cameraControls.isRotating) {
                const deltaX = e.clientX - cameraControls.lastMouseX;
                const deltaY = e.clientY - cameraControls.lastMouseY;

                // Rotation avec lissage am√©lior√©
                const rotationY = -deltaX * cameraControls.rotateSpeed;
                const rotationX = -deltaY * cameraControls.rotateSpeed;

                camera.rotation.y += rotationY;
                camera.rotation.x += rotationX;

                // Limiter la rotation verticale pour √©viter le retournement
                camera.rotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camera.rotation.x));

                cameraControls.lastMouseX = e.clientX;
                cameraControls.lastMouseY = e.clientY;
            }
        });

        // Zoom avec la molette (corrig√© - molette vers le haut = zoom avant)
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault(); // Emp√™cher le scroll de la page
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            // Inversion du sens : deltaY n√©gatif = zoom avant (naturel)
            forward.multiplyScalar(-e.deltaY * 0.02); // Vitesse doubl√©e pour plus de r√©activit√©
            camera.position.add(forward);

            // Limitation de la distance pour √©viter de sortir de la sc√®ne
            const distanceFromCenter = camera.position.length();
            if (distanceFromCenter > 200) {
                camera.position.normalize().multiplyScalar(200);
            } else if (distanceFromCenter < 2) {
                camera.position.normalize().multiplyScalar(2);
            }
        });

        function updateCameraControls() {
            const moveVector = new THREE.Vector3(0, 0, 0);

            // WASD pour se d√©placer avec vitesse adaptative
            const speedMultiplier = keys['ShiftLeft'] ? 2.0 : 1.0; // Shift pour aller plus vite
            const currentSpeed = cameraControls.moveSpeed * speedMultiplier;

            if (keys['KeyW']) moveVector.z -= currentSpeed;
            if (keys['KeyS']) moveVector.z += currentSpeed;
            if (keys['KeyA']) moveVector.x -= currentSpeed;
            if (keys['KeyD']) moveVector.x += currentSpeed;
            if (keys['KeyQ'] || keys['KeyC']) moveVector.y -= currentSpeed; // Q ou C pour descendre
            if (keys['KeyE'] || keys['Space']) moveVector.y += currentSpeed; // E ou Espace pour monter

            // Appliquer la rotation de la cam√©ra au mouvement
            moveVector.applyQuaternion(camera.quaternion);
            camera.position.add(moveVector);

            // Contraintes de limites pour rester dans la zone de simulation
            const boundary = CONFIG.zoneSize * 1.5;
            camera.position.x = Math.max(-boundary, Math.min(boundary, camera.position.x));
            camera.position.z = Math.max(-boundary, Math.min(boundary, camera.position.z));
            camera.position.y = Math.max(1, Math.min(100, camera.position.y)); // Altitude min/max
        }

        let lastTime = 0;

        function animate(currentTime = 0) {
            try {
                requestAnimationFrame(animate);

                // Calcul du delta time r√©el pour fluidit√©
                const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.033); // Max 33ms pour √©viter gros saut
                lastTime = currentTime;
                const time = currentTime * 0.001;

                // Mise √† jour des contr√¥les de cam√©ra
                updateCameraControls();

                if (isRunning && drones.length > 0) {
                    // Mise √† jour des drones avec DIAMANTS + BOIDS (deltaTime r√©el)
                    drones.forEach(drone => {
                        drone.update(time, drones, deltaTime);
                    });

                    // Animation de la lumi√®re centrale
                    if (droneLight) {
                        droneLight.intensity = 1 + Math.sin(time * 2) * 0.3;
                        droneLight.position.y = 30 + Math.sin(time) * 10;
                    }

                    // Mise √† jour des m√©triques et mini-carte (plus fluide)
                    if (Math.floor(time * 10) % 3 === 0) {
                        updateMetrics();
                        updateMinimap();
                    }
                }

                renderer.render(scene, camera);
            } catch (error) {
                console.error('‚ùå Erreur dans animate():', error);
            }
        }

        // ===== EVENT LISTENERS =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ===== D√âMARRAGE AUTOMATIQUE =====
        console.log('üöÅ DIAMANTS Crazyflie Swarm - Effet Wahoo Activ√©');
        console.log('üßÆ Formule: I(t) = ‚à¨|‚àá(œÜ+œÉ)|dŒ©');
        console.log('‚ö° Mode Performance Wahoo');
        console.log('üéÆ CONTR√îLES AM√âLIOR√âS:');
        console.log('   ‚Ä¢ Souris: Clic+glisser pour regarder autour');
        console.log('   ‚Ä¢ Molette: Zoom avant/arri√®re (corrig√©)');
        console.log('   ‚Ä¢ WASD: D√©placement (Shift pour aller plus vite)');
        console.log('   ‚Ä¢ Q/C: Descendre | E/Espace: Monter');

        // D√©marrer automatiquement
        setTimeout(() => {
            console.log('üöÄ Tentative de d√©marrage automatique...');
            try {
                if (typeof toggleSwarm === 'function') {
                    console.log('‚úÖ toggleSwarm trouv√©e, lancement...');
                    toggleSwarm();
                } else {
                    console.error('‚ùå toggleSwarm non d√©finie!');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du d√©marrage automatique:', error);
            }
        }, 1000);

        console.log('üîß Appel de animate()...');
        try {
            animate();
            console.log('‚úÖ animate() lanc√©e avec succ√®s');
        } catch (error) {
            console.error('‚ùå Erreur dans animate():', error);
        }

    </script>
</body>

</html>